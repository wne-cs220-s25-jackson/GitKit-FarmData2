"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandaloneServices = exports.standaloneEditorWorkerDescriptor = exports.StandaloneConfigurationService = exports.StandaloneKeybindingService = exports.StandaloneCommandService = exports.StandaloneNotificationService = void 0;
exports.updateConfigurationService = updateConfigurationService;
require("./standaloneCodeEditorService.js");
require("./standaloneLayoutService.js");
require("../../../platform/undoRedo/common/undoRedoService.js");
require("../../common/services/languageFeatureDebounce.js");
require("../../common/services/semanticTokensStylingService.js");
require("../../common/services/languageFeaturesService.js");
require("../../browser/services/hoverService/hoverService.js");
const strings = require("../../../base/common/strings.js");
const dom = require("../../../base/browser/dom.js");
const keyboardEvent_js_1 = require("../../../base/browser/keyboardEvent.js");
const event_js_1 = require("../../../base/common/event.js");
const keybindings_js_1 = require("../../../base/common/keybindings.js");
const lifecycle_js_1 = require("../../../base/common/lifecycle.js");
const platform_js_1 = require("../../../base/common/platform.js");
const severity_js_1 = require("../../../base/common/severity.js");
const uri_js_1 = require("../../../base/common/uri.js");
const bulkEditService_js_1 = require("../../browser/services/bulkEditService.js");
const editorConfigurationSchema_js_1 = require("../../common/config/editorConfigurationSchema.js");
const editOperation_js_1 = require("../../common/core/editOperation.js");
const position_js_1 = require("../../common/core/position.js");
const range_js_1 = require("../../common/core/range.js");
const model_js_1 = require("../../common/services/model.js");
const resolverService_js_1 = require("../../common/services/resolverService.js");
const textResourceConfiguration_js_1 = require("../../common/services/textResourceConfiguration.js");
const commands_js_1 = require("../../../platform/commands/common/commands.js");
const configuration_js_1 = require("../../../platform/configuration/common/configuration.js");
const configurationModels_js_1 = require("../../../platform/configuration/common/configurationModels.js");
const contextkey_js_1 = require("../../../platform/contextkey/common/contextkey.js");
const dialogs_js_1 = require("../../../platform/dialogs/common/dialogs.js");
const instantiation_js_1 = require("../../../platform/instantiation/common/instantiation.js");
const abstractKeybindingService_js_1 = require("../../../platform/keybinding/common/abstractKeybindingService.js");
const keybinding_js_1 = require("../../../platform/keybinding/common/keybinding.js");
const keybindingResolver_js_1 = require("../../../platform/keybinding/common/keybindingResolver.js");
const keybindingsRegistry_js_1 = require("../../../platform/keybinding/common/keybindingsRegistry.js");
const resolvedKeybindingItem_js_1 = require("../../../platform/keybinding/common/resolvedKeybindingItem.js");
const usLayoutResolvedKeybinding_js_1 = require("../../../platform/keybinding/common/usLayoutResolvedKeybinding.js");
const label_js_1 = require("../../../platform/label/common/label.js");
const notification_js_1 = require("../../../platform/notification/common/notification.js");
const progress_js_1 = require("../../../platform/progress/common/progress.js");
const telemetry_js_1 = require("../../../platform/telemetry/common/telemetry.js");
const workspace_js_1 = require("../../../platform/workspace/common/workspace.js");
const layoutService_js_1 = require("../../../platform/layout/browser/layoutService.js");
const standaloneStrings_js_1 = require("../../common/standaloneStrings.js");
const resources_js_1 = require("../../../base/common/resources.js");
const codeEditorService_js_1 = require("../../browser/services/codeEditorService.js");
const log_js_1 = require("../../../platform/log/common/log.js");
const workspaceTrust_js_1 = require("../../../platform/workspace/common/workspaceTrust.js");
const contextView_js_1 = require("../../../platform/contextview/browser/contextView.js");
const contextViewService_js_1 = require("../../../platform/contextview/browser/contextViewService.js");
const languageService_js_1 = require("../../common/services/languageService.js");
const contextMenuService_js_1 = require("../../../platform/contextview/browser/contextMenuService.js");
const extensions_js_1 = require("../../../platform/instantiation/common/extensions.js");
const openerService_js_1 = require("../../browser/services/openerService.js");
const editorWorker_js_1 = require("../../common/services/editorWorker.js");
const editorWorkerService_js_1 = require("../../browser/services/editorWorkerService.js");
const language_js_1 = require("../../common/languages/language.js");
const markerDecorationsService_js_1 = require("../../common/services/markerDecorationsService.js");
const markerDecorations_js_1 = require("../../common/services/markerDecorations.js");
const modelService_js_1 = require("../../common/services/modelService.js");
const standaloneQuickInputService_js_1 = require("./quickInput/standaloneQuickInputService.js");
const standaloneThemeService_js_1 = require("./standaloneThemeService.js");
const standaloneTheme_js_1 = require("../common/standaloneTheme.js");
const accessibilityService_js_1 = require("../../../platform/accessibility/browser/accessibilityService.js");
const accessibility_js_1 = require("../../../platform/accessibility/common/accessibility.js");
const actions_js_1 = require("../../../platform/actions/common/actions.js");
const menuService_js_1 = require("../../../platform/actions/common/menuService.js");
const clipboardService_js_1 = require("../../../platform/clipboard/browser/clipboardService.js");
const clipboardService_js_2 = require("../../../platform/clipboard/common/clipboardService.js");
const contextKeyService_js_1 = require("../../../platform/contextkey/browser/contextKeyService.js");
const descriptors_js_1 = require("../../../platform/instantiation/common/descriptors.js");
const instantiationService_js_1 = require("../../../platform/instantiation/common/instantiationService.js");
const serviceCollection_js_1 = require("../../../platform/instantiation/common/serviceCollection.js");
const listService_js_1 = require("../../../platform/list/browser/listService.js");
const markers_js_1 = require("../../../platform/markers/common/markers.js");
const markerService_js_1 = require("../../../platform/markers/common/markerService.js");
const opener_js_1 = require("../../../platform/opener/common/opener.js");
const quickInput_js_1 = require("../../../platform/quickinput/common/quickInput.js");
const storage_js_1 = require("../../../platform/storage/common/storage.js");
const configurations_js_1 = require("../../../platform/configuration/common/configurations.js");
const accessibilitySignalService_js_1 = require("../../../platform/accessibilitySignal/browser/accessibilitySignalService.js");
const languageFeatures_js_1 = require("../../common/services/languageFeatures.js");
const languageConfigurationRegistry_js_1 = require("../../common/languages/languageConfigurationRegistry.js");
const logService_js_1 = require("../../../platform/log/common/logService.js");
const editorFeatures_js_1 = require("../../common/editorFeatures.js");
const errors_js_1 = require("../../../base/common/errors.js");
const environment_js_1 = require("../../../platform/environment/common/environment.js");
const window_js_1 = require("../../../base/browser/window.js");
const map_js_1 = require("../../../base/common/map.js");
const treeSitterParserService_js_1 = require("../../common/services/treeSitterParserService.js");
const standaloneTreeSitterService_js_1 = require("./standaloneTreeSitterService.js");
class SimpleModel {
    constructor(model) {
        this.disposed = false;
        this.model = model;
        this._onWillDispose = new event_js_1.Emitter();
    }
    get onWillDispose() {
        return this._onWillDispose.event;
    }
    resolve() {
        return Promise.resolve();
    }
    get textEditorModel() {
        return this.model;
    }
    createSnapshot() {
        return this.model.createSnapshot();
    }
    isReadonly() {
        return false;
    }
    dispose() {
        this.disposed = true;
        this._onWillDispose.fire();
    }
    isDisposed() {
        return this.disposed;
    }
    isResolved() {
        return true;
    }
    getLanguageId() {
        return this.model.getLanguageId();
    }
}
let StandaloneTextModelService = class StandaloneTextModelService {
    constructor(modelService) {
        this.modelService = modelService;
    }
    createModelReference(resource) {
        const model = this.modelService.getModel(resource);
        if (!model) {
            return Promise.reject(new Error(`Model not found`));
        }
        return Promise.resolve(new lifecycle_js_1.ImmortalReference(new SimpleModel(model)));
    }
    registerTextModelContentProvider(scheme, provider) {
        return {
            dispose: function () { }
        };
    }
    canHandleResource(resource) {
        return false;
    }
};
StandaloneTextModelService = __decorate([
    __param(0, model_js_1.IModelService)
], StandaloneTextModelService);
class StandaloneEditorProgressService {
    static { this.NULL_PROGRESS_RUNNER = {
        done: () => { },
        total: () => { },
        worked: () => { }
    }; }
    show() {
        return StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;
    }
    async showWhile(promise, delay) {
        await promise;
    }
}
class StandaloneProgressService {
    withProgress(_options, task, onDidCancel) {
        return task({
            report: () => { },
        });
    }
}
class StandaloneEnvironmentService {
    constructor() {
        this.stateResource = uri_js_1.URI.from({ scheme: 'monaco', authority: 'stateResource' });
        this.userRoamingDataHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'userRoamingDataHome' });
        this.keyboardLayoutResource = uri_js_1.URI.from({ scheme: 'monaco', authority: 'keyboardLayoutResource' });
        this.argvResource = uri_js_1.URI.from({ scheme: 'monaco', authority: 'argvResource' });
        this.untitledWorkspacesHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'untitledWorkspacesHome' });
        this.workspaceStorageHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'workspaceStorageHome' });
        this.localHistoryHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'localHistoryHome' });
        this.cacheHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'cacheHome' });
        this.userDataSyncHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'userDataSyncHome' });
        this.sync = undefined;
        this.continueOn = undefined;
        this.editSessionId = undefined;
        this.debugExtensionHost = { port: null, break: false };
        this.isExtensionDevelopment = false;
        this.disableExtensions = false;
        this.enableExtensions = undefined;
        this.extensionDevelopmentLocationURI = undefined;
        this.extensionDevelopmentKind = undefined;
        this.extensionTestsLocationURI = undefined;
        this.logsHome = uri_js_1.URI.from({ scheme: 'monaco', authority: 'logsHome' });
        this.logLevel = undefined;
        this.extensionLogLevel = undefined;
        this.verbose = false;
        this.isBuilt = false;
        this.disableTelemetry = false;
        this.serviceMachineIdResource = uri_js_1.URI.from({ scheme: 'monaco', authority: 'serviceMachineIdResource' });
        this.policyFile = undefined;
    }
}
class StandaloneDialogService {
    constructor() {
        this.onWillShowDialog = event_js_1.Event.None;
        this.onDidShowDialog = event_js_1.Event.None;
    }
    async confirm(confirmation) {
        const confirmed = this.doConfirm(confirmation.message, confirmation.detail);
        return {
            confirmed,
            checkboxChecked: false // unsupported
        };
    }
    doConfirm(message, detail) {
        let messageText = message;
        if (detail) {
            messageText = messageText + '\n\n' + detail;
        }
        return window_js_1.mainWindow.confirm(messageText);
    }
    async prompt(prompt) {
        let result = undefined;
        const confirmed = this.doConfirm(prompt.message, prompt.detail);
        if (confirmed) {
            const promptButtons = [...(prompt.buttons ?? [])];
            if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {
                promptButtons.push(prompt.cancelButton);
            }
            result = await promptButtons[0]?.run({ checkboxChecked: false });
        }
        return { result };
    }
    async info(message, detail) {
        await this.prompt({ type: severity_js_1.default.Info, message, detail });
    }
    async warn(message, detail) {
        await this.prompt({ type: severity_js_1.default.Warning, message, detail });
    }
    async error(message, detail) {
        await this.prompt({ type: severity_js_1.default.Error, message, detail });
    }
    input() {
        return Promise.resolve({ confirmed: false }); // unsupported
    }
    about() {
        return Promise.resolve(undefined);
    }
}
class StandaloneNotificationService {
    constructor() {
        this.onDidAddNotification = event_js_1.Event.None;
        this.onDidRemoveNotification = event_js_1.Event.None;
        this.onDidChangeFilter = event_js_1.Event.None;
    }
    static { this.NO_OP = new notification_js_1.NoOpNotification(); }
    info(message) {
        return this.notify({ severity: severity_js_1.default.Info, message });
    }
    warn(message) {
        return this.notify({ severity: severity_js_1.default.Warning, message });
    }
    error(error) {
        return this.notify({ severity: severity_js_1.default.Error, message: error });
    }
    notify(notification) {
        switch (notification.severity) {
            case severity_js_1.default.Error:
                console.error(notification.message);
                break;
            case severity_js_1.default.Warning:
                console.warn(notification.message);
                break;
            default:
                console.log(notification.message);
                break;
        }
        return StandaloneNotificationService.NO_OP;
    }
    prompt(severity, message, choices, options) {
        return StandaloneNotificationService.NO_OP;
    }
    status(message, options) {
        return lifecycle_js_1.Disposable.None;
    }
    setFilter(filter) { }
    getFilter(source) {
        return notification_js_1.NotificationsFilter.OFF;
    }
    getFilters() {
        return [];
    }
    removeFilter(sourceId) { }
}
exports.StandaloneNotificationService = StandaloneNotificationService;
let StandaloneCommandService = class StandaloneCommandService {
    constructor(instantiationService) {
        this._onWillExecuteCommand = new event_js_1.Emitter();
        this._onDidExecuteCommand = new event_js_1.Emitter();
        this.onWillExecuteCommand = this._onWillExecuteCommand.event;
        this.onDidExecuteCommand = this._onDidExecuteCommand.event;
        this._instantiationService = instantiationService;
    }
    executeCommand(id, ...args) {
        const command = commands_js_1.CommandsRegistry.getCommand(id);
        if (!command) {
            return Promise.reject(new Error(`command '${id}' not found`));
        }
        try {
            this._onWillExecuteCommand.fire({ commandId: id, args });
            const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);
            this._onDidExecuteCommand.fire({ commandId: id, args });
            return Promise.resolve(result);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
};
exports.StandaloneCommandService = StandaloneCommandService;
exports.StandaloneCommandService = StandaloneCommandService = __decorate([
    __param(0, instantiation_js_1.IInstantiationService)
], StandaloneCommandService);
let StandaloneKeybindingService = class StandaloneKeybindingService extends abstractKeybindingService_js_1.AbstractKeybindingService {
    constructor(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
        super(contextKeyService, commandService, telemetryService, notificationService, logService);
        this._cachedResolver = null;
        this._dynamicKeybindings = [];
        this._domNodeListeners = [];
        const addContainer = (domNode) => {
            const disposables = new lifecycle_js_1.DisposableStore();
            // for standard keybindings
            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, (e) => {
                const keyEvent = new keyboardEvent_js_1.StandardKeyboardEvent(e);
                const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
                if (shouldPreventDefault) {
                    keyEvent.preventDefault();
                    keyEvent.stopPropagation();
                }
            }));
            // for single modifier chord keybindings (e.g. shift shift)
            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_UP, (e) => {
                const keyEvent = new keyboardEvent_js_1.StandardKeyboardEvent(e);
                const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
                if (shouldPreventDefault) {
                    keyEvent.preventDefault();
                }
            }));
            this._domNodeListeners.push(new DomNodeListeners(domNode, disposables));
        };
        const removeContainer = (domNode) => {
            for (let i = 0; i < this._domNodeListeners.length; i++) {
                const domNodeListeners = this._domNodeListeners[i];
                if (domNodeListeners.domNode === domNode) {
                    this._domNodeListeners.splice(i, 1);
                    domNodeListeners.dispose();
                }
            }
        };
        const addCodeEditor = (codeEditor) => {
            if (codeEditor.getOption(63 /* EditorOption.inDiffEditor */)) {
                return;
            }
            addContainer(codeEditor.getContainerDomNode());
        };
        const removeCodeEditor = (codeEditor) => {
            if (codeEditor.getOption(63 /* EditorOption.inDiffEditor */)) {
                return;
            }
            removeContainer(codeEditor.getContainerDomNode());
        };
        this._register(codeEditorService.onCodeEditorAdd(addCodeEditor));
        this._register(codeEditorService.onCodeEditorRemove(removeCodeEditor));
        codeEditorService.listCodeEditors().forEach(addCodeEditor);
        const addDiffEditor = (diffEditor) => {
            addContainer(diffEditor.getContainerDomNode());
        };
        const removeDiffEditor = (diffEditor) => {
            removeContainer(diffEditor.getContainerDomNode());
        };
        this._register(codeEditorService.onDiffEditorAdd(addDiffEditor));
        this._register(codeEditorService.onDiffEditorRemove(removeDiffEditor));
        codeEditorService.listDiffEditors().forEach(addDiffEditor);
    }
    addDynamicKeybinding(command, keybinding, handler, when) {
        return (0, lifecycle_js_1.combinedDisposable)(commands_js_1.CommandsRegistry.registerCommand(command, handler), this.addDynamicKeybindings([{
                keybinding,
                command,
                when
            }]));
    }
    addDynamicKeybindings(rules) {
        const entries = rules.map((rule) => {
            const keybinding = (0, keybindings_js_1.decodeKeybinding)(rule.keybinding, platform_js_1.OS);
            return {
                keybinding,
                command: rule.command ?? null,
                commandArgs: rule.commandArgs,
                when: rule.when,
                weight1: 1000,
                weight2: 0,
                extensionId: null,
                isBuiltinExtension: false
            };
        });
        this._dynamicKeybindings = this._dynamicKeybindings.concat(entries);
        this.updateResolver();
        return (0, lifecycle_js_1.toDisposable)(() => {
            // Search the first entry and remove them all since they will be contiguous
            for (let i = 0; i < this._dynamicKeybindings.length; i++) {
                if (this._dynamicKeybindings[i] === entries[0]) {
                    this._dynamicKeybindings.splice(i, entries.length);
                    this.updateResolver();
                    return;
                }
            }
        });
    }
    updateResolver() {
        this._cachedResolver = null;
        this._onDidUpdateKeybindings.fire();
    }
    _getResolver() {
        if (!this._cachedResolver) {
            const defaults = this._toNormalizedKeybindingItems(keybindingsRegistry_js_1.KeybindingsRegistry.getDefaultKeybindings(), true);
            const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
            this._cachedResolver = new keybindingResolver_js_1.KeybindingResolver(defaults, overrides, (str) => this._log(str));
        }
        return this._cachedResolver;
    }
    _documentHasFocus() {
        return window_js_1.mainWindow.document.hasFocus();
    }
    _toNormalizedKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            const keybinding = item.keybinding;
            if (!keybinding) {
                // This might be a removal keybinding item in user settings => accept it
                result[resultLen++] = new resolvedKeybindingItem_js_1.ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false);
            }
            else {
                const resolvedKeybindings = usLayoutResolvedKeybinding_js_1.USLayoutResolvedKeybinding.resolveKeybinding(keybinding, platform_js_1.OS);
                for (const resolvedKeybinding of resolvedKeybindings) {
                    result[resultLen++] = new resolvedKeybindingItem_js_1.ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);
                }
            }
        }
        return result;
    }
    resolveKeybinding(keybinding) {
        return usLayoutResolvedKeybinding_js_1.USLayoutResolvedKeybinding.resolveKeybinding(keybinding, platform_js_1.OS);
    }
    resolveKeyboardEvent(keyboardEvent) {
        const chord = new keybindings_js_1.KeyCodeChord(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
        return new usLayoutResolvedKeybinding_js_1.USLayoutResolvedKeybinding([chord], platform_js_1.OS);
    }
    resolveUserBinding(userBinding) {
        return [];
    }
    _dumpDebugInfo() {
        return '';
    }
    _dumpDebugInfoJSON() {
        return '';
    }
    registerSchemaContribution(contribution) {
        // noop
    }
    /**
     * not yet supported
     */
    enableKeybindingHoldMode(commandId) {
        return undefined;
    }
};
exports.StandaloneKeybindingService = StandaloneKeybindingService;
exports.StandaloneKeybindingService = StandaloneKeybindingService = __decorate([
    __param(0, contextkey_js_1.IContextKeyService),
    __param(1, commands_js_1.ICommandService),
    __param(2, telemetry_js_1.ITelemetryService),
    __param(3, notification_js_1.INotificationService),
    __param(4, log_js_1.ILogService),
    __param(5, codeEditorService_js_1.ICodeEditorService)
], StandaloneKeybindingService);
class DomNodeListeners extends lifecycle_js_1.Disposable {
    constructor(domNode, disposables) {
        super();
        this.domNode = domNode;
        this._register(disposables);
    }
}
function isConfigurationOverrides(thing) {
    return thing
        && typeof thing === 'object'
        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
        && (!thing.resource || thing.resource instanceof uri_js_1.URI);
}
let StandaloneConfigurationService = class StandaloneConfigurationService {
    constructor(logService) {
        this.logService = logService;
        this._onDidChangeConfiguration = new event_js_1.Emitter();
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        const defaultConfiguration = new configurations_js_1.DefaultConfiguration(logService);
        this._configuration = new configurationModels_js_1.Configuration(defaultConfiguration.reload(), configurationModels_js_1.ConfigurationModel.createEmptyModel(logService), configurationModels_js_1.ConfigurationModel.createEmptyModel(logService), configurationModels_js_1.ConfigurationModel.createEmptyModel(logService), configurationModels_js_1.ConfigurationModel.createEmptyModel(logService), configurationModels_js_1.ConfigurationModel.createEmptyModel(logService), new map_js_1.ResourceMap(), configurationModels_js_1.ConfigurationModel.createEmptyModel(logService), new map_js_1.ResourceMap(), logService);
        defaultConfiguration.dispose();
    }
    getValue(arg1, arg2) {
        const section = typeof arg1 === 'string' ? arg1 : undefined;
        const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};
        return this._configuration.getValue(section, overrides, undefined);
    }
    updateValues(values) {
        const previous = { data: this._configuration.toData() };
        const changedKeys = [];
        for (const entry of values) {
            const [key, value] = entry;
            if (this.getValue(key) === value) {
                continue;
            }
            this._configuration.updateValue(key, value);
            changedKeys.push(key);
        }
        if (changedKeys.length > 0) {
            const configurationChangeEvent = new configurationModels_js_1.ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration, undefined, this.logService);
            configurationChangeEvent.source = 8 /* ConfigurationTarget.MEMORY */;
            this._onDidChangeConfiguration.fire(configurationChangeEvent);
        }
        return Promise.resolve();
    }
    updateValue(key, value, arg3, arg4) {
        return this.updateValues([[key, value]]);
    }
    inspect(key, options = {}) {
        return this._configuration.inspect(key, options, undefined);
    }
    keys() {
        return this._configuration.keys(undefined);
    }
    reloadConfiguration() {
        return Promise.resolve(undefined);
    }
    getConfigurationData() {
        const emptyModel = {
            contents: {},
            keys: [],
            overrides: []
        };
        return {
            defaults: emptyModel,
            policy: emptyModel,
            application: emptyModel,
            user: emptyModel,
            workspace: emptyModel,
            folders: []
        };
    }
};
exports.StandaloneConfigurationService = StandaloneConfigurationService;
exports.StandaloneConfigurationService = StandaloneConfigurationService = __decorate([
    __param(0, log_js_1.ILogService)
], StandaloneConfigurationService);
let StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService {
    constructor(configurationService, modelService, languageService) {
        this.configurationService = configurationService;
        this.modelService = modelService;
        this.languageService = languageService;
        this._onDidChangeConfiguration = new event_js_1.Emitter();
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.configurationService.onDidChangeConfiguration((e) => {
            this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });
        });
    }
    getValue(resource, arg2, arg3) {
        const position = position_js_1.Position.isIPosition(arg2) ? arg2 : null;
        const section = position ? (typeof arg3 === 'string' ? arg3 : undefined) : (typeof arg2 === 'string' ? arg2 : undefined);
        const language = resource ? this.getLanguage(resource, position) : undefined;
        if (typeof section === 'undefined') {
            return this.configurationService.getValue({
                resource,
                overrideIdentifier: language
            });
        }
        return this.configurationService.getValue(section, {
            resource,
            overrideIdentifier: language
        });
    }
    inspect(resource, position, section) {
        const language = resource ? this.getLanguage(resource, position) : undefined;
        return this.configurationService.inspect(section, { resource, overrideIdentifier: language });
    }
    getLanguage(resource, position) {
        const model = this.modelService.getModel(resource);
        if (model) {
            return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();
        }
        return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
    }
    updateValue(resource, key, value, configurationTarget) {
        return this.configurationService.updateValue(key, value, { resource }, configurationTarget);
    }
};
StandaloneResourceConfigurationService = __decorate([
    __param(0, configuration_js_1.IConfigurationService),
    __param(1, model_js_1.IModelService),
    __param(2, language_js_1.ILanguageService)
], StandaloneResourceConfigurationService);
let StandaloneResourcePropertiesService = class StandaloneResourcePropertiesService {
    constructor(configurationService) {
        this.configurationService = configurationService;
    }
    getEOL(resource, language) {
        const eol = this.configurationService.getValue('files.eol', { overrideIdentifier: language, resource });
        if (eol && typeof eol === 'string' && eol !== 'auto') {
            return eol;
        }
        return (platform_js_1.isLinux || platform_js_1.isMacintosh) ? '\n' : '\r\n';
    }
};
StandaloneResourcePropertiesService = __decorate([
    __param(0, configuration_js_1.IConfigurationService)
], StandaloneResourcePropertiesService);
class StandaloneTelemetryService {
    constructor() {
        this.telemetryLevel = 0 /* TelemetryLevel.NONE */;
        this.sessionId = 'someValue.sessionId';
        this.machineId = 'someValue.machineId';
        this.sqmId = 'someValue.sqmId';
        this.devDeviceId = 'someValue.devDeviceId';
        this.firstSessionDate = 'someValue.firstSessionDate';
        this.sendErrorTelemetry = false;
    }
    setEnabled() { }
    setExperimentProperty() { }
    publicLog() { }
    publicLog2() { }
    publicLogError() { }
    publicLogError2() { }
}
class StandaloneWorkspaceContextService {
    static { this.SCHEME = 'inmemory'; }
    constructor() {
        this._onDidChangeWorkspaceName = new event_js_1.Emitter();
        this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
        this._onWillChangeWorkspaceFolders = new event_js_1.Emitter();
        this.onWillChangeWorkspaceFolders = this._onWillChangeWorkspaceFolders.event;
        this._onDidChangeWorkspaceFolders = new event_js_1.Emitter();
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this._onDidChangeWorkbenchState = new event_js_1.Emitter();
        this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
        const resource = uri_js_1.URI.from({ scheme: StandaloneWorkspaceContextService.SCHEME, authority: 'model', path: '/' });
        this.workspace = { id: workspace_js_1.STANDALONE_EDITOR_WORKSPACE_ID, folders: [new workspace_js_1.WorkspaceFolder({ uri: resource, name: '', index: 0 })] };
    }
    getCompleteWorkspace() {
        return Promise.resolve(this.getWorkspace());
    }
    getWorkspace() {
        return this.workspace;
    }
    getWorkbenchState() {
        if (this.workspace) {
            if (this.workspace.configuration) {
                return 3 /* WorkbenchState.WORKSPACE */;
            }
            return 2 /* WorkbenchState.FOLDER */;
        }
        return 1 /* WorkbenchState.EMPTY */;
    }
    getWorkspaceFolder(resource) {
        return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;
    }
    isInsideWorkspace(resource) {
        return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME;
    }
    isCurrentWorkspace(workspaceIdOrFolder) {
        return true;
    }
}
function updateConfigurationService(configurationService, source, isDiffEditor) {
    if (!source) {
        return;
    }
    if (!(configurationService instanceof StandaloneConfigurationService)) {
        return;
    }
    const toUpdate = [];
    Object.keys(source).forEach((key) => {
        if ((0, editorConfigurationSchema_js_1.isEditorConfigurationKey)(key)) {
            toUpdate.push([`editor.${key}`, source[key]]);
        }
        if (isDiffEditor && (0, editorConfigurationSchema_js_1.isDiffEditorConfigurationKey)(key)) {
            toUpdate.push([`diffEditor.${key}`, source[key]]);
        }
    });
    if (toUpdate.length > 0) {
        configurationService.updateValues(toUpdate);
    }
}
let StandaloneBulkEditService = class StandaloneBulkEditService {
    constructor(_modelService) {
        this._modelService = _modelService;
        //
    }
    hasPreviewHandler() {
        return false;
    }
    setPreviewHandler() {
        return lifecycle_js_1.Disposable.None;
    }
    async apply(editsIn, _options) {
        const edits = Array.isArray(editsIn) ? editsIn : bulkEditService_js_1.ResourceEdit.convert(editsIn);
        const textEdits = new Map();
        for (const edit of edits) {
            if (!(edit instanceof bulkEditService_js_1.ResourceTextEdit)) {
                throw new Error('bad edit - only text edits are supported');
            }
            const model = this._modelService.getModel(edit.resource);
            if (!model) {
                throw new Error('bad edit - model not found');
            }
            if (typeof edit.versionId === 'number' && model.getVersionId() !== edit.versionId) {
                throw new Error('bad state - model changed in the meantime');
            }
            let array = textEdits.get(model);
            if (!array) {
                array = [];
                textEdits.set(model, array);
            }
            array.push(editOperation_js_1.EditOperation.replaceMove(range_js_1.Range.lift(edit.textEdit.range), edit.textEdit.text));
        }
        let totalEdits = 0;
        let totalFiles = 0;
        for (const [model, edits] of textEdits) {
            model.pushStackElement();
            model.pushEditOperations([], edits, () => []);
            model.pushStackElement();
            totalFiles += 1;
            totalEdits += edits.length;
        }
        return {
            ariaSummary: strings.format(standaloneStrings_js_1.StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles),
            isApplied: totalEdits > 0
        };
    }
};
StandaloneBulkEditService = __decorate([
    __param(0, model_js_1.IModelService)
], StandaloneBulkEditService);
class StandaloneUriLabelService {
    constructor() {
        this.onDidChangeFormatters = event_js_1.Event.None;
    }
    getUriLabel(resource, options) {
        if (resource.scheme === 'file') {
            return resource.fsPath;
        }
        return resource.path;
    }
    getUriBasenameLabel(resource) {
        return (0, resources_js_1.basename)(resource);
    }
    getWorkspaceLabel(workspace, options) {
        return '';
    }
    getSeparator(scheme, authority) {
        return '/';
    }
    registerFormatter(formatter) {
        throw new Error('Not implemented');
    }
    registerCachedFormatter(formatter) {
        return this.registerFormatter(formatter);
    }
    getHostLabel() {
        return '';
    }
    getHostTooltip() {
        return undefined;
    }
}
let StandaloneContextViewService = class StandaloneContextViewService extends contextViewService_js_1.ContextViewService {
    constructor(layoutService, _codeEditorService) {
        super(layoutService);
        this._codeEditorService = _codeEditorService;
    }
    showContextView(delegate, container, shadowRoot) {
        if (!container) {
            const codeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
            if (codeEditor) {
                container = codeEditor.getContainerDomNode();
            }
        }
        return super.showContextView(delegate, container, shadowRoot);
    }
};
StandaloneContextViewService = __decorate([
    __param(0, layoutService_js_1.ILayoutService),
    __param(1, codeEditorService_js_1.ICodeEditorService)
], StandaloneContextViewService);
class StandaloneWorkspaceTrustManagementService {
    constructor() {
        this._neverEmitter = new event_js_1.Emitter();
        this.onDidChangeTrust = this._neverEmitter.event;
        this.onDidChangeTrustedFolders = this._neverEmitter.event;
        this.workspaceResolved = Promise.resolve();
        this.workspaceTrustInitialized = Promise.resolve();
        this.acceptsOutOfWorkspaceFiles = true;
    }
    isWorkspaceTrusted() {
        return true;
    }
    isWorkspaceTrustForced() {
        return false;
    }
    canSetParentFolderTrust() {
        return false;
    }
    async setParentFolderTrust(trusted) {
        // noop
    }
    canSetWorkspaceTrust() {
        return false;
    }
    async setWorkspaceTrust(trusted) {
        // noop
    }
    getUriTrustInfo(uri) {
        throw new Error('Method not supported.');
    }
    async setUrisTrust(uri, trusted) {
        // noop
    }
    getTrustedUris() {
        return [];
    }
    async setTrustedUris(uris) {
        // noop
    }
    addWorkspaceTrustTransitionParticipant(participant) {
        throw new Error('Method not supported.');
    }
}
class StandaloneLanguageService extends languageService_js_1.LanguageService {
    constructor() {
        super();
    }
}
class StandaloneLogService extends logService_js_1.LogService {
    constructor() {
        super(new log_js_1.ConsoleLogger());
    }
}
let StandaloneContextMenuService = class StandaloneContextMenuService extends contextMenuService_js_1.ContextMenuService {
    constructor(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService) {
        super(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService);
        this.configure({ blockMouse: false }); // we do not want that in the standalone editor
    }
};
StandaloneContextMenuService = __decorate([
    __param(0, telemetry_js_1.ITelemetryService),
    __param(1, notification_js_1.INotificationService),
    __param(2, contextView_js_1.IContextViewService),
    __param(3, keybinding_js_1.IKeybindingService),
    __param(4, actions_js_1.IMenuService),
    __param(5, contextkey_js_1.IContextKeyService)
], StandaloneContextMenuService);
exports.standaloneEditorWorkerDescriptor = {
    moduleId: 'vs/editor/common/services/editorSimpleWorker',
    esmModuleLocation: undefined,
    label: 'editorWorkerService'
};
let StandaloneEditorWorkerService = class StandaloneEditorWorkerService extends editorWorkerService_js_1.EditorWorkerService {
    constructor(modelService, configurationService, logService, languageConfigurationService, languageFeaturesService) {
        super(exports.standaloneEditorWorkerDescriptor, modelService, configurationService, logService, languageConfigurationService, languageFeaturesService);
    }
};
StandaloneEditorWorkerService = __decorate([
    __param(0, model_js_1.IModelService),
    __param(1, textResourceConfiguration_js_1.ITextResourceConfigurationService),
    __param(2, log_js_1.ILogService),
    __param(3, languageConfigurationRegistry_js_1.ILanguageConfigurationService),
    __param(4, languageFeatures_js_1.ILanguageFeaturesService)
], StandaloneEditorWorkerService);
class StandaloneAccessbilitySignalService {
    async playSignal(cue, options) {
    }
    async playSignals(cues) {
    }
    getEnabledState(signal, userGesture, modality) {
        return event_js_1.ValueWithChangeEvent.const(false);
    }
    getDelayMs(signal, modality) {
        return 0;
    }
    isSoundEnabled(cue) {
        return false;
    }
    isAnnouncementEnabled(cue) {
        return false;
    }
    onSoundEnabledChanged(cue) {
        return event_js_1.Event.None;
    }
    async playSound(cue, allowManyInParallel) {
    }
    playSignalLoop(cue) {
        return (0, lifecycle_js_1.toDisposable)(() => { });
    }
}
(0, extensions_js_1.registerSingleton)(log_js_1.ILogService, StandaloneLogService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(configuration_js_1.IConfigurationService, StandaloneConfigurationService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(textResourceConfiguration_js_1.ITextResourceConfigurationService, StandaloneResourceConfigurationService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(textResourceConfiguration_js_1.ITextResourcePropertiesService, StandaloneResourcePropertiesService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(workspace_js_1.IWorkspaceContextService, StandaloneWorkspaceContextService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(label_js_1.ILabelService, StandaloneUriLabelService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(telemetry_js_1.ITelemetryService, StandaloneTelemetryService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(dialogs_js_1.IDialogService, StandaloneDialogService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(environment_js_1.IEnvironmentService, StandaloneEnvironmentService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(notification_js_1.INotificationService, StandaloneNotificationService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(markers_js_1.IMarkerService, markerService_js_1.MarkerService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(language_js_1.ILanguageService, StandaloneLanguageService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(standaloneTheme_js_1.IStandaloneThemeService, standaloneThemeService_js_1.StandaloneThemeService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(model_js_1.IModelService, modelService_js_1.ModelService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(markerDecorations_js_1.IMarkerDecorationsService, markerDecorationsService_js_1.MarkerDecorationsService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(contextkey_js_1.IContextKeyService, contextKeyService_js_1.ContextKeyService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(progress_js_1.IProgressService, StandaloneProgressService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(progress_js_1.IEditorProgressService, StandaloneEditorProgressService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(storage_js_1.IStorageService, storage_js_1.InMemoryStorageService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(editorWorker_js_1.IEditorWorkerService, StandaloneEditorWorkerService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(bulkEditService_js_1.IBulkEditService, StandaloneBulkEditService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(workspaceTrust_js_1.IWorkspaceTrustManagementService, StandaloneWorkspaceTrustManagementService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(resolverService_js_1.ITextModelService, StandaloneTextModelService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(accessibility_js_1.IAccessibilityService, accessibilityService_js_1.AccessibilityService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(listService_js_1.IListService, listService_js_1.ListService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(commands_js_1.ICommandService, StandaloneCommandService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(keybinding_js_1.IKeybindingService, StandaloneKeybindingService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(quickInput_js_1.IQuickInputService, standaloneQuickInputService_js_1.StandaloneQuickInputService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(contextView_js_1.IContextViewService, StandaloneContextViewService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(opener_js_1.IOpenerService, openerService_js_1.OpenerService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(clipboardService_js_2.IClipboardService, clipboardService_js_1.BrowserClipboardService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(contextView_js_1.IContextMenuService, StandaloneContextMenuService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(actions_js_1.IMenuService, menuService_js_1.MenuService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(accessibilitySignalService_js_1.IAccessibilitySignalService, StandaloneAccessbilitySignalService, 0 /* InstantiationType.Eager */);
(0, extensions_js_1.registerSingleton)(treeSitterParserService_js_1.ITreeSitterParserService, standaloneTreeSitterService_js_1.StandaloneTreeSitterParserService, 0 /* InstantiationType.Eager */);
/**
 * We don't want to eagerly instantiate services because embedders get a one time chance
 * to override services when they create the first editor.
 */
var StandaloneServices;
(function (StandaloneServices) {
    const serviceCollection = new serviceCollection_js_1.ServiceCollection();
    for (const [id, descriptor] of (0, extensions_js_1.getSingletonServiceDescriptors)()) {
        serviceCollection.set(id, descriptor);
    }
    const instantiationService = new instantiationService_js_1.InstantiationService(serviceCollection, true);
    serviceCollection.set(instantiation_js_1.IInstantiationService, instantiationService);
    function get(serviceId) {
        if (!initialized) {
            initialize({});
        }
        const r = serviceCollection.get(serviceId);
        if (!r) {
            throw new Error('Missing service ' + serviceId);
        }
        if (r instanceof descriptors_js_1.SyncDescriptor) {
            return instantiationService.invokeFunction((accessor) => accessor.get(serviceId));
        }
        else {
            return r;
        }
    }
    StandaloneServices.get = get;
    let initialized = false;
    const onDidInitialize = new event_js_1.Emitter();
    function initialize(overrides) {
        if (initialized) {
            return instantiationService;
        }
        initialized = true;
        // Add singletons that were registered after this module loaded
        for (const [id, descriptor] of (0, extensions_js_1.getSingletonServiceDescriptors)()) {
            if (!serviceCollection.get(id)) {
                serviceCollection.set(id, descriptor);
            }
        }
        // Initialize the service collection with the overrides, but only if the
        // service was not instantiated in the meantime.
        for (const serviceId in overrides) {
            if (overrides.hasOwnProperty(serviceId)) {
                const serviceIdentifier = (0, instantiation_js_1.createDecorator)(serviceId);
                const r = serviceCollection.get(serviceIdentifier);
                if (r instanceof descriptors_js_1.SyncDescriptor) {
                    serviceCollection.set(serviceIdentifier, overrides[serviceId]);
                }
            }
        }
        // Instantiate all editor features
        const editorFeatures = (0, editorFeatures_js_1.getEditorFeatures)();
        for (const feature of editorFeatures) {
            try {
                instantiationService.createInstance(feature);
            }
            catch (err) {
                (0, errors_js_1.onUnexpectedError)(err);
            }
        }
        onDidInitialize.fire();
        return instantiationService;
    }
    StandaloneServices.initialize = initialize;
    /**
     * Executes callback once services are initialized.
     */
    function withServices(callback) {
        if (initialized) {
            return callback();
        }
        const disposable = new lifecycle_js_1.DisposableStore();
        const listener = disposable.add(onDidInitialize.event(() => {
            listener.dispose();
            disposable.add(callback());
        }));
        return disposable;
    }
    StandaloneServices.withServices = withServices;
})(StandaloneServices || (exports.StandaloneServices = StandaloneServices = {}));
//# sourceMappingURL=standaloneServices.js.map