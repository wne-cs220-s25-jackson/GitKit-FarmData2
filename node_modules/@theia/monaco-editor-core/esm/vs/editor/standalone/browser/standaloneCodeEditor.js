"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandaloneDiffEditor2 = exports.StandaloneEditor = exports.StandaloneCodeEditor = void 0;
exports.createTextModel = createTextModel;
const aria = require("../../../base/browser/ui/aria/aria.js");
const lifecycle_js_1 = require("../../../base/common/lifecycle.js");
const codeEditorService_js_1 = require("../../browser/services/codeEditorService.js");
const codeEditorWidget_js_1 = require("../../browser/widget/codeEditor/codeEditorWidget.js");
const editorAction_js_1 = require("../../common/editorAction.js");
const standaloneServices_js_1 = require("./standaloneServices.js");
const standaloneTheme_js_1 = require("../common/standaloneTheme.js");
const actions_js_1 = require("../../../platform/actions/common/actions.js");
const commands_js_1 = require("../../../platform/commands/common/commands.js");
const configuration_js_1 = require("../../../platform/configuration/common/configuration.js");
const contextkey_js_1 = require("../../../platform/contextkey/common/contextkey.js");
const contextView_js_1 = require("../../../platform/contextview/browser/contextView.js");
const instantiation_js_1 = require("../../../platform/instantiation/common/instantiation.js");
const keybinding_js_1 = require("../../../platform/keybinding/common/keybinding.js");
const notification_js_1 = require("../../../platform/notification/common/notification.js");
const themeService_js_1 = require("../../../platform/theme/common/themeService.js");
const accessibility_js_1 = require("../../../platform/accessibility/common/accessibility.js");
const standaloneStrings_js_1 = require("../../common/standaloneStrings.js");
const clipboardService_js_1 = require("../../../platform/clipboard/common/clipboardService.js");
const progress_js_1 = require("../../../platform/progress/common/progress.js");
const model_js_1 = require("../../common/services/model.js");
const language_js_1 = require("../../common/languages/language.js");
const standaloneCodeEditorService_js_1 = require("./standaloneCodeEditorService.js");
const modesRegistry_js_1 = require("../../common/languages/modesRegistry.js");
const languageConfigurationRegistry_js_1 = require("../../common/languages/languageConfigurationRegistry.js");
const languageFeatures_js_1 = require("../../common/services/languageFeatures.js");
const diffEditorWidget_js_1 = require("../../browser/widget/diffEditor/diffEditorWidget.js");
const accessibilitySignalService_js_1 = require("../../../platform/accessibilitySignal/browser/accessibilitySignalService.js");
const window_js_1 = require("../../../base/browser/window.js");
const hoverDelegateFactory_js_1 = require("../../../base/browser/ui/hover/hoverDelegateFactory.js");
const hover_js_1 = require("../../../platform/hover/browser/hover.js");
const hoverDelegate2_js_1 = require("../../../base/browser/ui/hover/hoverDelegate2.js");
let LAST_GENERATED_COMMAND_ID = 0;
let ariaDomNodeCreated = false;
/**
 * Create ARIA dom node inside parent,
 * or only for the first editor instantiation inside document.body.
 * @param parent container element for ARIA dom node
 */
function createAriaDomNode(parent) {
    if (!parent) {
        if (ariaDomNodeCreated) {
            return;
        }
        ariaDomNodeCreated = true;
    }
    aria.setARIAContainer(parent || window_js_1.mainWindow.document.body);
}
/**
 * A code editor to be used both by the standalone editor and the standalone diff editor.
 */
let StandaloneCodeEditor = class StandaloneCodeEditor extends codeEditorWidget_js_1.CodeEditorWidget {
    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, hoverService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
        const options = { ..._options };
        options.ariaLabel = options.ariaLabel || standaloneStrings_js_1.StandaloneCodeEditorNLS.editorViewAccessibleLabel;
        super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
        if (keybindingService instanceof standaloneServices_js_1.StandaloneKeybindingService) {
            this._standaloneKeybindingService = keybindingService;
        }
        else {
            this._standaloneKeybindingService = null;
        }
        createAriaDomNode(options.ariaContainerElement);
        (0, hoverDelegateFactory_js_1.setHoverDelegateFactory)((placement, enableInstantHover) => instantiationService.createInstance(hover_js_1.WorkbenchHoverDelegate, placement, enableInstantHover, {}));
        (0, hoverDelegate2_js_1.setBaseLayerHoverDelegate)(hoverService);
    }
    addCommand(keybinding, handler, context) {
        if (!this._standaloneKeybindingService) {
            console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');
            return null;
        }
        const commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);
        const whenExpression = contextkey_js_1.ContextKeyExpr.deserialize(context);
        this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);
        return commandId;
    }
    createContextKey(key, defaultValue) {
        return this._contextKeyService.createKey(key, defaultValue);
    }
    addAction(_descriptor) {
        if ((typeof _descriptor.id !== 'string') || (typeof _descriptor.label !== 'string') || (typeof _descriptor.run !== 'function')) {
            throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');
        }
        if (!this._standaloneKeybindingService) {
            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
            return lifecycle_js_1.Disposable.None;
        }
        // Read descriptor options
        const id = _descriptor.id;
        const label = _descriptor.label;
        const precondition = contextkey_js_1.ContextKeyExpr.and(contextkey_js_1.ContextKeyExpr.equals('editorId', this.getId()), contextkey_js_1.ContextKeyExpr.deserialize(_descriptor.precondition));
        const keybindings = _descriptor.keybindings;
        const keybindingsWhen = contextkey_js_1.ContextKeyExpr.and(precondition, contextkey_js_1.ContextKeyExpr.deserialize(_descriptor.keybindingContext));
        const contextMenuGroupId = _descriptor.contextMenuGroupId || null;
        const contextMenuOrder = _descriptor.contextMenuOrder || 0;
        const run = (_accessor, ...args) => {
            return Promise.resolve(_descriptor.run(this, ...args));
        };
        const toDispose = new lifecycle_js_1.DisposableStore();
        // Generate a unique id to allow the same descriptor.id across multiple editor instances
        const uniqueId = this.getId() + ':' + id;
        // Register the command
        toDispose.add(commands_js_1.CommandsRegistry.registerCommand(uniqueId, run));
        // Register the context menu item
        if (contextMenuGroupId) {
            const menuItem = {
                command: {
                    id: uniqueId,
                    title: label
                },
                when: precondition,
                group: contextMenuGroupId,
                order: contextMenuOrder
            };
            toDispose.add(actions_js_1.MenuRegistry.appendMenuItem(actions_js_1.MenuId.EditorContext, menuItem));
        }
        // Register the keybindings
        if (Array.isArray(keybindings)) {
            for (const kb of keybindings) {
                toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));
            }
        }
        // Finally, register an internal editor action
        const internalAction = new editorAction_js_1.InternalEditorAction(uniqueId, label, label, undefined, precondition, (...args) => Promise.resolve(_descriptor.run(this, ...args)), this._contextKeyService);
        // Store it under the original id, such that trigger with the original id will work
        this._actions.set(id, internalAction);
        toDispose.add((0, lifecycle_js_1.toDisposable)(() => {
            this._actions.delete(id);
        }));
        return toDispose;
    }
    _triggerCommand(handlerId, payload) {
        if (this._codeEditorService instanceof standaloneCodeEditorService_js_1.StandaloneCodeEditorService) {
            // Help commands find this editor as the active editor
            try {
                this._codeEditorService.setActiveCodeEditor(this);
                super._triggerCommand(handlerId, payload);
            }
            finally {
                this._codeEditorService.setActiveCodeEditor(null);
            }
        }
        else {
            super._triggerCommand(handlerId, payload);
        }
    }
};
exports.StandaloneCodeEditor = StandaloneCodeEditor;
exports.StandaloneCodeEditor = StandaloneCodeEditor = __decorate([
    __param(2, instantiation_js_1.IInstantiationService),
    __param(3, codeEditorService_js_1.ICodeEditorService),
    __param(4, commands_js_1.ICommandService),
    __param(5, contextkey_js_1.IContextKeyService),
    __param(6, hover_js_1.IHoverService),
    __param(7, keybinding_js_1.IKeybindingService),
    __param(8, themeService_js_1.IThemeService),
    __param(9, notification_js_1.INotificationService),
    __param(10, accessibility_js_1.IAccessibilityService),
    __param(11, languageConfigurationRegistry_js_1.ILanguageConfigurationService),
    __param(12, languageFeatures_js_1.ILanguageFeaturesService)
], StandaloneCodeEditor);
let StandaloneEditor = class StandaloneEditor extends StandaloneCodeEditor {
    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, hoverService, keybindingService, themeService, notificationService, configurationService, accessibilityService, modelService, languageService, languageConfigurationService, languageFeaturesService) {
        const options = { ..._options };
        (0, standaloneServices_js_1.updateConfigurationService)(configurationService, options, false);
        const themeDomRegistration = themeService.registerEditorContainer(domElement);
        if (typeof options.theme === 'string') {
            themeService.setTheme(options.theme);
        }
        if (typeof options.autoDetectHighContrast !== 'undefined') {
            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));
        }
        const _model = options.model;
        delete options.model;
        super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, hoverService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
        this._configurationService = configurationService;
        this._standaloneThemeService = themeService;
        this._register(themeDomRegistration);
        let model;
        if (typeof _model === 'undefined') {
            const languageId = languageService.getLanguageIdByMimeType(options.language) || options.language || modesRegistry_js_1.PLAINTEXT_LANGUAGE_ID;
            model = createTextModel(modelService, languageService, options.value || '', languageId, undefined);
            this._ownsModel = true;
        }
        else {
            model = _model;
            this._ownsModel = false;
        }
        this._attachModel(model);
        if (model) {
            const e = {
                oldModelUrl: null,
                newModelUrl: model.uri
            };
            this._onDidChangeModel.fire(e);
        }
    }
    dispose() {
        super.dispose();
    }
    updateOptions(newOptions) {
        (0, standaloneServices_js_1.updateConfigurationService)(this._configurationService, newOptions, false);
        if (typeof newOptions.theme === 'string') {
            this._standaloneThemeService.setTheme(newOptions.theme);
        }
        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {
            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));
        }
        super.updateOptions(newOptions);
    }
    _postDetachModelCleanup(detachedModel) {
        super._postDetachModelCleanup(detachedModel);
        if (detachedModel && this._ownsModel) {
            detachedModel.dispose();
            this._ownsModel = false;
        }
    }
};
exports.StandaloneEditor = StandaloneEditor;
exports.StandaloneEditor = StandaloneEditor = __decorate([
    __param(2, instantiation_js_1.IInstantiationService),
    __param(3, codeEditorService_js_1.ICodeEditorService),
    __param(4, commands_js_1.ICommandService),
    __param(5, contextkey_js_1.IContextKeyService),
    __param(6, hover_js_1.IHoverService),
    __param(7, keybinding_js_1.IKeybindingService),
    __param(8, standaloneTheme_js_1.IStandaloneThemeService),
    __param(9, notification_js_1.INotificationService),
    __param(10, configuration_js_1.IConfigurationService),
    __param(11, accessibility_js_1.IAccessibilityService),
    __param(12, model_js_1.IModelService),
    __param(13, language_js_1.ILanguageService),
    __param(14, languageConfigurationRegistry_js_1.ILanguageConfigurationService),
    __param(15, languageFeatures_js_1.ILanguageFeaturesService)
], StandaloneEditor);
let StandaloneDiffEditor2 = class StandaloneDiffEditor2 extends diffEditorWidget_js_1.DiffEditorWidget {
    constructor(domElement, _options, instantiationService, contextKeyService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService, accessibilitySignalService) {
        const options = { ..._options };
        (0, standaloneServices_js_1.updateConfigurationService)(configurationService, options, true);
        const themeDomRegistration = themeService.registerEditorContainer(domElement);
        if (typeof options.theme === 'string') {
            themeService.setTheme(options.theme);
        }
        if (typeof options.autoDetectHighContrast !== 'undefined') {
            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));
        }
        super(domElement, options, {}, contextKeyService, instantiationService, codeEditorService, accessibilitySignalService, editorProgressService);
        this._configurationService = configurationService;
        this._standaloneThemeService = themeService;
        this._register(themeDomRegistration);
    }
    dispose() {
        super.dispose();
    }
    updateOptions(newOptions) {
        (0, standaloneServices_js_1.updateConfigurationService)(this._configurationService, newOptions, true);
        if (typeof newOptions.theme === 'string') {
            this._standaloneThemeService.setTheme(newOptions.theme);
        }
        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {
            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));
        }
        super.updateOptions(newOptions);
    }
    _createInnerEditor(instantiationService, container, options) {
        return instantiationService.createInstance(StandaloneCodeEditor, container, options);
    }
    getOriginalEditor() {
        return super.getOriginalEditor();
    }
    getModifiedEditor() {
        return super.getModifiedEditor();
    }
    addCommand(keybinding, handler, context) {
        return this.getModifiedEditor().addCommand(keybinding, handler, context);
    }
    createContextKey(key, defaultValue) {
        return this.getModifiedEditor().createContextKey(key, defaultValue);
    }
    addAction(descriptor) {
        return this.getModifiedEditor().addAction(descriptor);
    }
};
exports.StandaloneDiffEditor2 = StandaloneDiffEditor2;
exports.StandaloneDiffEditor2 = StandaloneDiffEditor2 = __decorate([
    __param(2, instantiation_js_1.IInstantiationService),
    __param(3, contextkey_js_1.IContextKeyService),
    __param(4, codeEditorService_js_1.ICodeEditorService),
    __param(5, standaloneTheme_js_1.IStandaloneThemeService),
    __param(6, notification_js_1.INotificationService),
    __param(7, configuration_js_1.IConfigurationService),
    __param(8, contextView_js_1.IContextMenuService),
    __param(9, progress_js_1.IEditorProgressService),
    __param(10, clipboardService_js_1.IClipboardService),
    __param(11, accessibilitySignalService_js_1.IAccessibilitySignalService)
], StandaloneDiffEditor2);
/**
 * @internal
 */
function createTextModel(modelService, languageService, value, languageId, uri) {
    value = value || '';
    if (!languageId) {
        const firstLF = value.indexOf('\n');
        let firstLine = value;
        if (firstLF !== -1) {
            firstLine = value.substring(0, firstLF);
        }
        return doCreateModel(modelService, value, languageService.createByFilepathOrFirstLine(uri || null, firstLine), uri);
    }
    return doCreateModel(modelService, value, languageService.createById(languageId), uri);
}
/**
 * @internal
 */
function doCreateModel(modelService, value, languageSelection, uri) {
    return modelService.createModel(value, languageSelection, uri);
}
//# sourceMappingURL=standaloneCodeEditor.js.map