"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeSitterTokens = void 0;
const languages_js_1 = require("../languages.js");
const lineTokens_js_1 = require("../tokens/lineTokens.js");
const tokens_js_1 = require("./tokens.js");
const lifecycle_js_1 = require("../../../base/common/lifecycle.js");
class TreeSitterTokens extends tokens_js_1.AbstractTokens {
    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {
        super(languageIdCodec, textModel, languageId);
        this._treeSitterService = _treeSitterService;
        this._tokenizationSupport = null;
        this._tokensChangedListener = this._register(new lifecycle_js_1.MutableDisposable());
        this._initialize();
    }
    _initialize() {
        const newLanguage = this.getLanguageId();
        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {
            this._lastLanguageId = newLanguage;
            this._tokenizationSupport = languages_js_1.TreeSitterTokenizationRegistry.get(newLanguage);
            this._tokensChangedListener.value = this._tokenizationSupport?.onDidChangeTokens((e) => {
                if (e.textModel === this._textModel) {
                    this._onDidChangeTokens.fire(e.changes);
                }
            });
        }
    }
    getLineTokens(lineNumber) {
        const content = this._textModel.getLineContent(lineNumber);
        if (this._tokenizationSupport) {
            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);
            if (rawTokens) {
                return new lineTokens_js_1.LineTokens(rawTokens, content, this._languageIdCodec);
            }
        }
        return lineTokens_js_1.LineTokens.createEmpty(content, this._languageIdCodec);
    }
    resetTokenization(fireTokenChangeEvent = true) {
        if (fireTokenChangeEvent) {
            this._onDidChangeTokens.fire({
                semanticTokensApplied: false,
                ranges: [
                    {
                        fromLineNumber: 1,
                        toLineNumber: this._textModel.getLineCount(),
                    },
                ],
            });
        }
        this._initialize();
    }
    handleDidChangeAttached() {
        // TODO @alexr00 implement for background tokenization
    }
    handleDidChangeContent(e) {
        if (e.isFlush) {
            // Don't fire the event, as the view might not have got the text change event yet
            this.resetTokenization(false);
        }
    }
    forceTokenization(lineNumber) {
        // TODO @alexr00 implement
    }
    hasAccurateTokensForLine(lineNumber) {
        // TODO @alexr00 update for background tokenization
        return true;
    }
    isCheapToTokenize(lineNumber) {
        // TODO @alexr00 update for background tokenization
        return true;
    }
    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value
        return 0 /* StandardTokenType.Other */;
    }
    tokenizeLineWithEdit(lineNumber, edit) {
        // TODO @alexr00 understand what this is for and implement
        return { mainLineTokens: null, additionalLines: null };
    }
    get hasTokens() {
        // TODO @alexr00 once we have a token store, implement properly
        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;
        return hasTree;
    }
}
exports.TreeSitterTokens = TreeSitterTokens;
//# sourceMappingURL=treeSitterTokens.js.map