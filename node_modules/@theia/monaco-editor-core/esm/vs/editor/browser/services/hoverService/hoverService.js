"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverService = void 0;
const extensions_js_1 = require("../../../../platform/instantiation/common/extensions.js");
const themeService_js_1 = require("../../../../platform/theme/common/themeService.js");
const colorRegistry_js_1 = require("../../../../platform/theme/common/colorRegistry.js");
const hover_js_1 = require("../../../../platform/hover/browser/hover.js");
const contextView_js_1 = require("../../../../platform/contextview/browser/contextView.js");
const instantiation_js_1 = require("../../../../platform/instantiation/common/instantiation.js");
const hoverWidget_js_1 = require("./hoverWidget.js");
const lifecycle_js_1 = require("../../../../base/common/lifecycle.js");
const dom_js_1 = require("../../../../base/browser/dom.js");
const keybinding_js_1 = require("../../../../platform/keybinding/common/keybinding.js");
const keyboardEvent_js_1 = require("../../../../base/browser/keyboardEvent.js");
const accessibility_js_1 = require("../../../../platform/accessibility/common/accessibility.js");
const layoutService_js_1 = require("../../../../platform/layout/browser/layoutService.js");
const window_js_1 = require("../../../../base/browser/window.js");
const contextViewService_js_1 = require("../../../../platform/contextview/browser/contextViewService.js");
const updatableHoverWidget_js_1 = require("./updatableHoverWidget.js");
const async_js_1 = require("../../../../base/common/async.js");
const configuration_js_1 = require("../../../../platform/configuration/common/configuration.js");
const types_js_1 = require("../../../../base/common/types.js");
let HoverService = class HoverService extends lifecycle_js_1.Disposable {
    constructor(_instantiationService, _configurationService, contextMenuService, _keybindingService, _layoutService, _accessibilityService) {
        super();
        this._instantiationService = _instantiationService;
        this._configurationService = _configurationService;
        this._keybindingService = _keybindingService;
        this._layoutService = _layoutService;
        this._accessibilityService = _accessibilityService;
        this._currentDelayedHoverWasShown = false;
        this._managedHovers = new Map();
        contextMenuService.onDidShowContextMenu(() => this.hideHover());
        this._contextViewHandler = this._register(new contextViewService_js_1.ContextViewHandler(this._layoutService));
    }
    showHover(options, focus, skipLastFocusedUpdate, dontShow) {
        const hover = this._createHover(options, skipLastFocusedUpdate);
        if (!hover) {
            return undefined;
        }
        this._showHover(hover, options, focus);
        return hover;
    }
    showDelayedHover(options, lifecycleOptions) {
        if (!this._currentDelayedHover || this._currentDelayedHoverWasShown) {
            // Current hover is sticky, reject
            if (this._currentHover && this._currentHoverOptions?.persistence?.sticky) {
                return undefined;
            }
            // Identity is the same, return current hover
            if (getHoverOptionsIdentity(this._currentHoverOptions) === getHoverOptionsIdentity(options)) {
                return this._currentHover;
            }
            // Check group identity, if it's the same skip the delay and show the hover immediately
            if (this._currentHover && !this._currentHover.isDisposed && this._currentDelayedHoverGroupId !== undefined && this._currentDelayedHoverGroupId === lifecycleOptions?.groupId) {
                return this.showHover({
                    ...options,
                    appearance: {
                        ...options.appearance,
                        skipFadeInAnimation: true
                    }
                });
            }
        }
        const hover = this._createHover(options, undefined);
        if (!hover) {
            this._currentDelayedHover = undefined;
            this._currentDelayedHoverWasShown = false;
            this._currentDelayedHoverGroupId = undefined;
            return undefined;
        }
        this._currentDelayedHover = hover;
        this._currentDelayedHoverWasShown = false;
        this._currentDelayedHoverGroupId = lifecycleOptions?.groupId;
        (0, async_js_1.timeout)(this._configurationService.getValue('workbench.hover.delay')).then(() => {
            if (hover && !hover.isDisposed) {
                this._currentDelayedHoverWasShown = true;
                this._currentDelayedHoverWasShown = true;
                this._showHover(hover, options);
            }
        });
        return hover;
    }
    setupDelayedHover(target, options, lifecycleOptions) {
        const resolveHoverOptions = () => ({
            ...typeof options === 'function' ? options() : options,
            target
        });
        return this._setupDelayedHover(target, resolveHoverOptions, lifecycleOptions);
    }
    setupDelayedHoverAtMouse(target, options, lifecycleOptions) {
        const resolveHoverOptions = (e) => ({
            ...typeof options === 'function' ? options() : options,
            target: {
                targetElements: [target],
                x: e !== undefined ? e.x + 10 : undefined,
            }
        });
        return this._setupDelayedHover(target, resolveHoverOptions, lifecycleOptions);
    }
    _setupDelayedHover(target, resolveHoverOptions, lifecycleOptions) {
        const store = new lifecycle_js_1.DisposableStore();
        store.add((0, dom_js_1.addDisposableListener)(target, dom_js_1.EventType.MOUSE_OVER, e => {
            this.showDelayedHover(resolveHoverOptions(e), {
                groupId: lifecycleOptions?.groupId
            });
        }));
        if (lifecycleOptions?.setupKeyboardEvents) {
            store.add((0, dom_js_1.addDisposableListener)(target, dom_js_1.EventType.KEY_DOWN, e => {
                const evt = new keyboardEvent_js_1.StandardKeyboardEvent(e);
                if (evt.equals(10 /* KeyCode.Space */) || evt.equals(3 /* KeyCode.Enter */)) {
                    this.showHover(resolveHoverOptions(), true);
                }
            }));
        }
        return store;
    }
    _createHover(options, skipLastFocusedUpdate) {
        this._currentDelayedHover = undefined;
        if (this._currentHover && this._currentHoverOptions?.persistence?.sticky) {
            return undefined;
        }
        if (getHoverOptionsIdentity(this._currentHoverOptions) === getHoverOptionsIdentity(options)) {
            return undefined;
        }
        this._currentHoverOptions = options;
        this._lastHoverOptions = options;
        const trapFocus = options.trapFocus || this._accessibilityService.isScreenReaderOptimized();
        const activeElement = (0, dom_js_1.getActiveElement)();
        // HACK, remove this check when #189076 is fixed
        if (!skipLastFocusedUpdate) {
            if (trapFocus && activeElement) {
                if (!activeElement.classList.contains('monaco-hover')) {
                    this._lastFocusedElementBeforeOpen = activeElement;
                }
            }
            else {
                this._lastFocusedElementBeforeOpen = undefined;
            }
        }
        // Set `id` to default if it's undefined
        if (options.id === undefined) {
            options.id = (0, dom_js_1.isHTMLElement)(options.content)
                ? undefined
                : typeof options.content === 'string'
                    ? options.content.toString()
                    : options.content.value;
        }
        const hoverDisposables = new lifecycle_js_1.DisposableStore();
        const hover = this._instantiationService.createInstance(hoverWidget_js_1.HoverWidget, options);
        if (options.persistence?.sticky) {
            hover.isLocked = true;
        }
        // Adjust target position when a mouse event is provided as the hover position
        if (options.position?.hoverPosition && !(0, types_js_1.isNumber)(options.position.hoverPosition)) {
            options.target = {
                targetElements: (0, dom_js_1.isHTMLElement)(options.target) ? [options.target] : options.target.targetElements,
                x: options.position.hoverPosition.x + 10
            };
        }
        hover.onDispose(() => {
            const hoverWasFocused = this._currentHover?.domNode && (0, dom_js_1.isAncestorOfActiveElement)(this._currentHover.domNode);
            if (hoverWasFocused) {
                // Required to handle cases such as closing the hover with the escape key
                this._lastFocusedElementBeforeOpen?.focus();
            }
            // Only clear the current options if it's the current hover, the current options help
            // reduce flickering when the same hover is shown multiple times
            if (getHoverOptionsIdentity(this._currentHoverOptions) === getHoverOptionsIdentity(options)) {
                this._currentHoverOptions = undefined;
            }
            hoverDisposables.dispose();
        }, undefined, hoverDisposables);
        // Set the container explicitly to enable aux window support
        if (!options.container) {
            const targetElement = (0, dom_js_1.isHTMLElement)(options.target) ? options.target : options.target.targetElements[0];
            options.container = this._layoutService.getContainer((0, dom_js_1.getWindow)(targetElement));
        }
        hover.onRequestLayout(() => this._contextViewHandler.layout(), undefined, hoverDisposables);
        if (options.persistence?.sticky) {
            hoverDisposables.add((0, dom_js_1.addDisposableListener)((0, dom_js_1.getWindow)(options.container).document, dom_js_1.EventType.MOUSE_DOWN, e => {
                if (!(0, dom_js_1.isAncestor)(e.target, hover.domNode)) {
                    this.doHideHover();
                }
            }));
        }
        else {
            if ('targetElements' in options.target) {
                for (const element of options.target.targetElements) {
                    hoverDisposables.add((0, dom_js_1.addDisposableListener)(element, dom_js_1.EventType.CLICK, () => this.hideHover()));
                }
            }
            else {
                hoverDisposables.add((0, dom_js_1.addDisposableListener)(options.target, dom_js_1.EventType.CLICK, () => this.hideHover()));
            }
            const focusedElement = (0, dom_js_1.getActiveElement)();
            if (focusedElement) {
                const focusedElementDocument = (0, dom_js_1.getWindow)(focusedElement).document;
                hoverDisposables.add((0, dom_js_1.addDisposableListener)(focusedElement, dom_js_1.EventType.KEY_DOWN, e => this._keyDown(e, hover, !!options.persistence?.hideOnKeyDown)));
                hoverDisposables.add((0, dom_js_1.addDisposableListener)(focusedElementDocument, dom_js_1.EventType.KEY_DOWN, e => this._keyDown(e, hover, !!options.persistence?.hideOnKeyDown)));
                hoverDisposables.add((0, dom_js_1.addDisposableListener)(focusedElement, dom_js_1.EventType.KEY_UP, e => this._keyUp(e, hover)));
                hoverDisposables.add((0, dom_js_1.addDisposableListener)(focusedElementDocument, dom_js_1.EventType.KEY_UP, e => this._keyUp(e, hover)));
            }
        }
        if ('IntersectionObserver' in window_js_1.mainWindow) {
            const observer = new IntersectionObserver(e => this._intersectionChange(e, hover), { threshold: 0 });
            const firstTargetElement = 'targetElements' in options.target ? options.target.targetElements[0] : options.target;
            observer.observe(firstTargetElement);
            hoverDisposables.add((0, lifecycle_js_1.toDisposable)(() => observer.disconnect()));
        }
        this._currentHover = hover;
        return hover;
    }
    _showHover(hover, options, focus) {
        this._contextViewHandler.showContextView(new HoverContextViewDelegate(hover, focus), options.container);
    }
    hideHover() {
        if (this._currentHover?.isLocked || !this._currentHoverOptions) {
            return;
        }
        this.doHideHover();
    }
    doHideHover() {
        this._currentHover = undefined;
        this._currentHoverOptions = undefined;
        this._contextViewHandler.hideContextView();
    }
    _intersectionChange(entries, hover) {
        const entry = entries[entries.length - 1];
        if (!entry.isIntersecting) {
            hover.dispose();
        }
    }
    showAndFocusLastHover() {
        if (!this._lastHoverOptions) {
            return;
        }
        this.showHover(this._lastHoverOptions, true, true);
    }
    _keyDown(e, hover, hideOnKeyDown) {
        if (e.key === 'Alt') {
            hover.isLocked = true;
            return;
        }
        const event = new keyboardEvent_js_1.StandardKeyboardEvent(e);
        const keybinding = this._keybindingService.resolveKeyboardEvent(event);
        if (keybinding.getSingleModifierDispatchChords().some(value => !!value) || this._keybindingService.softDispatch(event, event.target).kind !== 0 /* ResultKind.NoMatchingKb */) {
            return;
        }
        if (hideOnKeyDown && (!this._currentHoverOptions?.trapFocus || e.key !== 'Tab')) {
            this.hideHover();
            this._lastFocusedElementBeforeOpen?.focus();
        }
    }
    _keyUp(e, hover) {
        if (e.key === 'Alt') {
            hover.isLocked = false;
            // Hide if alt is released while the mouse is not over hover/target
            if (!hover.isMouseIn) {
                this.hideHover();
                this._lastFocusedElementBeforeOpen?.focus();
            }
        }
    }
    // TODO: Investigate performance of this function. There seems to be a lot of content created
    //       and thrown away on start up
    setupManagedHover(hoverDelegate, targetElement, content, options) {
        targetElement.setAttribute('custom-hover', 'true');
        if (targetElement.title !== '') {
            console.warn('HTML element already has a title attribute, which will conflict with the custom hover. Please remove the title attribute.');
            console.trace('Stack trace:', targetElement.title);
            targetElement.title = '';
        }
        let hoverPreparation;
        let hoverWidget;
        const hideHover = (disposeWidget, disposePreparation) => {
            const hadHover = hoverWidget !== undefined;
            if (disposeWidget) {
                hoverWidget?.dispose();
                hoverWidget = undefined;
            }
            if (disposePreparation) {
                hoverPreparation?.dispose();
                hoverPreparation = undefined;
            }
            if (hadHover) {
                hoverDelegate.onDidHideHover?.();
                hoverWidget = undefined;
            }
        };
        const triggerShowHover = (delay, focus, target, trapFocus) => {
            return new async_js_1.TimeoutTimer(async () => {
                if (!hoverWidget || hoverWidget.isDisposed) {
                    hoverWidget = new updatableHoverWidget_js_1.ManagedHoverWidget(hoverDelegate, target || targetElement, delay > 0);
                    await hoverWidget.update(typeof content === 'function' ? content() : content, focus, { ...options, trapFocus });
                }
            }, delay);
        };
        const store = new lifecycle_js_1.DisposableStore();
        let isMouseDown = false;
        store.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.MOUSE_DOWN, () => {
            isMouseDown = true;
            hideHover(true, true);
        }, true));
        store.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.MOUSE_UP, () => {
            isMouseDown = false;
        }, true));
        store.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.MOUSE_LEAVE, (e) => {
            isMouseDown = false;
            hideHover(false, e.fromElement === targetElement);
        }, true));
        store.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.MOUSE_OVER, (e) => {
            if (hoverPreparation) {
                return;
            }
            const mouseOverStore = new lifecycle_js_1.DisposableStore();
            const target = {
                targetElements: [targetElement],
                dispose: () => { }
            };
            if (hoverDelegate.placement === undefined || hoverDelegate.placement === 'mouse') {
                // track the mouse position
                const onMouseMove = (e) => {
                    target.x = e.x + 10;
                    if (((0, dom_js_1.isHTMLElement)(e.target)) && getHoverTargetElement(e.target, targetElement) !== targetElement) {
                        hideHover(true, true);
                    }
                };
                mouseOverStore.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.MOUSE_MOVE, onMouseMove, true));
            }
            hoverPreparation = mouseOverStore;
            if (((0, dom_js_1.isHTMLElement)(e.target)) && getHoverTargetElement(e.target, targetElement) !== targetElement) {
                return; // Do not show hover when the mouse is over another hover target
            }
            mouseOverStore.add(triggerShowHover(hoverDelegate.delay, false, target));
        }, true));
        const onFocus = () => {
            if (isMouseDown || hoverPreparation) {
                return;
            }
            const target = {
                targetElements: [targetElement],
                dispose: () => { }
            };
            const toDispose = new lifecycle_js_1.DisposableStore();
            const onBlur = () => hideHover(true, true);
            toDispose.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.BLUR, onBlur, true));
            toDispose.add(triggerShowHover(hoverDelegate.delay, false, target));
            hoverPreparation = toDispose;
        };
        // Do not show hover when focusing an input or textarea
        if (!(0, dom_js_1.isEditableElement)(targetElement)) {
            store.add((0, dom_js_1.addDisposableListener)(targetElement, dom_js_1.EventType.FOCUS, onFocus, true));
        }
        const hover = {
            show: focus => {
                hideHover(false, true); // terminate a ongoing mouse over preparation
                triggerShowHover(0, focus, undefined, focus); // show hover immediately
            },
            hide: () => {
                hideHover(true, true);
            },
            update: async (newContent, hoverOptions) => {
                content = newContent;
                await hoverWidget?.update(content, undefined, hoverOptions);
            },
            dispose: () => {
                this._managedHovers.delete(targetElement);
                store.dispose();
                hideHover(true, true);
            }
        };
        this._managedHovers.set(targetElement, hover);
        return hover;
    }
    showManagedHover(target) {
        const hover = this._managedHovers.get(target);
        if (hover) {
            hover.show(true);
        }
    }
    dispose() {
        this._managedHovers.forEach(hover => hover.dispose());
        super.dispose();
    }
};
exports.HoverService = HoverService;
exports.HoverService = HoverService = __decorate([
    __param(0, instantiation_js_1.IInstantiationService),
    __param(1, configuration_js_1.IConfigurationService),
    __param(2, contextView_js_1.IContextMenuService),
    __param(3, keybinding_js_1.IKeybindingService),
    __param(4, layoutService_js_1.ILayoutService),
    __param(5, accessibility_js_1.IAccessibilityService)
], HoverService);
function getHoverOptionsIdentity(options) {
    if (options === undefined) {
        return undefined;
    }
    return options?.id ?? options;
}
class HoverContextViewDelegate {
    get anchorPosition() {
        return this._hover.anchor;
    }
    constructor(_hover, _focus = false) {
        this._hover = _hover;
        this._focus = _focus;
        // Render over all other context views
        this.layer = 1;
    }
    render(container) {
        this._hover.render(container);
        if (this._focus) {
            this._hover.focus();
        }
        return this._hover;
    }
    getAnchor() {
        return {
            x: this._hover.x,
            y: this._hover.y
        };
    }
    layout() {
        this._hover.layout();
    }
}
function getHoverTargetElement(element, stopElement) {
    stopElement = stopElement ?? (0, dom_js_1.getWindow)(element).document.body;
    while (!element.hasAttribute('custom-hover') && element !== stopElement) {
        element = element.parentElement;
    }
    return element;
}
(0, extensions_js_1.registerSingleton)(hover_js_1.IHoverService, HoverService, 1 /* InstantiationType.Delayed */);
(0, themeService_js_1.registerThemingParticipant)((theme, collector) => {
    const hoverBorder = theme.getColor(colorRegistry_js_1.editorHoverBorder);
    if (hoverBorder) {
        collector.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
        collector.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    }
});
//# sourceMappingURL=hoverService.js.map