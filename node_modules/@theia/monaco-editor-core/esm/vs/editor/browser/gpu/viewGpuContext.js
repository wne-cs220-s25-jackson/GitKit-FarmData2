"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ViewGpuContext_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewGpuContext = void 0;
const nls = require("../../../nls.js");
const dom_js_1 = require("../../../base/browser/dom.js");
const fastDomNode_js_1 = require("../../../base/browser/fastDomNode.js");
const errors_js_1 = require("../../../base/common/errors.js");
const lifecycle_js_1 = require("../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../base/common/observable.js");
const instantiation_js_1 = require("../../../platform/instantiation/common/instantiation.js");
const textureAtlas_js_1 = require("./atlas/textureAtlas.js");
const configuration_js_1 = require("../../../platform/configuration/common/configuration.js");
const notification_js_1 = require("../../../platform/notification/common/notification.js");
const gpuDisposable_js_1 = require("./gpuDisposable.js");
const gpuUtils_js_1 = require("./gpuUtils.js");
const rectangleRenderer_js_1 = require("./rectangleRenderer.js");
const decorationCssRuleExtractor_js_1 = require("./decorationCssRuleExtractor.js");
const event_js_1 = require("../../../base/common/event.js");
let ViewGpuContext = class ViewGpuContext extends lifecycle_js_1.Disposable {
    static { ViewGpuContext_1 = this; }
    static { this._decorationCssRuleExtractor = new decorationCssRuleExtractor_js_1.DecorationCssRuleExtractor(); }
    static get decorationCssRuleExtractor() {
        return ViewGpuContext_1._decorationCssRuleExtractor;
    }
    /**
     * The shared texture atlas to use across all views.
     *
     * @throws if called before the GPU device is resolved
     */
    static get atlas() {
        if (!ViewGpuContext_1._atlas) {
            throw new errors_js_1.BugIndicatingError('Cannot call ViewGpuContext.textureAtlas before device is resolved');
        }
        return ViewGpuContext_1._atlas;
    }
    /**
     * The shared texture atlas to use across all views. This is a convenience alias for
     * {@link ViewGpuContext.atlas}.
     *
     * @throws if called before the GPU device is resolved
     */
    get atlas() {
        return ViewGpuContext_1.atlas;
    }
    constructor(context, _instantiationService, _notificationService, configurationService) {
        super();
        this._instantiationService = _instantiationService;
        this._notificationService = _notificationService;
        this.configurationService = configurationService;
        /**
         * The temporary hard cap for lines rendered by the GPU renderer. This can be removed once more
         * dynamic allocation is implemented in https://github.com/microsoft/vscode/issues/227091
         */
        this.maxGpuLines = 3000 /* GpuRenderLimits.maxGpuLines */;
        /**
         * The temporary hard cap for line columns rendered by the GPU renderer. This can be removed
         * once more dynamic allocation is implemented in https://github.com/microsoft/vscode/issues/227108
         */
        this.maxGpuCols = 200 /* GpuRenderLimits.maxGpuCols */;
        this.canvas = (0, fastDomNode_js_1.createFastDomNode)(document.createElement('canvas'));
        this.canvas.setClassName('editorCanvas');
        // Adjust the canvas size to avoid drawing under the scroll bar
        this._register(event_js_1.Event.runAndSubscribe(configurationService.onDidChangeConfiguration, e => {
            if (!e || e.affectsConfiguration('editor.scrollbar.verticalScrollbarSize')) {
                const verticalScrollbarSize = configurationService.getValue('editor').scrollbar?.verticalScrollbarSize ?? 14;
                this.canvas.domNode.style.boxSizing = 'border-box';
                this.canvas.domNode.style.paddingRight = `${verticalScrollbarSize}px`;
            }
        }));
        this.ctx = (0, gpuUtils_js_1.ensureNonNullable)(this.canvas.domNode.getContext('webgpu'));
        this.device = gpuDisposable_js_1.GPULifecycle.requestDevice((message) => {
            const choices = [{
                    label: nls.localize('editor.dom.render', "Use DOM-based rendering"),
                    run: () => this.configurationService.updateValue('editor.experimentalGpuAcceleration', 'off'),
                }];
            this._notificationService.prompt(notification_js_1.Severity.Warning, message, choices);
        }).then(ref => this._register(ref).object);
        this.device.then(device => {
            if (!ViewGpuContext_1._atlas) {
                ViewGpuContext_1._atlas = this._instantiationService.createInstance(textureAtlas_js_1.TextureAtlas, device.limits.maxTextureDimension2D, undefined);
            }
        });
        this.rectangleRenderer = this._instantiationService.createInstance(rectangleRenderer_js_1.RectangleRenderer, context, this.canvas.domNode, this.ctx, this.device);
        const dprObs = (0, observable_js_1.observableValue)(this, (0, dom_js_1.getActiveWindow)().devicePixelRatio);
        this._register((0, dom_js_1.addDisposableListener)((0, dom_js_1.getActiveWindow)(), 'resize', () => {
            dprObs.set((0, dom_js_1.getActiveWindow)().devicePixelRatio, undefined);
        }));
        this.devicePixelRatio = dprObs;
        this._register((0, observable_js_1.runOnChange)(this.devicePixelRatio, () => ViewGpuContext_1.atlas?.clear()));
        const canvasDevicePixelDimensions = (0, observable_js_1.observableValue)(this, { width: this.canvas.domNode.width, height: this.canvas.domNode.height });
        this._register((0, gpuUtils_js_1.observeDevicePixelDimensions)(this.canvas.domNode, (0, dom_js_1.getActiveWindow)(), (width, height) => {
            this.canvas.domNode.width = width;
            this.canvas.domNode.height = height;
            canvasDevicePixelDimensions.set({ width, height }, undefined);
        }));
        this.canvasDevicePixelDimensions = canvasDevicePixelDimensions;
    }
    /**
     * This method determines which lines can be and are allowed to be rendered using the GPU
     * renderer. Eventually this should trend all lines, except maybe exceptional cases like
     * decorations that use class names.
     */
    canRender(options, viewportData, lineNumber) {
        const data = viewportData.getViewLineRenderingData(lineNumber);
        // Check if the line has simple attributes that aren't supported
        if (data.containsRTL ||
            data.maxColumn > 200 /* GpuRenderLimits.maxGpuCols */ ||
            data.continuesWithWrappedLine ||
            lineNumber >= 3000 /* GpuRenderLimits.maxGpuLines */) {
            return false;
        }
        // Check if all inline decorations are supported
        if (data.inlineDecorations.length > 0) {
            let supported = true;
            for (const decoration of data.inlineDecorations) {
                if (decoration.type !== 0 /* InlineDecorationType.Regular */) {
                    supported = false;
                    break;
                }
                const styleRules = ViewGpuContext_1._decorationCssRuleExtractor.getStyleRules(this.canvas.domNode, decoration.inlineClassName);
                supported &&= styleRules.every(rule => {
                    // Pseudo classes aren't supported currently
                    if (rule.selectorText.includes(':')) {
                        return false;
                    }
                    for (const r of rule.style) {
                        if (!gpuSupportedDecorationCssRules.includes(r)) {
                            return false;
                        }
                    }
                    return true;
                });
                if (!supported) {
                    break;
                }
            }
            return supported;
        }
        return true;
    }
    /**
     * Like {@link canRender} but returns detailed information about why the line cannot be rendered.
     */
    canRenderDetailed(options, viewportData, lineNumber) {
        const data = viewportData.getViewLineRenderingData(lineNumber);
        const reasons = [];
        if (data.containsRTL) {
            reasons.push('containsRTL');
        }
        if (data.maxColumn > 200 /* GpuRenderLimits.maxGpuCols */) {
            reasons.push('maxColumn > maxGpuCols');
        }
        if (data.continuesWithWrappedLine) {
            reasons.push('continuesWithWrappedLine');
        }
        if (data.inlineDecorations.length > 0) {
            let supported = true;
            const problemTypes = [];
            const problemSelectors = [];
            const problemRules = [];
            for (const decoration of data.inlineDecorations) {
                if (decoration.type !== 0 /* InlineDecorationType.Regular */) {
                    problemTypes.push(decoration.type);
                    supported = false;
                    continue;
                }
                const styleRules = ViewGpuContext_1._decorationCssRuleExtractor.getStyleRules(this.canvas.domNode, decoration.inlineClassName);
                supported &&= styleRules.every(rule => {
                    // Pseudo classes aren't supported currently
                    if (rule.selectorText.includes(':')) {
                        problemSelectors.push(rule.selectorText);
                        return false;
                    }
                    for (const r of rule.style) {
                        if (!gpuSupportedDecorationCssRules.includes(r)) {
                            problemRules.push(r);
                            return false;
                        }
                    }
                    return true;
                });
                if (!supported) {
                    continue;
                }
            }
            if (problemTypes.length > 0) {
                reasons.push(`inlineDecorations with unsupported types (${problemTypes.map(e => `\`${e}\``).join(', ')})`);
            }
            if (problemRules.length > 0) {
                reasons.push(`inlineDecorations with unsupported CSS rules (${problemRules.map(e => `\`${e}\``).join(', ')})`);
            }
            if (problemSelectors.length > 0) {
                reasons.push(`inlineDecorations with unsupported CSS selectors (${problemSelectors.map(e => `\`${e}\``).join(', ')})`);
            }
        }
        if (lineNumber >= 3000 /* GpuRenderLimits.maxGpuLines */) {
            reasons.push('lineNumber >= maxGpuLines');
        }
        return reasons;
    }
};
exports.ViewGpuContext = ViewGpuContext;
exports.ViewGpuContext = ViewGpuContext = ViewGpuContext_1 = __decorate([
    __param(1, instantiation_js_1.IInstantiationService),
    __param(2, notification_js_1.INotificationService),
    __param(3, configuration_js_1.IConfigurationService)
], ViewGpuContext);
/**
 * A list of fully supported decoration CSS rules that can be used in the GPU renderer.
 */
const gpuSupportedDecorationCssRules = [
    'color',
];
//# sourceMappingURL=viewGpuContext.js.map