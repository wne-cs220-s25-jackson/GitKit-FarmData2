"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.RevertButton = exports.RevertButtonsFeature = void 0;
const dom_js_1 = require("../../../../../base/browser/dom.js");
const iconLabels_js_1 = require("../../../../../base/browser/ui/iconLabel/iconLabels.js");
const codicons_js_1 = require("../../../../../base/common/codicons.js");
const lifecycle_js_1 = require("../../../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../../../base/common/observable.js");
const lineRange_js_1 = require("../../../../common/core/lineRange.js");
const range_js_1 = require("../../../../common/core/range.js");
const rangeMapping_js_1 = require("../../../../common/diff/rangeMapping.js");
const model_js_1 = require("../../../../common/model.js");
const nls_js_1 = require("../../../../../nls.js");
const emptyArr = [];
class RevertButtonsFeature extends lifecycle_js_1.Disposable {
    constructor(_editors, _diffModel, _options, _widget) {
        super();
        this._editors = _editors;
        this._diffModel = _diffModel;
        this._options = _options;
        this._widget = _widget;
        this._selectedDiffs = (0, observable_js_1.derived)(this, (reader) => {
            /** @description selectedDiffs */
            const model = this._diffModel.read(reader);
            const diff = model?.diff.read(reader);
            // Return `emptyArr` because it is a constant. [] is always a new array and would trigger a change.
            if (!diff) {
                return emptyArr;
            }
            const selections = this._editors.modifiedSelections.read(reader);
            if (selections.every(s => s.isEmpty())) {
                return emptyArr;
            }
            const selectedLineNumbers = new lineRange_js_1.LineRangeSet(selections.map(s => lineRange_js_1.LineRange.fromRangeInclusive(s)));
            const selectedMappings = diff.mappings.filter(m => m.lineRangeMapping.innerChanges && selectedLineNumbers.intersects(m.lineRangeMapping.modified));
            const result = selectedMappings.map(mapping => ({
                mapping,
                rangeMappings: mapping.lineRangeMapping.innerChanges.filter(c => selections.some(s => range_js_1.Range.areIntersecting(c.modifiedRange, s)))
            }));
            if (result.length === 0 || result.every(r => r.rangeMappings.length === 0)) {
                return emptyArr;
            }
            return result;
        });
        this._register((0, observable_js_1.autorunWithStore)((reader, store) => {
            if (!this._options.shouldRenderOldRevertArrows.read(reader)) {
                return;
            }
            const model = this._diffModel.read(reader);
            const diff = model?.diff.read(reader);
            if (!model || !diff) {
                return;
            }
            if (model.movedTextToCompare.read(reader)) {
                return;
            }
            const glyphWidgetsModified = [];
            const selectedDiffs = this._selectedDiffs.read(reader);
            const selectedDiffsSet = new Set(selectedDiffs.map(d => d.mapping));
            if (selectedDiffs.length > 0) {
                // The button to revert the selection
                const selections = this._editors.modifiedSelections.read(reader);
                const btn = store.add(new RevertButton(selections[selections.length - 1].positionLineNumber, this._widget, selectedDiffs.flatMap(d => d.rangeMappings), true));
                this._editors.modified.addGlyphMarginWidget(btn);
                glyphWidgetsModified.push(btn);
            }
            for (const m of diff.mappings) {
                if (selectedDiffsSet.has(m)) {
                    continue;
                }
                if (!m.lineRangeMapping.modified.isEmpty && m.lineRangeMapping.innerChanges) {
                    const btn = store.add(new RevertButton(m.lineRangeMapping.modified.startLineNumber, this._widget, m.lineRangeMapping, false));
                    this._editors.modified.addGlyphMarginWidget(btn);
                    glyphWidgetsModified.push(btn);
                }
            }
            store.add((0, lifecycle_js_1.toDisposable)(() => {
                for (const w of glyphWidgetsModified) {
                    this._editors.modified.removeGlyphMarginWidget(w);
                }
            }));
        }));
    }
}
exports.RevertButtonsFeature = RevertButtonsFeature;
class RevertButton extends lifecycle_js_1.Disposable {
    static { this.counter = 0; }
    getId() { return this._id; }
    constructor(_lineNumber, _widget, _diffs, _revertSelection) {
        super();
        this._lineNumber = _lineNumber;
        this._widget = _widget;
        this._diffs = _diffs;
        this._revertSelection = _revertSelection;
        this._id = `revertButton${RevertButton.counter++}`;
        this._domNode = (0, dom_js_1.h)('div.revertButton', {
            title: this._revertSelection
                ? (0, nls_js_1.localize)('revertSelectedChanges', 'Revert Selected Changes')
                : (0, nls_js_1.localize)('revertChange', 'Revert Change')
        }, [(0, iconLabels_js_1.renderIcon)(codicons_js_1.Codicon.arrowRight)]).root;
        this._register((0, dom_js_1.addDisposableListener)(this._domNode, dom_js_1.EventType.MOUSE_DOWN, e => {
            // don't prevent context menu from showing up
            if (e.button !== 2) {
                e.stopPropagation();
                e.preventDefault();
            }
        }));
        this._register((0, dom_js_1.addDisposableListener)(this._domNode, dom_js_1.EventType.MOUSE_UP, e => {
            e.stopPropagation();
            e.preventDefault();
        }));
        this._register((0, dom_js_1.addDisposableListener)(this._domNode, dom_js_1.EventType.CLICK, (e) => {
            if (this._diffs instanceof rangeMapping_js_1.LineRangeMapping) {
                this._widget.revert(this._diffs);
            }
            else {
                this._widget.revertRangeMappings(this._diffs);
            }
            e.stopPropagation();
            e.preventDefault();
        }));
    }
    /**
     * Get the dom node of the glyph widget.
     */
    getDomNode() {
        return this._domNode;
    }
    /**
     * Get the placement of the glyph widget.
     */
    getPosition() {
        return {
            lane: model_js_1.GlyphMarginLane.Right,
            range: {
                startColumn: 1,
                startLineNumber: this._lineNumber,
                endColumn: 1,
                endLineNumber: this._lineNumber,
            },
            zIndex: 10001,
        };
    }
}
exports.RevertButton = RevertButton;
//# sourceMappingURL=revertButtonsFeature.js.map