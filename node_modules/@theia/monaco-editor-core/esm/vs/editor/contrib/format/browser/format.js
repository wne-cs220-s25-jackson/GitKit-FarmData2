"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormattingConflicts = void 0;
exports.getRealAndSyntheticDocumentFormattersOrdered = getRealAndSyntheticDocumentFormattersOrdered;
exports.formatDocumentRangesWithSelectedProvider = formatDocumentRangesWithSelectedProvider;
exports.formatDocumentRangesWithProvider = formatDocumentRangesWithProvider;
exports.formatDocumentWithSelectedProvider = formatDocumentWithSelectedProvider;
exports.formatDocumentWithProvider = formatDocumentWithProvider;
exports.getDocumentRangeFormattingEditsUntilResult = getDocumentRangeFormattingEditsUntilResult;
exports.getDocumentFormattingEditsUntilResult = getDocumentFormattingEditsUntilResult;
exports.getDocumentFormattingEditsWithSelectedProvider = getDocumentFormattingEditsWithSelectedProvider;
exports.getOnTypeFormattingEdits = getOnTypeFormattingEdits;
const arrays_js_1 = require("../../../../base/common/arrays.js");
const cancellation_js_1 = require("../../../../base/common/cancellation.js");
const errors_js_1 = require("../../../../base/common/errors.js");
const iterator_js_1 = require("../../../../base/common/iterator.js");
const linkedList_js_1 = require("../../../../base/common/linkedList.js");
const types_js_1 = require("../../../../base/common/types.js");
const uri_js_1 = require("../../../../base/common/uri.js");
const editorState_js_1 = require("../../editorState/browser/editorState.js");
const editorBrowser_js_1 = require("../../../browser/editorBrowser.js");
const position_js_1 = require("../../../common/core/position.js");
const range_js_1 = require("../../../common/core/range.js");
const selection_js_1 = require("../../../common/core/selection.js");
const editorWorker_js_1 = require("../../../common/services/editorWorker.js");
const resolverService_js_1 = require("../../../common/services/resolverService.js");
const formattingEdit_js_1 = require("./formattingEdit.js");
const commands_js_1 = require("../../../../platform/commands/common/commands.js");
const extensions_js_1 = require("../../../../platform/extensions/common/extensions.js");
const instantiation_js_1 = require("../../../../platform/instantiation/common/instantiation.js");
const languageFeatures_js_1 = require("../../../common/services/languageFeatures.js");
const log_js_1 = require("../../../../platform/log/common/log.js");
const accessibilitySignalService_js_1 = require("../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js");
function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {
    const result = [];
    const seen = new extensions_js_1.ExtensionIdentifierSet();
    // (1) add all document formatter
    const docFormatter = documentFormattingEditProvider.ordered(model);
    for (const formatter of docFormatter) {
        result.push(formatter);
        if (formatter.extensionId) {
            seen.add(formatter.extensionId);
        }
    }
    // (2) add all range formatter as document formatter (unless the same extension already did that)
    const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);
    for (const formatter of rangeFormatter) {
        if (formatter.extensionId) {
            if (seen.has(formatter.extensionId)) {
                continue;
            }
            seen.add(formatter.extensionId);
        }
        result.push({
            displayName: formatter.displayName,
            extensionId: formatter.extensionId,
            provideDocumentFormattingEdits(model, options, token) {
                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);
            }
        });
    }
    return result;
}
class FormattingConflicts {
    static { this._selectors = new linkedList_js_1.LinkedList(); }
    static setFormatterSelector(selector) {
        const remove = FormattingConflicts._selectors.unshift(selector);
        return { dispose: remove };
    }
    static async select(formatter, document, mode, kind) {
        if (formatter.length === 0) {
            return undefined;
        }
        const selector = iterator_js_1.Iterable.first(FormattingConflicts._selectors);
        if (selector) {
            return await selector(formatter, document, mode, kind);
        }
        return undefined;
    }
}
exports.FormattingConflicts = FormattingConflicts;
async function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token, userGesture) {
    const instaService = accessor.get(instantiation_js_1.IInstantiationService);
    const { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    const model = (0, editorBrowser_js_1.isCodeEditor)(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    const provider = documentRangeFormattingEditProviderRegistry.ordered(model);
    const selected = await FormattingConflicts.select(provider, model, mode, 2 /* FormattingKind.Selection */);
    if (selected) {
        progress.report(selected);
        await instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token, userGesture);
    }
}
async function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token, userGesture) {
    const workerService = accessor.get(editorWorker_js_1.IEditorWorkerService);
    const logService = accessor.get(log_js_1.ILogService);
    const accessibilitySignalService = accessor.get(accessibilitySignalService_js_1.IAccessibilitySignalService);
    let model;
    let cts;
    if ((0, editorBrowser_js_1.isCodeEditor)(editorOrModel)) {
        model = editorOrModel.getModel();
        cts = new editorState_js_1.EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);
    }
    else {
        model = editorOrModel;
        cts = new editorState_js_1.TextModelCancellationTokenSource(editorOrModel, token);
    }
    // make sure that ranges don't overlap nor touch each other
    const ranges = [];
    let len = 0;
    for (const range of (0, arrays_js_1.asArray)(rangeOrRanges).sort(range_js_1.Range.compareRangesUsingStarts)) {
        if (len > 0 && range_js_1.Range.areIntersectingOrTouching(ranges[len - 1], range)) {
            ranges[len - 1] = range_js_1.Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());
        }
        else {
            len = ranges.push(range);
        }
    }
    const computeEdits = async (range) => {
        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, range);
        const result = (await provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];
        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);
        return result;
    };
    const hasIntersectingEdit = (a, b) => {
        if (!a.length || !b.length) {
            return false;
        }
        // quick exit if the list of ranges are completely unrelated [O(n)]
        const mergedA = a.reduce((acc, val) => { return range_js_1.Range.plusRange(acc, val.range); }, a[0].range);
        if (!b.some(x => { return range_js_1.Range.intersectRanges(mergedA, x.range); })) {
            return false;
        }
        // fallback to a complete check [O(n^2)]
        for (const edit of a) {
            for (const otherEdit of b) {
                if (range_js_1.Range.intersectRanges(edit.range, otherEdit.range)) {
                    return true;
                }
            }
        }
        return false;
    };
    const allEdits = [];
    const rawEditsList = [];
    try {
        if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {
            logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, ranges);
            const result = (await provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];
            logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);
            rawEditsList.push(result);
        }
        else {
            for (const range of ranges) {
                if (cts.token.isCancellationRequested) {
                    return true;
                }
                rawEditsList.push(await computeEdits(range));
            }
            for (let i = 0; i < ranges.length; ++i) {
                for (let j = i + 1; j < ranges.length; ++j) {
                    if (cts.token.isCancellationRequested) {
                        return true;
                    }
                    if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {
                        // Merge ranges i and j into a single range, recompute the associated edits
                        const mergedRange = range_js_1.Range.plusRange(ranges[i], ranges[j]);
                        const edits = await computeEdits(mergedRange);
                        ranges.splice(j, 1);
                        ranges.splice(i, 1);
                        ranges.push(mergedRange);
                        rawEditsList.splice(j, 1);
                        rawEditsList.splice(i, 1);
                        rawEditsList.push(edits);
                        // Restart scanning
                        i = 0;
                        j = 0;
                    }
                }
            }
        }
        for (const rawEdits of rawEditsList) {
            if (cts.token.isCancellationRequested) {
                return true;
            }
            const minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
            if (minimalEdits) {
                allEdits.push(...minimalEdits);
            }
        }
    }
    finally {
        cts.dispose();
    }
    if (allEdits.length === 0) {
        return false;
    }
    if ((0, editorBrowser_js_1.isCodeEditor)(editorOrModel)) {
        // use editor to apply edits
        formattingEdit_js_1.FormattingEdit.execute(editorOrModel, allEdits, true);
        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);
    }
    else {
        // use model to apply edits
        const [{ range }] = allEdits;
        const initialSelection = new selection_js_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        model.pushEditOperations([initialSelection], allEdits.map(edit => {
            return {
                text: edit.text,
                range: range_js_1.Range.lift(edit.range),
                forceMoveMarkers: true
            };
        }), undoEdits => {
            for (const { range } of undoEdits) {
                if (range_js_1.Range.areIntersectingOrTouching(range, initialSelection)) {
                    return [new selection_js_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
                }
            }
            return null;
        });
    }
    accessibilitySignalService.playSignal(accessibilitySignalService_js_1.AccessibilitySignal.format, { userGesture });
    return true;
}
async function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token, userGesture) {
    const instaService = accessor.get(instantiation_js_1.IInstantiationService);
    const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    const model = (0, editorBrowser_js_1.isCodeEditor)(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
    const selected = await FormattingConflicts.select(provider, model, mode, 1 /* FormattingKind.File */);
    if (selected) {
        progress.report(selected);
        await instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token, userGesture);
    }
}
async function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token, userGesture) {
    const workerService = accessor.get(editorWorker_js_1.IEditorWorkerService);
    const accessibilitySignalService = accessor.get(accessibilitySignalService_js_1.IAccessibilitySignalService);
    let model;
    let cts;
    if ((0, editorBrowser_js_1.isCodeEditor)(editorOrModel)) {
        model = editorOrModel.getModel();
        cts = new editorState_js_1.EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);
    }
    else {
        model = editorOrModel;
        cts = new editorState_js_1.TextModelCancellationTokenSource(editorOrModel, token);
    }
    let edits;
    try {
        const rawEdits = await provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);
        edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
        if (cts.token.isCancellationRequested) {
            return true;
        }
    }
    finally {
        cts.dispose();
    }
    if (!edits || edits.length === 0) {
        return false;
    }
    if ((0, editorBrowser_js_1.isCodeEditor)(editorOrModel)) {
        // use editor to apply edits
        formattingEdit_js_1.FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);
        if (mode !== 2 /* FormattingMode.Silent */) {
            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);
        }
    }
    else {
        // use model to apply edits
        const [{ range }] = edits;
        const initialSelection = new selection_js_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        model.pushEditOperations([initialSelection], edits.map(edit => {
            return {
                text: edit.text,
                range: range_js_1.Range.lift(edit.range),
                forceMoveMarkers: true
            };
        }), undoEdits => {
            for (const { range } of undoEdits) {
                if (range_js_1.Range.areIntersectingOrTouching(range, initialSelection)) {
                    return [new selection_js_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
                }
            }
            return null;
        });
    }
    accessibilitySignalService.playSignal(accessibilitySignalService_js_1.AccessibilitySignal.format, { userGesture });
    return true;
}
async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {
    const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);
    for (const provider of providers) {
        const rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(errors_js_1.onUnexpectedExternalError);
        if ((0, arrays_js_1.isNonEmptyArray)(rawEdits)) {
            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
        }
    }
    return undefined;
}
async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {
    const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
    for (const provider of providers) {
        const rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(errors_js_1.onUnexpectedExternalError);
        if ((0, arrays_js_1.isNonEmptyArray)(rawEdits)) {
            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
        }
    }
    return undefined;
}
async function getDocumentFormattingEditsWithSelectedProvider(workerService, languageFeaturesService, editorOrModel, mode, token) {
    const model = (0, editorBrowser_js_1.isCodeEditor)(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
    const selected = await FormattingConflicts.select(provider, model, mode, 1 /* FormattingKind.File */);
    if (selected) {
        const rawEdits = await Promise.resolve(selected.provideDocumentFormattingEdits(model, model.getOptions(), token)).catch(errors_js_1.onUnexpectedExternalError);
        return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
    }
    return undefined;
}
function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {
    const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
    if (providers.length === 0) {
        return Promise.resolve(undefined);
    }
    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {
        return Promise.resolve(undefined);
    }
    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(errors_js_1.onUnexpectedExternalError).then(edits => {
        return workerService.computeMoreMinimalEdits(model.uri, edits);
    });
}
commands_js_1.CommandsRegistry.registerCommand('_executeFormatRangeProvider', async function (accessor, ...args) {
    const [resource, range, options] = args;
    (0, types_js_1.assertType)(uri_js_1.URI.isUri(resource));
    (0, types_js_1.assertType)(range_js_1.Range.isIRange(range));
    const resolverService = accessor.get(resolverService_js_1.ITextModelService);
    const workerService = accessor.get(editorWorker_js_1.IEditorWorkerService);
    const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    const reference = await resolverService.createModelReference(resource);
    try {
        return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, range_js_1.Range.lift(range), options, cancellation_js_1.CancellationToken.None);
    }
    finally {
        reference.dispose();
    }
});
commands_js_1.CommandsRegistry.registerCommand('_executeFormatDocumentProvider', async function (accessor, ...args) {
    const [resource, options] = args;
    (0, types_js_1.assertType)(uri_js_1.URI.isUri(resource));
    const resolverService = accessor.get(resolverService_js_1.ITextModelService);
    const workerService = accessor.get(editorWorker_js_1.IEditorWorkerService);
    const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    const reference = await resolverService.createModelReference(resource);
    try {
        return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, cancellation_js_1.CancellationToken.None);
    }
    finally {
        reference.dispose();
    }
});
commands_js_1.CommandsRegistry.registerCommand('_executeFormatOnTypeProvider', async function (accessor, ...args) {
    const [resource, position, ch, options] = args;
    (0, types_js_1.assertType)(uri_js_1.URI.isUri(resource));
    (0, types_js_1.assertType)(position_js_1.Position.isIPosition(position));
    (0, types_js_1.assertType)(typeof ch === 'string');
    const resolverService = accessor.get(resolverService_js_1.ITextModelService);
    const workerService = accessor.get(editorWorker_js_1.IEditorWorkerService);
    const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    const reference = await resolverService.createModelReference(resource);
    try {
        return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, position_js_1.Position.lift(position), ch, options, cancellation_js_1.CancellationToken.None);
    }
    finally {
        reference.dispose();
    }
});
//# sourceMappingURL=format.js.map