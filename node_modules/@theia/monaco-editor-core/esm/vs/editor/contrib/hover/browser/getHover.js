"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverProviderResult = void 0;
exports.getHoverProviderResultsAsAsyncIterable = getHoverProviderResultsAsAsyncIterable;
exports.getHoversPromise = getHoversPromise;
const async_js_1 = require("../../../../base/common/async.js");
const cancellation_js_1 = require("../../../../base/common/cancellation.js");
const errors_js_1 = require("../../../../base/common/errors.js");
const editorExtensions_js_1 = require("../../../browser/editorExtensions.js");
const languageFeatures_js_1 = require("../../../common/services/languageFeatures.js");
class HoverProviderResult {
    constructor(provider, hover, ordinal) {
        this.provider = provider;
        this.hover = hover;
        this.ordinal = ordinal;
    }
}
exports.HoverProviderResult = HoverProviderResult;
/**
 * Does not throw or return a rejected promise (returns undefined instead).
 */
async function executeProvider(provider, ordinal, model, position, token) {
    const result = await Promise
        .resolve(provider.provideHover(model, position, token))
        .catch(errors_js_1.onUnexpectedExternalError);
    if (!result || !isValid(result)) {
        return undefined;
    }
    return new HoverProviderResult(provider, result, ordinal);
}
function getHoverProviderResultsAsAsyncIterable(registry, model, position, token, recursive = false) {
    const providers = registry.ordered(model, recursive);
    const promises = providers.map((provider, index) => executeProvider(provider, index, model, position, token));
    return async_js_1.AsyncIterableObject.fromPromisesResolveOrder(promises).coalesce();
}
function getHoversPromise(registry, model, position, token, recursive = false) {
    return getHoverProviderResultsAsAsyncIterable(registry, model, position, token, recursive).map(item => item.hover).toPromise();
}
(0, editorExtensions_js_1.registerModelAndPositionCommand)('_executeHoverProvider', (accessor, model, position) => {
    const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    return getHoversPromise(languageFeaturesService.hoverProvider, model, position, cancellation_js_1.CancellationToken.None);
});
(0, editorExtensions_js_1.registerModelAndPositionCommand)('_executeHoverProvider_recursive', (accessor, model, position) => {
    const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
    return getHoversPromise(languageFeaturesService.hoverProvider, model, position, cancellation_js_1.CancellationToken.None, true);
});
function isValid(result) {
    const hasRange = (typeof result.range !== 'undefined');
    const hasHtmlContent = typeof result.contents !== 'undefined' && result.contents && result.contents.length > 0;
    return hasRange && hasHtmlContent;
}
//# sourceMappingURL=getHover.js.map