"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefinitionAction = exports.SymbolNavigationAction = exports.SymbolNavigationAnchor = void 0;
const aria_js_1 = require("../../../../base/browser/ui/aria/aria.js");
const async_js_1 = require("../../../../base/common/async.js");
const keyCodes_js_1 = require("../../../../base/common/keyCodes.js");
const types_js_1 = require("../../../../base/common/types.js");
const uri_js_1 = require("../../../../base/common/uri.js");
const editorState_js_1 = require("../../editorState/browser/editorState.js");
const editorBrowser_js_1 = require("../../../browser/editorBrowser.js");
const editorExtensions_js_1 = require("../../../browser/editorExtensions.js");
const codeEditorService_js_1 = require("../../../browser/services/codeEditorService.js");
const embeddedCodeEditorWidget_js_1 = require("../../../browser/widget/codeEditor/embeddedCodeEditorWidget.js");
const corePosition = require("../../../common/core/position.js");
const range_js_1 = require("../../../common/core/range.js");
const editorContextKeys_js_1 = require("../../../common/editorContextKeys.js");
const languages_js_1 = require("../../../common/languages.js");
const referencesController_js_1 = require("./peek/referencesController.js");
const referencesModel_js_1 = require("./referencesModel.js");
const symbolNavigation_js_1 = require("./symbolNavigation.js");
const messageController_js_1 = require("../../message/browser/messageController.js");
const peekView_js_1 = require("../../peekView/browser/peekView.js");
const nls = require("../../../../nls.js");
const actions_js_1 = require("../../../../platform/actions/common/actions.js");
const commands_js_1 = require("../../../../platform/commands/common/commands.js");
const contextkey_js_1 = require("../../../../platform/contextkey/common/contextkey.js");
const instantiation_js_1 = require("../../../../platform/instantiation/common/instantiation.js");
const notification_js_1 = require("../../../../platform/notification/common/notification.js");
const progress_js_1 = require("../../../../platform/progress/common/progress.js");
const goToSymbol_js_1 = require("./goToSymbol.js");
const languageFeatures_js_1 = require("../../../common/services/languageFeatures.js");
const iterator_js_1 = require("../../../../base/common/iterator.js");
const contextkeys_js_1 = require("../../../../platform/contextkey/common/contextkeys.js");
actions_js_1.MenuRegistry.appendMenuItem(actions_js_1.MenuId.EditorContext, {
    submenu: actions_js_1.MenuId.EditorContextPeek,
    title: nls.localize('peek.submenu', "Peek"),
    group: 'navigation',
    order: 100
});
class SymbolNavigationAnchor {
    static is(thing) {
        if (!thing || typeof thing !== 'object') {
            return false;
        }
        if (thing instanceof SymbolNavigationAnchor) {
            return true;
        }
        if (corePosition.Position.isIPosition(thing.position) && thing.model) {
            return true;
        }
        return false;
    }
    constructor(model, position) {
        this.model = model;
        this.position = position;
    }
}
exports.SymbolNavigationAnchor = SymbolNavigationAnchor;
class SymbolNavigationAction extends editorExtensions_js_1.EditorAction2 {
    static { this._allSymbolNavigationCommands = new Map(); }
    static { this._activeAlternativeCommands = new Set(); }
    static all() {
        return SymbolNavigationAction._allSymbolNavigationCommands.values();
    }
    static _patchConfig(opts) {
        const result = { ...opts, f1: true };
        // patch context menu when clause
        if (result.menu) {
            for (const item of iterator_js_1.Iterable.wrap(result.menu)) {
                if (item.id === actions_js_1.MenuId.EditorContext || item.id === actions_js_1.MenuId.EditorContextPeek) {
                    item.when = contextkey_js_1.ContextKeyExpr.and(opts.precondition, item.when);
                }
            }
        }
        return result;
    }
    constructor(configuration, opts) {
        super(SymbolNavigationAction._patchConfig(opts));
        this.configuration = configuration;
        SymbolNavigationAction._allSymbolNavigationCommands.set(opts.id, this);
    }
    runEditorCommand(accessor, editor, arg, range) {
        if (!editor.hasModel()) {
            return Promise.resolve(undefined);
        }
        const notificationService = accessor.get(notification_js_1.INotificationService);
        const editorService = accessor.get(codeEditorService_js_1.ICodeEditorService);
        const progressService = accessor.get(progress_js_1.IEditorProgressService);
        const symbolNavService = accessor.get(symbolNavigation_js_1.ISymbolNavigationService);
        const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
        const instaService = accessor.get(instantiation_js_1.IInstantiationService);
        const model = editor.getModel();
        const position = editor.getPosition();
        const anchor = SymbolNavigationAnchor.is(arg) ? arg : new SymbolNavigationAnchor(model, position);
        const cts = new editorState_js_1.EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */);
        const promise = (0, async_js_1.raceCancellation)(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then(async (references) => {
            if (!references || cts.token.isCancellationRequested) {
                return;
            }
            (0, aria_js_1.alert)(references.ariaMessage);
            let altAction;
            if (references.referenceAt(model.uri, position)) {
                const altActionId = this._getAlternativeCommand(editor);
                if (!SymbolNavigationAction._activeAlternativeCommands.has(altActionId) && SymbolNavigationAction._allSymbolNavigationCommands.has(altActionId)) {
                    altAction = SymbolNavigationAction._allSymbolNavigationCommands.get(altActionId);
                }
            }
            const referenceCount = references.references.length;
            if (referenceCount === 0) {
                // no result -> show message
                if (!this.configuration.muteMessage) {
                    const info = model.getWordAtPosition(position);
                    messageController_js_1.MessageController.get(editor)?.showMessage(this._getNoResultFoundMessage(info), position);
                }
            }
            else if (referenceCount === 1 && altAction) {
                // already at the only result, run alternative
                SymbolNavigationAction._activeAlternativeCommands.add(this.desc.id);
                instaService.invokeFunction((accessor) => altAction.runEditorCommand(accessor, editor, arg, range).finally(() => {
                    SymbolNavigationAction._activeAlternativeCommands.delete(this.desc.id);
                }));
            }
            else {
                // normal results handling
                return this._onResult(editorService, symbolNavService, editor, references, range);
            }
        }, (err) => {
            // report an error
            notificationService.error(err);
        }).finally(() => {
            cts.dispose();
        });
        progressService.showWhile(promise, 250);
        return promise;
    }
    async _onResult(editorService, symbolNavService, editor, model, range) {
        const gotoLocation = this._getGoToPreference(editor);
        if (!(editor instanceof embeddedCodeEditorWidget_js_1.EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || (gotoLocation === 'peek' && model.references.length > 1))) {
            this._openInPeek(editor, model, range);
        }
        else {
            const next = model.firstReference();
            const peek = model.references.length > 1 && gotoLocation === 'gotoAndPeek';
            const targetEditor = await this._openReference(editor, editorService, next, this.configuration.openToSide, !peek);
            if (peek && targetEditor) {
                this._openInPeek(targetEditor, model, range);
            }
            else {
                model.dispose();
            }
            // keep remaining locations around when using
            // 'goto'-mode
            if (gotoLocation === 'goto') {
                symbolNavService.put(next);
            }
        }
    }
    async _openReference(editor, editorService, reference, sideBySide, highlight) {
        // range is the target-selection-range when we have one
        // and the fallback is the 'full' range
        let range = undefined;
        if ((0, languages_js_1.isLocationLink)(reference)) {
            range = reference.targetSelectionRange;
        }
        if (!range) {
            range = reference.range;
        }
        if (!range) {
            return undefined;
        }
        const targetEditor = await editorService.openCodeEditor({
            resource: reference.uri,
            options: {
                selection: range_js_1.Range.collapseToStart(range),
                selectionRevealType: 3 /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */,
                selectionSource: "code.jump" /* TextEditorSelectionSource.JUMP */
            }
        }, editor, sideBySide);
        if (!targetEditor) {
            return undefined;
        }
        if (highlight) {
            const modelNow = targetEditor.getModel();
            const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: 'symbol-navigate-action-highlight', className: 'symbolHighlight' } }]);
            setTimeout(() => {
                if (targetEditor.getModel() === modelNow) {
                    decorations.clear();
                }
            }, 350);
        }
        return targetEditor;
    }
    _openInPeek(target, model, range) {
        const controller = referencesController_js_1.ReferencesController.get(target);
        if (controller && target.hasModel()) {
            controller.toggleWidget(range ?? target.getSelection(), (0, async_js_1.createCancelablePromise)(_ => Promise.resolve(model)), this.configuration.openInPeek);
        }
        else {
            model.dispose();
        }
    }
}
exports.SymbolNavigationAction = SymbolNavigationAction;
//#region --- DEFINITION
class DefinitionAction extends SymbolNavigationAction {
    async _getLocationModel(languageFeaturesService, model, position, token) {
        return new referencesModel_js_1.ReferencesModel(await (0, goToSymbol_js_1.getDefinitionsAtPosition)(languageFeaturesService.definitionProvider, model, position, false, token), nls.localize('def.title', 'Definitions'));
    }
    _getNoResultFoundMessage(info) {
        return info && info.word
            ? nls.localize('noResultWord', "No definition found for '{0}'", info.word)
            : nls.localize('generic.noResults', "No definition found");
    }
    _getAlternativeCommand(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).alternativeDefinitionCommand;
    }
    _getGoToPreference(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).multipleDefinitions;
    }
}
exports.DefinitionAction = DefinitionAction;
(0, actions_js_1.registerAction2)(class GoToDefinitionAction extends DefinitionAction {
    static { this.id = 'editor.action.revealDefinition'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: false,
            muteMessage: false
        }, {
            id: GoToDefinitionAction.id,
            title: {
                ...nls.localize2('actions.goToDecl.label', "Go to Definition"),
                mnemonicTitle: nls.localize({ key: 'miGotoDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Definition"),
            },
            precondition: editorContextKeys_js_1.EditorContextKeys.hasDefinitionProvider,
            keybinding: [{
                    when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                    primary: 70 /* KeyCode.F12 */,
                    weight: 100 /* KeybindingWeight.EditorContrib */
                }, {
                    when: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.editorTextFocus, contextkeys_js_1.IsWebContext),
                    primary: 2048 /* KeyMod.CtrlCmd */ | 70 /* KeyCode.F12 */,
                    weight: 100 /* KeybindingWeight.EditorContrib */
                }],
            menu: [{
                    id: actions_js_1.MenuId.EditorContext,
                    group: 'navigation',
                    order: 1.1
                }, {
                    id: actions_js_1.MenuId.MenubarGoMenu,
                    precondition: null,
                    group: '4_symbol_nav',
                    order: 2,
                }]
        });
        commands_js_1.CommandsRegistry.registerCommandAlias('editor.action.goToDeclaration', GoToDefinitionAction.id);
    }
});
(0, actions_js_1.registerAction2)(class OpenDefinitionToSideAction extends DefinitionAction {
    static { this.id = 'editor.action.revealDefinitionAside'; }
    constructor() {
        super({
            openToSide: true,
            openInPeek: false,
            muteMessage: false
        }, {
            id: OpenDefinitionToSideAction.id,
            title: nls.localize2('actions.goToDeclToSide.label', "Open Definition to the Side"),
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasDefinitionProvider, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            keybinding: [{
                    when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                    primary: (0, keyCodes_js_1.KeyChord)(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 70 /* KeyCode.F12 */),
                    weight: 100 /* KeybindingWeight.EditorContrib */
                }, {
                    when: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.editorTextFocus, contextkeys_js_1.IsWebContext),
                    primary: (0, keyCodes_js_1.KeyChord)(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 70 /* KeyCode.F12 */),
                    weight: 100 /* KeybindingWeight.EditorContrib */
                }]
        });
        commands_js_1.CommandsRegistry.registerCommandAlias('editor.action.openDeclarationToTheSide', OpenDefinitionToSideAction.id);
    }
});
(0, actions_js_1.registerAction2)(class PeekDefinitionAction extends DefinitionAction {
    static { this.id = 'editor.action.peekDefinition'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: true,
            muteMessage: false
        }, {
            id: PeekDefinitionAction.id,
            title: nls.localize2('actions.previewDecl.label', "Peek Definition"),
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasDefinitionProvider, peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            keybinding: {
                when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                primary: 512 /* KeyMod.Alt */ | 70 /* KeyCode.F12 */,
                linux: { primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 68 /* KeyCode.F10 */ },
                weight: 100 /* KeybindingWeight.EditorContrib */
            },
            menu: {
                id: actions_js_1.MenuId.EditorContextPeek,
                group: 'peek',
                order: 2
            }
        });
        commands_js_1.CommandsRegistry.registerCommandAlias('editor.action.previewDeclaration', PeekDefinitionAction.id);
    }
});
//#endregion
//#region --- DECLARATION
class DeclarationAction extends SymbolNavigationAction {
    async _getLocationModel(languageFeaturesService, model, position, token) {
        return new referencesModel_js_1.ReferencesModel(await (0, goToSymbol_js_1.getDeclarationsAtPosition)(languageFeaturesService.declarationProvider, model, position, false, token), nls.localize('decl.title', 'Declarations'));
    }
    _getNoResultFoundMessage(info) {
        return info && info.word
            ? nls.localize('decl.noResultWord', "No declaration found for '{0}'", info.word)
            : nls.localize('decl.generic.noResults', "No declaration found");
    }
    _getAlternativeCommand(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).alternativeDeclarationCommand;
    }
    _getGoToPreference(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).multipleDeclarations;
    }
}
(0, actions_js_1.registerAction2)(class GoToDeclarationAction extends DeclarationAction {
    static { this.id = 'editor.action.revealDeclaration'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: false,
            muteMessage: false
        }, {
            id: GoToDeclarationAction.id,
            title: {
                ...nls.localize2('actions.goToDeclaration.label', "Go to Declaration"),
                mnemonicTitle: nls.localize({ key: 'miGotoDeclaration', comment: ['&& denotes a mnemonic'] }, "Go to &&Declaration"),
            },
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasDeclarationProvider, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            menu: [{
                    id: actions_js_1.MenuId.EditorContext,
                    group: 'navigation',
                    order: 1.3
                }, {
                    id: actions_js_1.MenuId.MenubarGoMenu,
                    precondition: null,
                    group: '4_symbol_nav',
                    order: 3,
                }],
        });
    }
    _getNoResultFoundMessage(info) {
        return info && info.word
            ? nls.localize('decl.noResultWord', "No declaration found for '{0}'", info.word)
            : nls.localize('decl.generic.noResults', "No declaration found");
    }
});
(0, actions_js_1.registerAction2)(class PeekDeclarationAction extends DeclarationAction {
    constructor() {
        super({
            openToSide: false,
            openInPeek: true,
            muteMessage: false
        }, {
            id: 'editor.action.peekDeclaration',
            title: nls.localize2('actions.peekDecl.label', "Peek Declaration"),
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasDeclarationProvider, peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            menu: {
                id: actions_js_1.MenuId.EditorContextPeek,
                group: 'peek',
                order: 3
            }
        });
    }
});
//#endregion
//#region --- TYPE DEFINITION
class TypeDefinitionAction extends SymbolNavigationAction {
    async _getLocationModel(languageFeaturesService, model, position, token) {
        return new referencesModel_js_1.ReferencesModel(await (0, goToSymbol_js_1.getTypeDefinitionsAtPosition)(languageFeaturesService.typeDefinitionProvider, model, position, false, token), nls.localize('typedef.title', 'Type Definitions'));
    }
    _getNoResultFoundMessage(info) {
        return info && info.word
            ? nls.localize('goToTypeDefinition.noResultWord', "No type definition found for '{0}'", info.word)
            : nls.localize('goToTypeDefinition.generic.noResults', "No type definition found");
    }
    _getAlternativeCommand(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).alternativeTypeDefinitionCommand;
    }
    _getGoToPreference(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).multipleTypeDefinitions;
    }
}
(0, actions_js_1.registerAction2)(class GoToTypeDefinitionAction extends TypeDefinitionAction {
    static { this.ID = 'editor.action.goToTypeDefinition'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: false,
            muteMessage: false
        }, {
            id: GoToTypeDefinitionAction.ID,
            title: {
                ...nls.localize2('actions.goToTypeDefinition.label', "Go to Type Definition"),
                mnemonicTitle: nls.localize({ key: 'miGotoTypeDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Type Definition"),
            },
            precondition: editorContextKeys_js_1.EditorContextKeys.hasTypeDefinitionProvider,
            keybinding: {
                when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                primary: 0,
                weight: 100 /* KeybindingWeight.EditorContrib */
            },
            menu: [{
                    id: actions_js_1.MenuId.EditorContext,
                    group: 'navigation',
                    order: 1.4
                }, {
                    id: actions_js_1.MenuId.MenubarGoMenu,
                    precondition: null,
                    group: '4_symbol_nav',
                    order: 3,
                }]
        });
    }
});
(0, actions_js_1.registerAction2)(class PeekTypeDefinitionAction extends TypeDefinitionAction {
    static { this.ID = 'editor.action.peekTypeDefinition'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: true,
            muteMessage: false
        }, {
            id: PeekTypeDefinitionAction.ID,
            title: nls.localize2('actions.peekTypeDefinition.label', "Peek Type Definition"),
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasTypeDefinitionProvider, peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            menu: {
                id: actions_js_1.MenuId.EditorContextPeek,
                group: 'peek',
                order: 4
            }
        });
    }
});
//#endregion
//#region --- IMPLEMENTATION
class ImplementationAction extends SymbolNavigationAction {
    async _getLocationModel(languageFeaturesService, model, position, token) {
        return new referencesModel_js_1.ReferencesModel(await (0, goToSymbol_js_1.getImplementationsAtPosition)(languageFeaturesService.implementationProvider, model, position, false, token), nls.localize('impl.title', 'Implementations'));
    }
    _getNoResultFoundMessage(info) {
        return info && info.word
            ? nls.localize('goToImplementation.noResultWord', "No implementation found for '{0}'", info.word)
            : nls.localize('goToImplementation.generic.noResults', "No implementation found");
    }
    _getAlternativeCommand(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).alternativeImplementationCommand;
    }
    _getGoToPreference(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).multipleImplementations;
    }
}
(0, actions_js_1.registerAction2)(class GoToImplementationAction extends ImplementationAction {
    static { this.ID = 'editor.action.goToImplementation'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: false,
            muteMessage: false
        }, {
            id: GoToImplementationAction.ID,
            title: {
                ...nls.localize2('actions.goToImplementation.label', "Go to Implementations"),
                mnemonicTitle: nls.localize({ key: 'miGotoImplementation', comment: ['&& denotes a mnemonic'] }, "Go to &&Implementations"),
            },
            precondition: editorContextKeys_js_1.EditorContextKeys.hasImplementationProvider,
            keybinding: {
                when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                primary: 2048 /* KeyMod.CtrlCmd */ | 70 /* KeyCode.F12 */,
                weight: 100 /* KeybindingWeight.EditorContrib */
            },
            menu: [{
                    id: actions_js_1.MenuId.EditorContext,
                    group: 'navigation',
                    order: 1.45
                }, {
                    id: actions_js_1.MenuId.MenubarGoMenu,
                    precondition: null,
                    group: '4_symbol_nav',
                    order: 4,
                }]
        });
    }
});
(0, actions_js_1.registerAction2)(class PeekImplementationAction extends ImplementationAction {
    static { this.ID = 'editor.action.peekImplementation'; }
    constructor() {
        super({
            openToSide: false,
            openInPeek: true,
            muteMessage: false
        }, {
            id: PeekImplementationAction.ID,
            title: nls.localize2('actions.peekImplementation.label', "Peek Implementations"),
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasImplementationProvider, peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            keybinding: {
                when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 70 /* KeyCode.F12 */,
                weight: 100 /* KeybindingWeight.EditorContrib */
            },
            menu: {
                id: actions_js_1.MenuId.EditorContextPeek,
                group: 'peek',
                order: 5
            }
        });
    }
});
//#endregion
//#region --- REFERENCES
class ReferencesAction extends SymbolNavigationAction {
    _getNoResultFoundMessage(info) {
        return info
            ? nls.localize('references.no', "No references found for '{0}'", info.word)
            : nls.localize('references.noGeneric', "No references found");
    }
    _getAlternativeCommand(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).alternativeReferenceCommand;
    }
    _getGoToPreference(editor) {
        return editor.getOption(60 /* EditorOption.gotoLocation */).multipleReferences;
    }
}
(0, actions_js_1.registerAction2)(class GoToReferencesAction extends ReferencesAction {
    constructor() {
        super({
            openToSide: false,
            openInPeek: false,
            muteMessage: false
        }, {
            id: 'editor.action.goToReferences',
            title: {
                ...nls.localize2('goToReferences.label', "Go to References"),
                mnemonicTitle: nls.localize({ key: 'miGotoReference', comment: ['&& denotes a mnemonic'] }, "Go to &&References"),
            },
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasReferenceProvider, peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            keybinding: {
                when: editorContextKeys_js_1.EditorContextKeys.editorTextFocus,
                primary: 1024 /* KeyMod.Shift */ | 70 /* KeyCode.F12 */,
                weight: 100 /* KeybindingWeight.EditorContrib */
            },
            menu: [{
                    id: actions_js_1.MenuId.EditorContext,
                    group: 'navigation',
                    order: 1.45
                }, {
                    id: actions_js_1.MenuId.MenubarGoMenu,
                    precondition: null,
                    group: '4_symbol_nav',
                    order: 5,
                }]
        });
    }
    async _getLocationModel(languageFeaturesService, model, position, token) {
        return new referencesModel_js_1.ReferencesModel(await (0, goToSymbol_js_1.getReferencesAtPosition)(languageFeaturesService.referenceProvider, model, position, true, false, token), nls.localize('ref.title', 'References'));
    }
});
(0, actions_js_1.registerAction2)(class PeekReferencesAction extends ReferencesAction {
    constructor() {
        super({
            openToSide: false,
            openInPeek: true,
            muteMessage: false
        }, {
            id: 'editor.action.referenceSearch.trigger',
            title: nls.localize2('references.action.label', "Peek References"),
            precondition: contextkey_js_1.ContextKeyExpr.and(editorContextKeys_js_1.EditorContextKeys.hasReferenceProvider, peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
            menu: {
                id: actions_js_1.MenuId.EditorContextPeek,
                group: 'peek',
                order: 6
            }
        });
    }
    async _getLocationModel(languageFeaturesService, model, position, token) {
        return new referencesModel_js_1.ReferencesModel(await (0, goToSymbol_js_1.getReferencesAtPosition)(languageFeaturesService.referenceProvider, model, position, false, false, token), nls.localize('ref.title', 'References'));
    }
});
//#endregion
//#region --- GENERIC goto symbols command
class GenericGoToLocationAction extends SymbolNavigationAction {
    constructor(config, _references, _gotoMultipleBehaviour) {
        super(config, {
            id: 'editor.action.goToLocation',
            title: nls.localize2('label.generic', "Go to Any Symbol"),
            precondition: contextkey_js_1.ContextKeyExpr.and(peekView_js_1.PeekContext.notInPeekEditor, editorContextKeys_js_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),
        });
        this._references = _references;
        this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
    }
    async _getLocationModel(languageFeaturesService, _model, _position, _token) {
        return new referencesModel_js_1.ReferencesModel(this._references, nls.localize('generic.title', 'Locations'));
    }
    _getNoResultFoundMessage(info) {
        return info && nls.localize('generic.noResult', "No results for '{0}'", info.word) || '';
    }
    _getGoToPreference(editor) {
        return this._gotoMultipleBehaviour ?? editor.getOption(60 /* EditorOption.gotoLocation */).multipleReferences;
    }
    _getAlternativeCommand() { return ''; }
}
commands_js_1.CommandsRegistry.registerCommand({
    id: 'editor.action.goToLocations',
    metadata: {
        description: 'Go to locations from a position in a file',
        args: [
            { name: 'uri', description: 'The text document in which to start', constraint: uri_js_1.URI },
            { name: 'position', description: 'The position at which to start', constraint: corePosition.Position.isIPosition },
            { name: 'locations', description: 'An array of locations.', constraint: Array },
            { name: 'multiple', description: 'Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`' },
            { name: 'noResultsMessage', description: 'Human readable message that shows when locations is empty.' },
        ]
    },
    handler: async (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => {
        (0, types_js_1.assertType)(uri_js_1.URI.isUri(resource));
        (0, types_js_1.assertType)(corePosition.Position.isIPosition(position));
        (0, types_js_1.assertType)(Array.isArray(references));
        (0, types_js_1.assertType)(typeof multiple === 'undefined' || typeof multiple === 'string');
        (0, types_js_1.assertType)(typeof openInPeek === 'undefined' || typeof openInPeek === 'boolean');
        const editorService = accessor.get(codeEditorService_js_1.ICodeEditorService);
        const editor = await editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
        if ((0, editorBrowser_js_1.isCodeEditor)(editor)) {
            editor.setPosition(position);
            editor.revealPositionInCenterIfOutsideViewport(position, 0 /* ScrollType.Smooth */);
            return editor.invokeWithinContext(accessor => {
                const command = new class extends GenericGoToLocationAction {
                    _getNoResultFoundMessage(info) {
                        return noResultsMessage || super._getNoResultFoundMessage(info);
                    }
                }({
                    muteMessage: !Boolean(noResultsMessage),
                    openInPeek: Boolean(openInPeek),
                    openToSide: false
                }, references, multiple);
                accessor.get(instantiation_js_1.IInstantiationService).invokeFunction(command.run.bind(command), editor);
            });
        }
    }
});
commands_js_1.CommandsRegistry.registerCommand({
    id: 'editor.action.peekLocations',
    metadata: {
        description: 'Peek locations from a position in a file',
        args: [
            { name: 'uri', description: 'The text document in which to start', constraint: uri_js_1.URI },
            { name: 'position', description: 'The position at which to start', constraint: corePosition.Position.isIPosition },
            { name: 'locations', description: 'An array of locations.', constraint: Array },
            { name: 'multiple', description: 'Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`' },
        ]
    },
    handler: async (accessor, resource, position, references, multiple) => {
        accessor.get(commands_js_1.ICommandService).executeCommand('editor.action.goToLocations', resource, position, references, multiple, undefined, true);
    }
});
//#endregion
//#region --- REFERENCE search special commands
commands_js_1.CommandsRegistry.registerCommand({
    id: 'editor.action.findReferences',
    handler: (accessor, resource, position) => {
        (0, types_js_1.assertType)(uri_js_1.URI.isUri(resource));
        (0, types_js_1.assertType)(corePosition.Position.isIPosition(position));
        const languageFeaturesService = accessor.get(languageFeatures_js_1.ILanguageFeaturesService);
        const codeEditorService = accessor.get(codeEditorService_js_1.ICodeEditorService);
        return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then(control => {
            if (!(0, editorBrowser_js_1.isCodeEditor)(control) || !control.hasModel()) {
                return undefined;
            }
            const controller = referencesController_js_1.ReferencesController.get(control);
            if (!controller) {
                return undefined;
            }
            const references = (0, async_js_1.createCancelablePromise)(token => (0, goToSymbol_js_1.getReferencesAtPosition)(languageFeaturesService.referenceProvider, control.getModel(), corePosition.Position.lift(position), false, false, token).then(references => new referencesModel_js_1.ReferencesModel(references, nls.localize('ref.title', 'References'))));
            const range = new range_js_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            return Promise.resolve(controller.toggleWidget(range, references, false));
        });
    }
});
// use NEW command
commands_js_1.CommandsRegistry.registerCommandAlias('editor.action.showReferences', 'editor.action.peekLocations');
//#endregion
//# sourceMappingURL=goToCommands.js.map