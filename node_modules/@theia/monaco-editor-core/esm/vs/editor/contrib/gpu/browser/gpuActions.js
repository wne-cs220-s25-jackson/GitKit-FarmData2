"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const dom_js_1 = require("../../../../base/browser/dom.js");
const buffer_js_1 = require("../../../../base/common/buffer.js");
const uri_js_1 = require("../../../../base/common/uri.js");
const nls_js_1 = require("../../../../nls.js");
const configuration_js_1 = require("../../../../platform/configuration/common/configuration.js");
const contextkey_js_1 = require("../../../../platform/contextkey/common/contextkey.js");
const files_js_1 = require("../../../../platform/files/common/files.js");
const instantiation_js_1 = require("../../../../platform/instantiation/common/instantiation.js");
const log_js_1 = require("../../../../platform/log/common/log.js");
const quickInput_js_1 = require("../../../../platform/quickinput/common/quickInput.js");
const workspace_js_1 = require("../../../../platform/workspace/common/workspace.js");
const editorExtensions_js_1 = require("../../../browser/editorExtensions.js");
const gpuUtils_js_1 = require("../../../browser/gpu/gpuUtils.js");
const glyphRasterizer_js_1 = require("../../../browser/gpu/raster/glyphRasterizer.js");
const viewGpuContext_js_1 = require("../../../browser/gpu/viewGpuContext.js");
class DebugEditorGpuRendererAction extends editorExtensions_js_1.EditorAction {
    constructor() {
        super({
            id: 'editor.action.debugEditorGpuRenderer',
            label: (0, nls_js_1.localize2)('gpuDebug.label', "Developer: Debug Editor GPU Renderer"),
            // TODO: Why doesn't `ContextKeyExpr.equals('config:editor.experimentalGpuAcceleration', 'on')` work?
            precondition: contextkey_js_1.ContextKeyExpr.true(),
        });
    }
    async run(accessor, editor) {
        const instantiationService = accessor.get(instantiation_js_1.IInstantiationService);
        const quickInputService = accessor.get(quickInput_js_1.IQuickInputService);
        const choice = await quickInputService.pick([
            {
                label: (0, nls_js_1.localize)('logTextureAtlasStats.label', "Log Texture Atlas Stats"),
                id: 'logTextureAtlasStats',
            },
            {
                label: (0, nls_js_1.localize)('saveTextureAtlas.label', "Save Texture Atlas"),
                id: 'saveTextureAtlas',
            },
            {
                label: (0, nls_js_1.localize)('drawGlyph.label', "Draw Glyph"),
                id: 'drawGlyph',
            },
        ], { canPickMany: false });
        if (!choice) {
            return;
        }
        switch (choice.id) {
            case 'logTextureAtlasStats':
                instantiationService.invokeFunction(accessor => {
                    const logService = accessor.get(log_js_1.ILogService);
                    const atlas = viewGpuContext_js_1.ViewGpuContext.atlas;
                    if (!viewGpuContext_js_1.ViewGpuContext.atlas) {
                        logService.error('No texture atlas found');
                        return;
                    }
                    const stats = atlas.getStats();
                    logService.info(['Texture atlas stats', ...stats].join('\n\n'));
                });
                break;
            case 'saveTextureAtlas':
                instantiationService.invokeFunction(async (accessor) => {
                    const workspaceContextService = accessor.get(workspace_js_1.IWorkspaceContextService);
                    const fileService = accessor.get(files_js_1.IFileService);
                    const folders = workspaceContextService.getWorkspace().folders;
                    if (folders.length > 0) {
                        const atlas = viewGpuContext_js_1.ViewGpuContext.atlas;
                        const promises = [];
                        for (const [layerIndex, page] of atlas.pages.entries()) {
                            promises.push(...[
                                fileService.writeFile(uri_js_1.URI.joinPath(folders[0].uri, `textureAtlasPage${layerIndex}_actual.png`), buffer_js_1.VSBuffer.wrap(new Uint8Array(await (await page.source.convertToBlob()).arrayBuffer()))),
                                fileService.writeFile(uri_js_1.URI.joinPath(folders[0].uri, `textureAtlasPage${layerIndex}_usage.png`), buffer_js_1.VSBuffer.wrap(new Uint8Array(await (await page.getUsagePreview()).arrayBuffer()))),
                            ]);
                        }
                        await Promise.all(promises);
                    }
                });
                break;
            case 'drawGlyph':
                instantiationService.invokeFunction(async (accessor) => {
                    const configurationService = accessor.get(configuration_js_1.IConfigurationService);
                    const fileService = accessor.get(files_js_1.IFileService);
                    const quickInputService = accessor.get(quickInput_js_1.IQuickInputService);
                    const workspaceContextService = accessor.get(workspace_js_1.IWorkspaceContextService);
                    const folders = workspaceContextService.getWorkspace().folders;
                    if (folders.length === 0) {
                        return;
                    }
                    const atlas = viewGpuContext_js_1.ViewGpuContext.atlas;
                    const fontFamily = configurationService.getValue('editor.fontFamily');
                    const fontSize = configurationService.getValue('editor.fontSize');
                    const rasterizer = new glyphRasterizer_js_1.GlyphRasterizer(fontSize, fontFamily, (0, dom_js_1.getActiveWindow)().devicePixelRatio);
                    let chars = await quickInputService.input({
                        prompt: 'Enter a character to draw (prefix with 0x for code point))'
                    });
                    if (!chars) {
                        return;
                    }
                    const codePoint = chars.match(/0x(?<codePoint>[0-9a-f]+)/i)?.groups?.codePoint;
                    if (codePoint !== undefined) {
                        chars = String.fromCodePoint(parseInt(codePoint, 16));
                    }
                    const tokenMetadata = 0;
                    const charMetadata = 0;
                    const rasterizedGlyph = atlas.getGlyph(rasterizer, chars, tokenMetadata, charMetadata);
                    if (!rasterizedGlyph) {
                        return;
                    }
                    const imageData = atlas.pages[rasterizedGlyph.pageIndex].source.getContext('2d')?.getImageData(rasterizedGlyph.x, rasterizedGlyph.y, rasterizedGlyph.w, rasterizedGlyph.h);
                    if (!imageData) {
                        return;
                    }
                    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
                    const ctx = (0, gpuUtils_js_1.ensureNonNullable)(canvas.getContext('2d'));
                    ctx.putImageData(imageData, 0, 0);
                    const blob = await canvas.convertToBlob({ type: 'image/png' });
                    const resource = uri_js_1.URI.joinPath(folders[0].uri, `glyph_${chars}_${tokenMetadata}_${fontSize}px_${fontFamily.replaceAll(/[,\\\/\.'\s]/g, '_')}.png`);
                    await fileService.writeFile(resource, buffer_js_1.VSBuffer.wrap(new Uint8Array(await blob.arrayBuffer())));
                });
                break;
        }
    }
}
(0, editorExtensions_js_1.registerEditorAction)(DebugEditorGpuRendererAction);
//# sourceMappingURL=gpuActions.js.map