"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableContextKeyService = exports.ColumnRange = void 0;
exports.getReadonlyEmptyArray = getReadonlyEmptyArray;
exports.addPositions = addPositions;
exports.subtractPositions = subtractPositions;
exports.substringPos = substringPos;
exports.getEndPositionsAfterApplying = getEndPositionsAfterApplying;
exports.convertItemsToStableObservables = convertItemsToStableObservables;
const arrays_js_1 = require("../../../../base/common/arrays.js");
const errors_js_1 = require("../../../../base/common/errors.js");
const observable_js_1 = require("../../../../base/common/observable.js");
const strings_js_1 = require("../../../../base/common/strings.js");
const platformObservableUtils_js_1 = require("../../../../platform/observable/common/platformObservableUtils.js");
const position_js_1 = require("../../../common/core/position.js");
const range_js_1 = require("../../../common/core/range.js");
const textEdit_js_1 = require("../../../common/core/textEdit.js");
const array = [];
function getReadonlyEmptyArray() {
    return array;
}
class ColumnRange {
    constructor(startColumn, endColumnExclusive) {
        this.startColumn = startColumn;
        this.endColumnExclusive = endColumnExclusive;
        if (startColumn > endColumnExclusive) {
            throw new errors_js_1.BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);
        }
    }
    toRange(lineNumber) {
        return new range_js_1.Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);
    }
    equals(other) {
        return this.startColumn === other.startColumn
            && this.endColumnExclusive === other.endColumnExclusive;
    }
}
exports.ColumnRange = ColumnRange;
function addPositions(pos1, pos2) {
    return new position_js_1.Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);
}
function subtractPositions(pos1, pos2) {
    return new position_js_1.Position(pos1.lineNumber - pos2.lineNumber + 1, pos1.lineNumber - pos2.lineNumber === 0 ? pos1.column - pos2.column + 1 : pos1.column);
}
function substringPos(text, pos) {
    let subtext = '';
    const lines = (0, strings_js_1.splitLinesIncludeSeparators)(text);
    for (let i = pos.lineNumber - 1; i < lines.length; i++) {
        subtext += lines[i].substring(i === pos.lineNumber - 1 ? pos.column - 1 : 0);
    }
    return subtext;
}
function getEndPositionsAfterApplying(edits) {
    const sortPerm = arrays_js_1.Permutation.createSortPermutation(edits, (0, arrays_js_1.compareBy)(e => e.range, range_js_1.Range.compareRangesUsingStarts));
    const edit = new textEdit_js_1.TextEdit(sortPerm.apply(edits));
    const sortedNewRanges = edit.getNewRanges();
    const newRanges = sortPerm.inverse().apply(sortedNewRanges);
    return newRanges.map(range => range.getEndPosition());
}
function convertItemsToStableObservables(items, store) {
    const result = (0, observable_js_1.observableValue)('result', []);
    const innerObservables = [];
    store.add((0, observable_js_1.autorun)(reader => {
        const itemsValue = items.read(reader);
        (0, observable_js_1.transaction)(tx => {
            if (itemsValue.length !== innerObservables.length) {
                innerObservables.length = itemsValue.length;
                for (let i = 0; i < innerObservables.length; i++) {
                    if (!innerObservables[i]) {
                        innerObservables[i] = (0, observable_js_1.observableValue)('item', itemsValue[i]);
                    }
                }
                result.set([...innerObservables], tx);
            }
            innerObservables.forEach((o, i) => o.set(itemsValue[i], tx));
        });
    }));
    return result;
}
class ObservableContextKeyService {
    constructor(_contextKeyService) {
        this._contextKeyService = _contextKeyService;
    }
    bind(key, obs) {
        return (0, platformObservableUtils_js_1.bindContextKey)(key, this._contextKeyService, obs instanceof Function ? obs : reader => obs.read(reader));
    }
}
exports.ObservableContextKeyService = ObservableContextKeyService;
//# sourceMappingURL=utils.js.map