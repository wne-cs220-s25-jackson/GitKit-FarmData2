"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineCompletionsAccessibleView = void 0;
const event_js_1 = require("../../../../base/common/event.js");
const codeEditorService_js_1 = require("../../../browser/services/codeEditorService.js");
const inlineCompletionContextKeys_js_1 = require("./controller/inlineCompletionContextKeys.js");
const inlineCompletionsController_js_1 = require("./controller/inlineCompletionsController.js");
const contextkey_js_1 = require("../../../../platform/contextkey/common/contextkey.js");
const lifecycle_js_1 = require("../../../../base/common/lifecycle.js");
class InlineCompletionsAccessibleView {
    constructor() {
        this.type = "view" /* AccessibleViewType.View */;
        this.priority = 95;
        this.name = 'inline-completions';
        this.when = contextkey_js_1.ContextKeyExpr.and(inlineCompletionContextKeys_js_1.InlineCompletionContextKeys.inlineSuggestionVisible);
    }
    getProvider(accessor) {
        const codeEditorService = accessor.get(codeEditorService_js_1.ICodeEditorService);
        const editor = codeEditorService.getActiveCodeEditor() || codeEditorService.getFocusedCodeEditor();
        if (!editor) {
            return;
        }
        const model = inlineCompletionsController_js_1.InlineCompletionsController.get(editor)?.model.get();
        if (!model?.inlineCompletionState.get()) {
            return;
        }
        return new InlineCompletionsAccessibleViewContentProvider(editor, model);
    }
}
exports.InlineCompletionsAccessibleView = InlineCompletionsAccessibleView;
class InlineCompletionsAccessibleViewContentProvider extends lifecycle_js_1.Disposable {
    constructor(_editor, _model) {
        super();
        this._editor = _editor;
        this._model = _model;
        this._onDidChangeContent = this._register(new event_js_1.Emitter());
        this.onDidChangeContent = this._onDidChangeContent.event;
        this.id = "inlineCompletions" /* AccessibleViewProviderId.InlineCompletions */;
        this.verbositySettingKey = 'accessibility.verbosity.inlineCompletions';
        this.options = { language: this._editor.getModel()?.getLanguageId() ?? undefined, type: "view" /* AccessibleViewType.View */ };
    }
    provideContent() {
        const state = this._model.inlineCompletionState.get();
        if (!state) {
            throw new Error('Inline completion is visible but state is not available');
        }
        const lineText = this._model.textModel.getLineContent(state.primaryGhostText.lineNumber);
        const ghostText = state.primaryGhostText.renderForScreenReader(lineText);
        if (!ghostText) {
            throw new Error('Inline completion is visible but ghost text is not available');
        }
        return lineText + ghostText;
    }
    provideNextContent() {
        // asynchronously update the model and fire the event
        this._model.next().then((() => this._onDidChangeContent.fire()));
        return;
    }
    providePreviousContent() {
        // asynchronously update the model and fire the event
        this._model.previous().then((() => this._onDidChangeContent.fire()));
        return;
    }
    onClose() {
        this._model.stop();
        this._editor.focus();
    }
}
//# sourceMappingURL=inlineCompletionsAccessibleView.js.map