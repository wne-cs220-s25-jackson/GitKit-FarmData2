"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var InlineSuggestionHintsContentWidget_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomizedMenuWorkbenchToolBar = exports.InlineSuggestionHintsContentWidget = exports.InlineCompletionsHintsWidget = void 0;
const dom_js_1 = require("../../../../../base/browser/dom.js");
const actionViewItems_js_1 = require("../../../../../base/browser/ui/actionbar/actionViewItems.js");
const keybindingLabel_js_1 = require("../../../../../base/browser/ui/keybindingLabel/keybindingLabel.js");
const actions_js_1 = require("../../../../../base/common/actions.js");
const arrays_js_1 = require("../../../../../base/common/arrays.js");
const async_js_1 = require("../../../../../base/common/async.js");
const codicons_js_1 = require("../../../../../base/common/codicons.js");
const lifecycle_js_1 = require("../../../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../../../base/common/observable.js");
const platform_js_1 = require("../../../../../base/common/platform.js");
const themables_js_1 = require("../../../../../base/common/themables.js");
const nls_js_1 = require("../../../../../nls.js");
const menuEntryActionViewItem_js_1 = require("../../../../../platform/actions/browser/menuEntryActionViewItem.js");
const toolbar_js_1 = require("../../../../../platform/actions/browser/toolbar.js");
const actions_js_2 = require("../../../../../platform/actions/common/actions.js");
const commands_js_1 = require("../../../../../platform/commands/common/commands.js");
const contextkey_js_1 = require("../../../../../platform/contextkey/common/contextkey.js");
const contextView_js_1 = require("../../../../../platform/contextview/browser/contextView.js");
const instantiation_js_1 = require("../../../../../platform/instantiation/common/instantiation.js");
const keybinding_js_1 = require("../../../../../platform/keybinding/common/keybinding.js");
const telemetry_js_1 = require("../../../../../platform/telemetry/common/telemetry.js");
const iconRegistry_js_1 = require("../../../../../platform/theme/common/iconRegistry.js");
const position_js_1 = require("../../../../common/core/position.js");
const languages_js_1 = require("../../../../common/languages.js");
const commandIds_js_1 = require("../controller/commandIds.js");
require("./inlineCompletionsHintsWidget.css");
let InlineCompletionsHintsWidget = class InlineCompletionsHintsWidget extends lifecycle_js_1.Disposable {
    constructor(editor, model, instantiationService) {
        super();
        this.editor = editor;
        this.model = model;
        this.instantiationService = instantiationService;
        this.alwaysShowToolbar = (0, observable_js_1.observableFromEvent)(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(64 /* EditorOption.inlineSuggest */).showToolbar === 'always');
        this.sessionPosition = undefined;
        this.position = (0, observable_js_1.derived)(this, reader => {
            const ghostText = this.model.read(reader)?.primaryGhostText.read(reader);
            if (!this.alwaysShowToolbar.read(reader) || !ghostText || ghostText.parts.length === 0) {
                this.sessionPosition = undefined;
                return null;
            }
            const firstColumn = ghostText.parts[0].column;
            if (this.sessionPosition && this.sessionPosition.lineNumber !== ghostText.lineNumber) {
                this.sessionPosition = undefined;
            }
            const position = new position_js_1.Position(ghostText.lineNumber, Math.min(firstColumn, this.sessionPosition?.column ?? Number.MAX_SAFE_INTEGER));
            this.sessionPosition = position;
            return position;
        });
        this._register((0, observable_js_1.autorunWithStore)((reader, store) => {
            /** @description setup content widget */
            const model = this.model.read(reader);
            if (!model || !this.alwaysShowToolbar.read(reader)) {
                return;
            }
            const contentWidgetValue = (0, observable_js_1.derivedWithStore)((reader, store) => {
                const contentWidget = store.add(this.instantiationService.createInstance(InlineSuggestionHintsContentWidget, this.editor, true, this.position, model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.activeCommands));
                editor.addContentWidget(contentWidget);
                store.add((0, lifecycle_js_1.toDisposable)(() => editor.removeContentWidget(contentWidget)));
                store.add((0, observable_js_1.autorun)(reader => {
                    /** @description request explicit */
                    const position = this.position.read(reader);
                    if (!position) {
                        return;
                    }
                    if (model.lastTriggerKind.read(reader) !== languages_js_1.InlineCompletionTriggerKind.Explicit) {
                        model.triggerExplicitly();
                    }
                }));
                return contentWidget;
            });
            const hadPosition = (0, observable_js_1.derivedObservableWithCache)(this, (reader, lastValue) => !!this.position.read(reader) || !!lastValue);
            store.add((0, observable_js_1.autorun)(reader => {
                if (hadPosition.read(reader)) {
                    contentWidgetValue.read(reader);
                }
            }));
        }));
    }
};
exports.InlineCompletionsHintsWidget = InlineCompletionsHintsWidget;
exports.InlineCompletionsHintsWidget = InlineCompletionsHintsWidget = __decorate([
    __param(2, instantiation_js_1.IInstantiationService)
], InlineCompletionsHintsWidget);
const inlineSuggestionHintsNextIcon = (0, iconRegistry_js_1.registerIcon)('inline-suggestion-hints-next', codicons_js_1.Codicon.chevronRight, (0, nls_js_1.localize)('parameterHintsNextIcon', 'Icon for show next parameter hint.'));
const inlineSuggestionHintsPreviousIcon = (0, iconRegistry_js_1.registerIcon)('inline-suggestion-hints-previous', codicons_js_1.Codicon.chevronLeft, (0, nls_js_1.localize)('parameterHintsPreviousIcon', 'Icon for show previous parameter hint.'));
let InlineSuggestionHintsContentWidget = class InlineSuggestionHintsContentWidget extends lifecycle_js_1.Disposable {
    static { InlineSuggestionHintsContentWidget_1 = this; }
    static { this._dropDownVisible = false; }
    static get dropDownVisible() { return this._dropDownVisible; }
    static { this.id = 0; }
    createCommandAction(commandId, label, iconClassName) {
        const action = new actions_js_1.Action(commandId, label, iconClassName, true, () => this._commandService.executeCommand(commandId));
        const kb = this.keybindingService.lookupKeybinding(commandId, this._contextKeyService);
        let tooltip = label;
        if (kb) {
            tooltip = (0, nls_js_1.localize)({ key: 'content', comment: ['A label', 'A keybinding'] }, '{0} ({1})', label, kb.getLabel());
        }
        action.tooltip = tooltip;
        return action;
    }
    constructor(editor, withBorder, _position, _currentSuggestionIdx, _suggestionCount, _extraCommands, _commandService, instantiationService, keybindingService, _contextKeyService, _menuService) {
        super();
        this.editor = editor;
        this.withBorder = withBorder;
        this._position = _position;
        this._currentSuggestionIdx = _currentSuggestionIdx;
        this._suggestionCount = _suggestionCount;
        this._extraCommands = _extraCommands;
        this._commandService = _commandService;
        this.keybindingService = keybindingService;
        this._contextKeyService = _contextKeyService;
        this._menuService = _menuService;
        this.id = `InlineSuggestionHintsContentWidget${InlineSuggestionHintsContentWidget_1.id++}`;
        this.allowEditorOverflow = true;
        this.suppressMouseDown = false;
        this.nodes = (0, dom_js_1.h)('div.inlineSuggestionsHints', { className: this.withBorder ? '.withBorder' : '' }, [
            (0, dom_js_1.h)('div@toolBar'),
        ]);
        this.previousAction = this.createCommandAction(commandIds_js_1.showPreviousInlineSuggestionActionId, (0, nls_js_1.localize)('previous', 'Previous'), themables_js_1.ThemeIcon.asClassName(inlineSuggestionHintsPreviousIcon));
        this.availableSuggestionCountAction = new actions_js_1.Action('inlineSuggestionHints.availableSuggestionCount', '', undefined, false);
        this.nextAction = this.createCommandAction(commandIds_js_1.showNextInlineSuggestionActionId, (0, nls_js_1.localize)('next', 'Next'), themables_js_1.ThemeIcon.asClassName(inlineSuggestionHintsNextIcon));
        // TODO@hediet: deprecate MenuId.InlineCompletionsActions
        this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(actions_js_2.MenuId.InlineCompletionsActions, this._contextKeyService));
        this.clearAvailableSuggestionCountLabelDebounced = this._register(new async_js_1.RunOnceScheduler(() => {
            this.availableSuggestionCountAction.label = '';
        }, 100));
        this.disableButtonsDebounced = this._register(new async_js_1.RunOnceScheduler(() => {
            this.previousAction.enabled = this.nextAction.enabled = false;
        }, 100));
        this.toolBar = this._register(instantiationService.createInstance(CustomizedMenuWorkbenchToolBar, this.nodes.toolBar, actions_js_2.MenuId.InlineSuggestionToolbar, {
            menuOptions: { renderShortTitle: true },
            toolbarOptions: { primaryGroup: g => g.startsWith('primary') },
            actionViewItemProvider: (action, options) => {
                if (action instanceof actions_js_2.MenuItemAction) {
                    return instantiationService.createInstance(StatusBarViewItem, action, undefined);
                }
                if (action === this.availableSuggestionCountAction) {
                    const a = new ActionViewItemWithClassName(undefined, action, { label: true, icon: false });
                    a.setClass('availableSuggestionCount');
                    return a;
                }
                return undefined;
            },
            telemetrySource: 'InlineSuggestionToolbar',
        }));
        this.toolBar.setPrependedPrimaryActions([
            this.previousAction,
            this.availableSuggestionCountAction,
            this.nextAction,
        ]);
        this._register(this.toolBar.onDidChangeDropdownVisibility(e => {
            InlineSuggestionHintsContentWidget_1._dropDownVisible = e;
        }));
        this._register((0, observable_js_1.autorun)(reader => {
            /** @description update position */
            this._position.read(reader);
            this.editor.layoutContentWidget(this);
        }));
        this._register((0, observable_js_1.autorun)(reader => {
            /** @description counts */
            const suggestionCount = this._suggestionCount.read(reader);
            const currentSuggestionIdx = this._currentSuggestionIdx.read(reader);
            if (suggestionCount !== undefined) {
                this.clearAvailableSuggestionCountLabelDebounced.cancel();
                this.availableSuggestionCountAction.label = `${currentSuggestionIdx + 1}/${suggestionCount}`;
            }
            else {
                this.clearAvailableSuggestionCountLabelDebounced.schedule();
            }
            if (suggestionCount !== undefined && suggestionCount > 1) {
                this.disableButtonsDebounced.cancel();
                this.previousAction.enabled = this.nextAction.enabled = true;
            }
            else {
                this.disableButtonsDebounced.schedule();
            }
        }));
        this._register((0, observable_js_1.autorun)(reader => {
            /** @description extra commands */
            const extraCommands = this._extraCommands.read(reader);
            const extraActions = extraCommands.map(c => ({
                class: undefined,
                id: c.id,
                enabled: true,
                tooltip: c.tooltip || '',
                label: c.title,
                run: (event) => {
                    return this._commandService.executeCommand(c.id);
                },
            }));
            for (const [_, group] of this.inlineCompletionsActionsMenus.getActions()) {
                for (const action of group) {
                    if (action instanceof actions_js_2.MenuItemAction) {
                        extraActions.push(action);
                    }
                }
            }
            if (extraActions.length > 0) {
                extraActions.unshift(new actions_js_1.Separator());
            }
            this.toolBar.setAdditionalSecondaryActions(extraActions);
        }));
    }
    getId() { return this.id; }
    getDomNode() {
        return this.nodes.root;
    }
    getPosition() {
        return {
            position: this._position.get(),
            preference: [1 /* ContentWidgetPositionPreference.ABOVE */, 2 /* ContentWidgetPositionPreference.BELOW */],
            positionAffinity: 3 /* PositionAffinity.LeftOfInjectedText */,
        };
    }
};
exports.InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget;
exports.InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget_1 = __decorate([
    __param(6, commands_js_1.ICommandService),
    __param(7, instantiation_js_1.IInstantiationService),
    __param(8, keybinding_js_1.IKeybindingService),
    __param(9, contextkey_js_1.IContextKeyService),
    __param(10, actions_js_2.IMenuService)
], InlineSuggestionHintsContentWidget);
class ActionViewItemWithClassName extends actionViewItems_js_1.ActionViewItem {
    constructor() {
        super(...arguments);
        this._className = undefined;
    }
    setClass(className) {
        this._className = className;
    }
    render(container) {
        super.render(container);
        if (this._className) {
            container.classList.add(this._className);
        }
    }
    updateTooltip() {
        // NOOP, disable tooltip
    }
}
class StatusBarViewItem extends menuEntryActionViewItem_js_1.MenuEntryActionViewItem {
    updateLabel() {
        const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService, true);
        if (!kb) {
            return super.updateLabel();
        }
        if (this.label) {
            const div = (0, dom_js_1.h)('div.keybinding').root;
            const k = this._register(new keybindingLabel_js_1.KeybindingLabel(div, platform_js_1.OS, { disableTitle: true, ...keybindingLabel_js_1.unthemedKeybindingLabelOptions }));
            k.set(kb);
            this.label.textContent = this._action.label;
            this.label.appendChild(div);
            this.label.classList.add('inlineSuggestionStatusBarItemLabel');
        }
    }
    updateTooltip() {
        // NOOP, disable tooltip
    }
}
let CustomizedMenuWorkbenchToolBar = class CustomizedMenuWorkbenchToolBar extends toolbar_js_1.WorkbenchToolBar {
    constructor(container, menuId, options2, menuService, contextKeyService, contextMenuService, keybindingService, commandService, telemetryService) {
        super(container, { resetMenu: menuId, ...options2 }, menuService, contextKeyService, contextMenuService, keybindingService, commandService, telemetryService);
        this.menuId = menuId;
        this.options2 = options2;
        this.menuService = menuService;
        this.contextKeyService = contextKeyService;
        this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: true }));
        this.additionalActions = [];
        this.prependedPrimaryActions = [];
        this.additionalPrimaryActions = [];
        this._store.add(this.menu.onDidChange(() => this.updateToolbar()));
        this.updateToolbar();
    }
    updateToolbar() {
        const { primary, secondary } = (0, menuEntryActionViewItem_js_1.getActionBarActions)(this.menu.getActions(this.options2?.menuOptions), this.options2?.toolbarOptions?.primaryGroup, this.options2?.toolbarOptions?.shouldInlineSubmenu, this.options2?.toolbarOptions?.useSeparatorsInPrimaryActions);
        secondary.push(...this.additionalActions);
        primary.unshift(...this.prependedPrimaryActions);
        primary.push(...this.additionalPrimaryActions);
        this.setActions(primary, secondary);
    }
    setPrependedPrimaryActions(actions) {
        if ((0, arrays_js_1.equals)(this.prependedPrimaryActions, actions, (a, b) => a === b)) {
            return;
        }
        this.prependedPrimaryActions = actions;
        this.updateToolbar();
    }
    setAdditionalPrimaryActions(actions) {
        if ((0, arrays_js_1.equals)(this.additionalPrimaryActions, actions, (a, b) => a === b)) {
            return;
        }
        this.additionalPrimaryActions = actions;
        this.updateToolbar();
    }
    setAdditionalSecondaryActions(actions) {
        if ((0, arrays_js_1.equals)(this.additionalActions, actions, (a, b) => a === b)) {
            return;
        }
        this.additionalActions = actions;
        this.updateToolbar();
    }
};
exports.CustomizedMenuWorkbenchToolBar = CustomizedMenuWorkbenchToolBar;
exports.CustomizedMenuWorkbenchToolBar = CustomizedMenuWorkbenchToolBar = __decorate([
    __param(3, actions_js_2.IMenuService),
    __param(4, contextkey_js_1.IContextKeyService),
    __param(5, contextView_js_1.IContextMenuService),
    __param(6, keybinding_js_1.IKeybindingService),
    __param(7, commands_js_1.ICommandService),
    __param(8, telemetry_js_1.ITelemetryService)
], CustomizedMenuWorkbenchToolBar);
//# sourceMappingURL=inlineCompletionsHintsWidget.js.map