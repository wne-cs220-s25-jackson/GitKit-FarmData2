"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineEditsView = exports.border = exports.modifiedChangedTextOverlayColor = exports.modifiedChangedLineBackgroundColor = exports.originalChangedTextOverlayColor = exports.originalChangedLineBackgroundColor = exports.modifiedBackgroundColor = exports.originalBackgroundColor = void 0;
const dom_js_1 = require("../../../../../../base/browser/dom.js");
const lifecycle_js_1 = require("../../../../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../../../../base/common/observable.js");
const actions_js_1 = require("../../../../../../platform/actions/common/actions.js");
const instantiation_js_1 = require("../../../../../../platform/instantiation/common/instantiation.js");
const observableCodeEditor_js_1 = require("../../../../../browser/observableCodeEditor.js");
const embeddedCodeEditorWidget_js_1 = require("../../../../../browser/widget/codeEditor/embeddedCodeEditorWidget.js");
const utils_js_1 = require("../../../../../browser/widget/diffEditor/utils.js");
const lineRange_js_1 = require("../../../../../common/core/lineRange.js");
const range_js_1 = require("../../../../../common/core/range.js");
const textEdit_js_1 = require("../../../../../common/core/textEdit.js");
const rangeMapping_js_1 = require("../../../../../common/diff/rangeMapping.js");
const textModel_js_1 = require("../../../../../common/model/textModel.js");
require("./inlineEditsView.css");
const inlineDiffView_js_1 = require("./inlineDiffView.js");
const utils_js_2 = require("./utils.js");
const inlineEditsIndicatorView_js_1 = require("./inlineEditsIndicatorView.js");
const colorUtils_js_1 = require("../../../../../../platform/theme/common/colorUtils.js");
const colorRegistry_js_1 = require("../../../../../../platform/theme/common/colorRegistry.js");
const inlineCompletionsHintsWidget_js_1 = require("../../hintsWidget/inlineCompletionsHintsWidget.js");
const commands_js_1 = require("../../../../../../platform/commands/common/commands.js");
const equals_js_1 = require("../../../../../../base/common/equals.js");
const editorColorRegistry_js_1 = require("../../../../../common/core/editorColorRegistry.js");
const actionViewItems_js_1 = require("../../../../../../base/browser/ui/actionbar/actionViewItems.js");
const offsetRange_js_1 = require("../../../../../common/core/offsetRange.js");
const color_js_1 = require("../../../../../../base/common/color.js");
exports.originalBackgroundColor = (0, colorUtils_js_1.registerColor)('inlineEdit.originalBackground', (0, colorUtils_js_1.transparent)(colorRegistry_js_1.diffRemoved, 0.4), '', true);
exports.modifiedBackgroundColor = (0, colorUtils_js_1.registerColor)('inlineEdit.modifiedBackground', (0, colorUtils_js_1.transparent)(colorRegistry_js_1.diffInserted, 0.4), '', true);
exports.originalChangedLineBackgroundColor = (0, colorUtils_js_1.registerColor)('inlineEdit.originalChangedLineBackground', color_js_1.Color.transparent, '', true);
exports.originalChangedTextOverlayColor = (0, colorUtils_js_1.registerColor)('inlineEdit.originalChangedTextBackground', colorRegistry_js_1.diffRemoved, '', true);
exports.modifiedChangedLineBackgroundColor = (0, colorUtils_js_1.registerColor)('inlineEdit.modifiedChangedLineBackground', color_js_1.Color.transparent, '', true);
exports.modifiedChangedTextOverlayColor = (0, colorUtils_js_1.registerColor)('inlineEdit.modifiedChangedTextBackground', colorRegistry_js_1.diffInserted, '', true);
exports.border = (0, colorUtils_js_1.registerColor)('inlineEdit.border', {
    light: (0, colorUtils_js_1.darken)(editorColorRegistry_js_1.editorLineHighlightBorder, 0.15),
    dark: (0, colorUtils_js_1.lighten)(editorColorRegistry_js_1.editorLineHighlightBorder, 0.50),
    hcDark: editorColorRegistry_js_1.editorLineHighlightBorder,
    hcLight: editorColorRegistry_js_1.editorLineHighlightBorder
}, '');
let InlineEditsView = class InlineEditsView extends lifecycle_js_1.Disposable {
    constructor(_editor, _edit, _model, _instantiationService, _commandService) {
        super();
        this._editor = _editor;
        this._edit = _edit;
        this._model = _model;
        this._instantiationService = _instantiationService;
        this._commandService = _commandService;
        this._editorObs = (0, observableCodeEditor_js_1.observableCodeEditor)(this._editor);
        this._elements = (0, dom_js_1.h)('div.inline-edits-view', {
            style: {
                position: 'absolute',
                overflow: 'visible',
                top: '0px',
                left: '0px',
            },
        }, [
            (0, dom_js_1.svgElem)('svg@svg', { transform: 'translate(-0.5 -0.5)', style: { overflow: 'visible', pointerEvents: 'none', position: 'absolute' }, }, []),
            (0, dom_js_1.h)('div.editorContainer@editorContainer', { style: { position: 'absolute' } }, [
                (0, dom_js_1.h)('div.preview@editor', { style: {} }),
                (0, dom_js_1.h)('div.toolbar@toolbar', { style: {} }),
            ]),
            (0, dom_js_1.svgElem)('svg@svg2', { transform: 'translate(-0.5 -0.5)', style: { overflow: 'visible', pointerEvents: 'none', position: 'absolute' }, }, []),
        ]);
        this._useMixedLinesDiff = (0, observableCodeEditor_js_1.observableCodeEditor)(this._editor).getOption(64 /* EditorOption.inlineSuggest */).map(s => s.edits.experimental.useMixedLinesDiff);
        this._useInterleavedLinesDiff = (0, observableCodeEditor_js_1.observableCodeEditor)(this._editor).getOption(64 /* EditorOption.inlineSuggest */).map(s => s.edits.experimental.useInterleavedLinesDiff);
        this._uiState = (0, observable_js_1.derived)(this, reader => {
            const edit = this._edit.read(reader);
            if (!edit) {
                return undefined;
            }
            this._model.get()?.handleInlineCompletionShown(edit.inlineCompletion);
            let mappings = rangeMapping_js_1.RangeMapping.fromEdit(edit.edit);
            let newText = edit.edit.apply(edit.originalText);
            let diff = (0, rangeMapping_js_1.lineRangeMappingFromRangeMappings)(mappings, edit.originalText, new textEdit_js_1.StringText(newText));
            let state;
            if (edit.isCollapsed) {
                state = 'collapsed';
            }
            else if (diff.every(m => inlineDiffView_js_1.OriginalEditorInlineDiffView.supportsInlineDiffRendering(m)) &&
                (this._useMixedLinesDiff.read(reader) === 'whenPossible' || (edit.userJumpedToIt && this._useMixedLinesDiff.read(reader) === 'afterJumpWhenPossible'))) {
                state = 'mixedLines';
            }
            else if ((this._useInterleavedLinesDiff.read(reader) === 'always' || (edit.userJumpedToIt && this._useInterleavedLinesDiff.read(reader) === 'afterJump'))) {
                state = 'interleavedLines';
            }
            else {
                state = 'sideBySide';
            }
            if (state === 'sideBySide') {
                const indentationAdjustmentEdit = (0, utils_js_2.createReindentEdit)(newText, edit.modifiedLineRange);
                newText = indentationAdjustmentEdit.applyToString(newText);
                mappings = (0, utils_js_2.applyEditToModifiedRangeMappings)(mappings, indentationAdjustmentEdit);
                diff = (0, rangeMapping_js_1.lineRangeMappingFromRangeMappings)(mappings, edit.originalText, new textEdit_js_1.StringText(newText));
            }
            const originalDisplayRange = edit.originalText.lineRange.intersect(edit.originalLineRange.join(lineRange_js_1.LineRange.ofLength(edit.originalLineRange.startLineNumber, edit.lineEdit.newLines.length)));
            return {
                state,
                diff,
                edit,
                newText,
                newTextLineCount: edit.modifiedLineRange.length,
                originalDisplayRange: originalDisplayRange,
            };
        });
        this._toolbar = this._register(this._instantiationService.createInstance(inlineCompletionsHintsWidget_js_1.CustomizedMenuWorkbenchToolBar, this._elements.toolbar, actions_js_1.MenuId.InlineEditsActions, {
            menuOptions: { renderShortTitle: true },
            toolbarOptions: {
                primaryGroup: g => g.startsWith('primary'),
            },
            actionViewItemProvider: (action, options) => {
                if (action instanceof actions_js_1.MenuItemAction) {
                    return this._instantiationService.createInstance(utils_js_2.StatusBarViewItem, action, undefined);
                }
                if (action.class === undefined) {
                    return this._instantiationService.createInstance(actionViewItems_js_1.ActionViewItem, {}, action, { icon: false });
                }
                return undefined;
            },
            telemetrySource: 'inlineEditsToolbar'
        }));
        this._extraCommands = (0, observable_js_1.derivedOpts)({ owner: this, equalsFn: equals_js_1.structuralEquals }, reader => {
            return this._uiState.read(reader)?.edit.commands ?? [];
        });
        this._updateToolbarAutorun = this._register((0, observable_js_1.autorun)(reader => {
            /** @description extra commands */
            const extraCommands = this._extraCommands.read(reader);
            const primaryExtraActions = [];
            const secondaryExtraActions = [];
            for (const c of extraCommands) {
                const action = {
                    class: undefined,
                    id: c.id,
                    enabled: true,
                    tooltip: c.tooltip || '',
                    label: c.title,
                    run: (event) => {
                        return this._commandService.executeCommand(c.id, ...(c.arguments ?? []));
                    },
                };
                // TODO this is a hack just to make the feedback action more visible.
                if (c.title.toLowerCase().indexOf('feedback') !== -1) {
                    primaryExtraActions.push(action);
                }
                else {
                    secondaryExtraActions.push(action);
                }
            }
            this._toolbar.setAdditionalPrimaryActions(primaryExtraActions);
            this._toolbar.setAdditionalSecondaryActions(secondaryExtraActions);
        }));
        // #region preview editor
        this._previewTextModel = this._register(this._instantiationService.createInstance(textModel_js_1.TextModel, '', this._editor.getModel().getLanguageId(), { ...textModel_js_1.TextModel.DEFAULT_CREATION_OPTIONS, bracketPairColorizationOptions: { enabled: true, independentColorPoolPerBracketType: false } }, null));
        this._previewEditor = this._register(this._instantiationService.createInstance(embeddedCodeEditorWidget_js_1.EmbeddedCodeEditorWidget, this._elements.editor, {
            glyphMargin: false,
            lineNumbers: 'off',
            minimap: { enabled: false },
            guides: {
                indentation: false,
                bracketPairs: false,
                bracketPairsHorizontal: false,
                highlightActiveIndentation: false,
            },
            folding: false,
            selectOnLineNumbers: false,
            selectionHighlight: false,
            columnSelection: false,
            overviewRulerBorder: false,
            overviewRulerLanes: 0,
            lineDecorationsWidth: 0,
            lineNumbersMinChars: 0,
            bracketPairColorization: { enabled: true, independentColorPoolPerBracketType: false },
            scrollBeyondLastLine: false,
            scrollbar: {
                vertical: 'hidden',
                horizontal: 'hidden',
                handleMouseWheel: false,
            },
            readOnly: true,
            wordWrap: 'off',
        }, { contributions: [], }, this._editor));
        this._previewEditorObs = (0, observableCodeEditor_js_1.observableCodeEditor)(this._previewEditor);
        this._previewEditorRootVisibility = (0, observable_js_1.derived)(this, reader => this._uiState.read(reader)?.state === 'sideBySide' ? 'block' : 'none');
        this._updatePreviewEditorRootVisibility = (0, observable_js_1.derived)(reader => {
            this._elements.root.style.display = this._previewEditorRootVisibility.read(reader);
        });
        this._updatePreviewEditor = (0, observable_js_1.derived)(reader => {
            this._updatePreviewEditorRootVisibility.read(reader);
            const uiState = this._uiState.read(reader);
            if (!uiState) {
                return;
            }
            this._previewTextModel.setLanguage(this._editor.getModel().getLanguageId());
            this._previewTextModel.setValue(uiState.newText);
            const range = uiState.edit.originalLineRange;
            const hiddenAreas = [];
            if (range.startLineNumber > 1) {
                hiddenAreas.push(new range_js_1.Range(1, 1, range.startLineNumber - 1, 1));
            }
            if (range.startLineNumber + uiState.newTextLineCount < this._previewTextModel.getLineCount() + 1) {
                hiddenAreas.push(new range_js_1.Range(range.startLineNumber + uiState.newTextLineCount, 1, this._previewTextModel.getLineCount() + 1, 1));
            }
            this._previewEditor.setHiddenAreas(hiddenAreas, undefined, true);
        }).recomputeInitiallyAndOnChange(this._store);
        this._previewEditorWidth = (0, observable_js_1.derived)(this, reader => {
            const edit = this._edit.read(reader);
            if (!edit) {
                return 0;
            }
            this._updatePreviewEditor.read(reader);
            return (0, utils_js_2.maxContentWidthInRange)(this._previewEditorObs, edit.modifiedLineRange, reader) + 10;
        });
        this._cursorPosIfTouchesEdit = (0, observable_js_1.derived)(this, reader => {
            const cursorPos = this._editorObs.cursorPosition.read(reader);
            const edit = this._edit.read(reader);
            if (!edit || !cursorPos) {
                return undefined;
            }
            return edit.modifiedLineRange.contains(cursorPos.lineNumber) ? cursorPos : undefined;
        });
        /**
         * ![test](./layout.dio.svg)
        */
        this._previewEditorLayoutInfo = (0, observable_js_1.derived)(this, (reader) => {
            const inlineEdit = this._edit.read(reader);
            if (!inlineEdit) {
                return null;
            }
            const state = this._uiState.read(reader);
            if (!state) {
                return null;
            }
            const range = inlineEdit.originalLineRange;
            const horizontalScrollOffset = this._editorObs.scrollLeft.read(reader);
            const editorContentMaxWidthInRange = (0, utils_js_2.maxContentWidthInRange)(this._editorObs, state.originalDisplayRange, reader);
            const editorLayout = this._editorObs.layoutInfo.read(reader);
            const previewWidth = this._previewEditorWidth.read(reader);
            const editorContentAreaWidth = editorLayout.width - editorLayout.contentLeft - editorLayout.minimap.minimapWidth - editorLayout.verticalScrollbarWidth;
            const cursorPos = this._cursorPosIfTouchesEdit.read(reader);
            const maxPreviewEditorLeft = Math.max(editorContentAreaWidth * 0.65 + horizontalScrollOffset - 10, editorContentAreaWidth - previewWidth - 70 + horizontalScrollOffset - 10, cursorPos ? (0, utils_js_2.getOffsetForPos)(this._editorObs, cursorPos, reader) + 50 : 0);
            const previewEditorLeftInTextArea = Math.min(editorContentMaxWidthInRange + 20, maxPreviewEditorLeft);
            const previewEditorLeft = editorLayout.contentLeft + previewEditorLeftInTextArea;
            const maxContentWidth = editorContentMaxWidthInRange + 20 + previewWidth + 70;
            const dist = maxPreviewEditorLeft - previewEditorLeftInTextArea;
            const left = Math.max(editorLayout.contentLeft, previewEditorLeft - horizontalScrollOffset);
            const selectionTop = this._editor.getTopForLineNumber(range.startLineNumber) - this._editorObs.scrollTop.read(reader);
            const selectionBottom = this._editor.getTopForLineNumber(range.endLineNumberExclusive) - this._editorObs.scrollTop.read(reader);
            const codeLeft = editorLayout.contentLeft;
            const code1 = new utils_js_2.Point(left, selectionTop);
            const codeStart1 = new utils_js_2.Point(codeLeft, selectionTop);
            const code2 = new utils_js_2.Point(left, selectionBottom);
            const codeStart2 = new utils_js_2.Point(codeLeft, selectionBottom);
            const codeHeight = selectionBottom - selectionTop;
            const codeEditDistRange = inlineEdit.modifiedLineRange.length === inlineEdit.originalLineRange.length
                ? new offsetRange_js_1.OffsetRange(4, 61)
                : new offsetRange_js_1.OffsetRange(60, 61);
            const clipped = dist === 0;
            const codeEditDist = codeEditDistRange.clip(dist);
            const editHeight = this._editor.getOption(68 /* EditorOption.lineHeight */) * inlineEdit.modifiedLineRange.length;
            const edit1 = new utils_js_2.Point(left + codeEditDist, selectionTop);
            const edit2 = new utils_js_2.Point(left + codeEditDist, selectionTop + editHeight);
            return {
                code1,
                codeStart1,
                code2,
                codeStart2,
                codeHeight,
                edit1,
                edit2,
                editHeight,
                previewEditorLeft,
                maxContentWidth,
                shouldShowShadow: clipped,
            };
        });
        // #endregion
        this._inlineDiffViewState = (0, observable_js_1.derived)(this, reader => {
            const e = this._uiState.read(reader);
            if (!e) {
                return undefined;
            }
            return {
                modifiedText: new textEdit_js_1.StringText(e.newText),
                diff: e.diff,
                mode: e.state === 'collapsed' ? 'sideBySide' : e.state,
                modifiedCodeEditor: this._previewEditor,
            };
        });
        this._inlineDiffView = this._register(new inlineDiffView_js_1.OriginalEditorInlineDiffView(this._editor, this._inlineDiffViewState, this._previewTextModel));
        this._indicator = this._register(new inlineEditsIndicatorView_js_1.InlineEditsIndicator(this._editorObs, (0, observable_js_1.derived)(reader => {
            const state = this._uiState.read(reader);
            const edit1 = this._previewEditorLayoutInfo.read(reader)?.edit1;
            if (!edit1 || !state) {
                return undefined;
            }
            return { editTopLeft: edit1, showAlways: state.state !== 'sideBySide' };
        }), this._model));
        this._register((0, utils_js_1.appendRemoveOnDispose)(this._editor.getDomNode(), this._elements.root));
        this._register(this._editorObs.createOverlayWidget({
            domNode: this._elements.root,
            position: (0, observable_js_1.constObservable)(null),
            allowEditorOverflow: false,
            minContentWidthInPx: (0, observable_js_1.derived)(reader => {
                const x = this._previewEditorLayoutInfo.read(reader)?.maxContentWidth;
                if (x === undefined) {
                    return 0;
                }
                return x;
            }),
        }));
        this._previewEditor.setModel(this._previewTextModel);
        this._register((0, observable_js_1.autorun)(reader => {
            const layoutInfo = this._previewEditorLayoutInfo.read(reader);
            if (!layoutInfo) {
                this._elements.svg.replaceChildren();
                return;
            }
            const topEdit = layoutInfo.edit1;
            const editHeight = layoutInfo.editHeight;
            const width = this._previewEditorWidth.read(reader);
            const pathBuilder1 = new utils_js_2.PathBuilder();
            pathBuilder1.moveTo(layoutInfo.code2);
            pathBuilder1.lineTo(layoutInfo.codeStart2);
            pathBuilder1.lineTo(layoutInfo.codeStart1);
            pathBuilder1.lineTo(layoutInfo.code1);
            const pathBuilder2 = new utils_js_2.PathBuilder();
            pathBuilder2.moveTo(layoutInfo.code1);
            pathBuilder2.lineTo(layoutInfo.edit1);
            pathBuilder2.lineTo(layoutInfo.edit1.deltaX(width));
            pathBuilder2.lineTo(layoutInfo.edit2.deltaX(width));
            pathBuilder2.lineTo(layoutInfo.edit2);
            if (layoutInfo.edit2.y !== layoutInfo.code2.y) {
                pathBuilder2.curveTo2(layoutInfo.edit2.deltaX(-20), layoutInfo.code2.deltaX(20), layoutInfo.code2.deltaX(0));
            }
            pathBuilder2.lineTo(layoutInfo.code2);
            const pathBuilder4 = new utils_js_2.PathBuilder();
            pathBuilder4.moveTo(layoutInfo.code1);
            pathBuilder4.lineTo(layoutInfo.code1.deltaX(1000));
            pathBuilder4.lineTo(layoutInfo.code2.deltaX(1000));
            pathBuilder4.lineTo(layoutInfo.code2);
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttribute('d', pathBuilder1.build());
            path1.style.fill = 'var(--vscode-inlineEdit-originalBackground, transparent)';
            path1.style.stroke = 'var(--vscode-inlineEdit-border)';
            path1.style.strokeWidth = '1px';
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttribute('d', pathBuilder2.build());
            path2.style.fill = 'var(--vscode-inlineEdit-modifiedBackground, transparent)';
            path2.style.stroke = 'var(--vscode-inlineEdit-border)';
            path2.style.strokeWidth = '1px';
            const pathModifiedBackground = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathModifiedBackground.setAttribute('d', pathBuilder2.build());
            pathModifiedBackground.style.fill = 'var(--vscode-editor-background, transparent)';
            pathModifiedBackground.style.strokeWidth = '1px';
            const elements = [];
            if (layoutInfo.shouldShowShadow) {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const linearGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                linearGradient.setAttribute('id', 'gradient');
                linearGradient.setAttribute('x1', '0%');
                linearGradient.setAttribute('x2', '100%');
                const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop1.setAttribute('offset', '0%');
                stop1.setAttribute('style', 'stop-color:var(--vscode-inlineEdit-border);stop-opacity:0');
                const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop2.setAttribute('offset', '100%');
                stop2.setAttribute('style', 'stop-color:var(--vscode-inlineEdit-border);stop-opacity:1');
                linearGradient.appendChild(stop1);
                linearGradient.appendChild(stop2);
                defs.appendChild(linearGradient);
                const width = 6;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', `${layoutInfo.code1.x - width}`);
                rect.setAttribute('y', `${layoutInfo.code1.y}`);
                rect.setAttribute('width', `${width}`);
                rect.setAttribute('height', `${layoutInfo.code2.y - layoutInfo.code1.y}`);
                rect.setAttribute('fill', 'url(#gradient)');
                rect.style.strokeWidth = '0';
                rect.style.stroke = 'transparent';
                elements.push(defs);
                elements.push(rect);
            }
            else {
                const pathBuilder3 = new utils_js_2.PathBuilder();
                pathBuilder3.moveTo(layoutInfo.code1);
                pathBuilder3.lineTo(layoutInfo.code2);
                const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path3.setAttribute('d', pathBuilder3.build());
                path3.style.stroke = 'var(--vscode-inlineEdit-border)';
                path3.style.strokeWidth = '1px';
                elements.push(path3);
            }
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttribute('d', pathBuilder4.build());
            path4.style.fill = 'var(--vscode-editor-background, transparent)';
            this._elements.svg.replaceChildren(path4, pathModifiedBackground);
            this._elements.svg2.replaceChildren(path1, path2, ...elements);
            this._elements.editorContainer.style.top = `${topEdit.y}px`;
            this._elements.editorContainer.style.left = `${topEdit.x}px`;
            this._previewEditor.layout({ height: editHeight, width });
        }));
        const toolbarDropdownVisible = (0, observable_js_1.observableFromEvent)(this, this._toolbar.onDidChangeDropdownVisibility, (e) => e ?? false);
        this._register((0, observable_js_1.autorun)(reader => {
            this._elements.root.classList.toggle('toolbarDropdownVisible', toolbarDropdownVisible.read(reader));
        }));
    }
};
exports.InlineEditsView = InlineEditsView;
exports.InlineEditsView = InlineEditsView = __decorate([
    __param(3, instantiation_js_1.IInstantiationService),
    __param(4, commands_js_1.ICommandService)
], InlineEditsView);
//# sourceMappingURL=inlineEditsView.js.map