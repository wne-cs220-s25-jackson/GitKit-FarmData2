"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathBuilder = exports.UniqueUriGenerator = exports.Point = exports.StatusBarViewItem = void 0;
exports.maxContentWidthInRange = maxContentWidthInRange;
exports.getOffsetForPos = getOffsetForPos;
exports.applyEditToModifiedRangeMappings = applyEditToModifiedRangeMappings;
exports.classNames = classNames;
exports.createReindentEdit = createReindentEdit;
const dom_js_1 = require("../../../../../../base/browser/dom.js");
const keybindingLabel_js_1 = require("../../../../../../base/browser/ui/keybindingLabel/keybindingLabel.js");
const arrays_js_1 = require("../../../../../../base/common/arrays.js");
const arraysFind_js_1 = require("../../../../../../base/common/arraysFind.js");
const platform_js_1 = require("../../../../../../base/common/platform.js");
const strings_js_1 = require("../../../../../../base/common/strings.js");
const uri_js_1 = require("../../../../../../base/common/uri.js");
const menuEntryActionViewItem_js_1 = require("../../../../../../platform/actions/browser/menuEntryActionViewItem.js");
const offsetRange_js_1 = require("../../../../../common/core/offsetRange.js");
const textEdit_js_1 = require("../../../../../common/core/textEdit.js");
const rangeMapping_js_1 = require("../../../../../common/diff/rangeMapping.js");
const range_js_1 = require("../../../../../common/core/range.js");
const position_js_1 = require("../../../../../common/core/position.js");
function maxContentWidthInRange(editor, range, reader) {
    editor.layoutInfo.read(reader);
    editor.value.read(reader);
    const model = editor.model.read(reader);
    if (!model) {
        return 0;
    }
    let maxContentWidth = 0;
    editor.scrollTop.read(reader);
    for (let i = range.startLineNumber; i < range.endLineNumberExclusive; i++) {
        const column = model.getLineMaxColumn(i);
        const lineContentWidth = editor.editor.getOffsetForColumn(i, column);
        maxContentWidth = Math.max(maxContentWidth, lineContentWidth);
    }
    const lines = range.mapToLineArray(l => model.getLineContent(l));
    if (maxContentWidth < 5 && lines.some(l => l.length > 0) && model.uri.scheme !== 'file') {
        console.error('unexpected width');
    }
    return maxContentWidth;
}
function getOffsetForPos(editor, pos, reader) {
    editor.layoutInfo.read(reader);
    editor.value.read(reader);
    const model = editor.model.read(reader);
    if (!model) {
        return 0;
    }
    editor.scrollTop.read(reader);
    const lineContentWidth = editor.editor.getOffsetForColumn(pos.lineNumber, pos.column);
    return lineContentWidth;
}
class StatusBarViewItem extends menuEntryActionViewItem_js_1.MenuEntryActionViewItem {
    constructor() {
        super(...arguments);
        this._updateLabelListener = this._register(this._contextKeyService.onDidChangeContext(() => {
            this.updateLabel();
        }));
    }
    updateLabel() {
        const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService, true);
        if (!kb) {
            return super.updateLabel();
        }
        if (this.label) {
            const div = (0, dom_js_1.h)('div.keybinding').root;
            const keybindingLabel = this._register(new keybindingLabel_js_1.KeybindingLabel(div, platform_js_1.OS, { disableTitle: true, ...keybindingLabel_js_1.unthemedKeybindingLabelOptions }));
            keybindingLabel.set(kb);
            this.label.textContent = this._action.label;
            this.label.appendChild(div);
            this.label.classList.add('inlineSuggestionStatusBarItemLabel');
        }
    }
    updateTooltip() {
        // NOOP, disable tooltip
    }
}
exports.StatusBarViewItem = StatusBarViewItem;
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    add(other) {
        return new Point(this.x + other.x, this.y + other.y);
    }
    deltaX(delta) {
        return new Point(this.x + delta, this.y);
    }
    deltaY(delta) {
        return new Point(this.x, this.y + delta);
    }
}
exports.Point = Point;
class UniqueUriGenerator {
    static { this._modelId = 0; }
    constructor(scheme) {
        this.scheme = scheme;
    }
    getUniqueUri() {
        return uri_js_1.URI.from({ scheme: this.scheme, path: new Date().toString() + String(UniqueUriGenerator._modelId++) });
    }
}
exports.UniqueUriGenerator = UniqueUriGenerator;
function applyEditToModifiedRangeMappings(rangeMapping, edit) {
    const updatedMappings = [];
    for (const m of rangeMapping) {
        const updatedRange = edit.mapRange(m.modifiedRange);
        updatedMappings.push(new rangeMapping_js_1.RangeMapping(m.originalRange, updatedRange));
    }
    return updatedMappings;
}
function classNames(...classes) {
    return classes.filter(c => typeof c === 'string').join(' ');
}
function offsetRangeToRange(columnOffsetRange, startPos) {
    return new range_js_1.Range(startPos.lineNumber, startPos.column + columnOffsetRange.start, startPos.lineNumber, startPos.column + columnOffsetRange.endExclusive);
}
function createReindentEdit(text, range) {
    const newLines = (0, strings_js_1.splitLines)(text);
    const edits = [];
    const minIndent = (0, arraysFind_js_1.findFirstMin)(range.mapToLineArray(l => (0, strings_js_1.getIndentationLength)(newLines[l - 1])), arrays_js_1.numberComparator);
    range.forEach(lineNumber => {
        edits.push(new textEdit_js_1.SingleTextEdit(offsetRangeToRange(new offsetRange_js_1.OffsetRange(0, minIndent), new position_js_1.Position(lineNumber, 1)), ''));
    });
    return new textEdit_js_1.TextEdit(edits);
}
class PathBuilder {
    constructor() {
        this._data = '';
    }
    moveTo(point) {
        this._data += `M ${point.x} ${point.y} `;
        return this;
    }
    lineTo(point) {
        this._data += `L ${point.x} ${point.y} `;
        return this;
    }
    curveTo(cp, to) {
        this._data += `Q ${cp.x} ${cp.y} ${to.x} ${to.y} `;
        return this;
    }
    curveTo2(cp1, cp2, to) {
        this._data += `C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${to.x} ${to.y} `;
        return this;
    }
    build() {
        return this._data;
    }
}
exports.PathBuilder = PathBuilder;
//# sourceMappingURL=utils.js.map