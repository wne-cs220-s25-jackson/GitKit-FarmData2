"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ttPolicy = exports.AdditionalLinesWidget = exports.GhostTextView = void 0;
const trustedTypes_js_1 = require("../../../../../../base/browser/trustedTypes.js");
const event_js_1 = require("../../../../../../base/common/event.js");
const lifecycle_js_1 = require("../../../../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../../../../base/common/observable.js");
const strings = require("../../../../../../base/common/strings.js");
const domFontInfo_js_1 = require("../../../../../browser/config/domFontInfo.js");
const observableCodeEditor_js_1 = require("../../../../../browser/observableCodeEditor.js");
const editorOptions_js_1 = require("../../../../../common/config/editorOptions.js");
const offsetEdit_js_1 = require("../../../../../common/core/offsetEdit.js");
const position_js_1 = require("../../../../../common/core/position.js");
const range_js_1 = require("../../../../../common/core/range.js");
const stringBuilder_js_1 = require("../../../../../common/core/stringBuilder.js");
const language_js_1 = require("../../../../../common/languages/language.js");
const model_js_1 = require("../../../../../common/model.js");
const tokenizationTextModelPart_js_1 = require("../../../../../common/tokenizationTextModelPart.js");
const lineTokens_js_1 = require("../../../../../common/tokens/lineTokens.js");
const lineDecorations_js_1 = require("../../../../../common/viewLayout/lineDecorations.js");
const viewLineRenderer_js_1 = require("../../../../../common/viewLayout/viewLineRenderer.js");
const ghostText_js_1 = require("../../model/ghostText.js");
const utils_js_1 = require("../../utils.js");
require("./ghostTextView.css");
let GhostTextView = class GhostTextView extends lifecycle_js_1.Disposable {
    constructor(_editor, _model, _languageService) {
        super();
        this._editor = _editor;
        this._model = _model;
        this._languageService = _languageService;
        this._isDisposed = (0, observable_js_1.observableValue)(this, false);
        this._editorObs = (0, observableCodeEditor_js_1.observableCodeEditor)(this._editor);
        this._useSyntaxHighlighting = this._editorObs.getOption(64 /* EditorOption.inlineSuggest */).map(v => v.syntaxHighlightingEnabled);
        this.uiState = (0, observable_js_1.derived)(this, reader => {
            if (this._isDisposed.read(reader)) {
                return undefined;
            }
            const textModel = this._editorObs.model.read(reader);
            if (textModel !== this._model.targetTextModel.read(reader)) {
                return undefined;
            }
            const ghostText = this._model.ghostText.read(reader);
            if (!ghostText) {
                return undefined;
            }
            const replacedRange = ghostText instanceof ghostText_js_1.GhostTextReplacement ? ghostText.columnRange : undefined;
            const syntaxHighlightingEnabled = this._useSyntaxHighlighting.read(reader);
            const extraClassName = syntaxHighlightingEnabled ? ' syntax-highlighted' : '';
            const { inlineTexts, additionalLines, hiddenRange } = computeGhostTextViewData(ghostText, textModel, 'ghost-text' + extraClassName);
            const edit = new offsetEdit_js_1.OffsetEdit(inlineTexts.map(t => offsetEdit_js_1.SingleOffsetEdit.insert(t.column - 1, t.text)));
            const tokens = syntaxHighlightingEnabled ? textModel.tokenization.tokenizeLineWithEdit(ghostText.lineNumber, new tokenizationTextModelPart_js_1.LineEditWithAdditionalLines(edit, additionalLines.map(l => l.content))) : undefined;
            const newRanges = edit.getNewTextRanges();
            const inlineTextsWithTokens = inlineTexts.map((t, idx) => ({ ...t, tokens: tokens?.mainLineTokens?.getTokensInRange(newRanges[idx]) }));
            const tokenizedAdditionalLines = additionalLines.map((l, idx) => ({
                content: tokens?.additionalLines?.[idx] ?? lineTokens_js_1.LineTokens.createEmpty(l.content, this._languageService.languageIdCodec),
                decorations: l.decorations,
            }));
            return {
                replacedRange,
                inlineTexts: inlineTextsWithTokens,
                additionalLines: tokenizedAdditionalLines,
                hiddenRange,
                lineNumber: ghostText.lineNumber,
                additionalReservedLineCount: this._model.minReservedLineCount.read(reader),
                targetTextModel: textModel,
                syntaxHighlightingEnabled,
            };
        });
        this.decorations = (0, observable_js_1.derived)(this, reader => {
            const uiState = this.uiState.read(reader);
            if (!uiState) {
                return [];
            }
            const decorations = [];
            const extraClassName = uiState.syntaxHighlightingEnabled ? ' syntax-highlighted' : '';
            if (uiState.replacedRange) {
                decorations.push({
                    range: uiState.replacedRange.toRange(uiState.lineNumber),
                    options: { inlineClassName: 'inline-completion-text-to-replace' + extraClassName, description: 'GhostTextReplacement' }
                });
            }
            if (uiState.hiddenRange) {
                decorations.push({
                    range: uiState.hiddenRange.toRange(uiState.lineNumber),
                    options: { inlineClassName: 'ghost-text-hidden', description: 'ghost-text-hidden', }
                });
            }
            for (const p of uiState.inlineTexts) {
                decorations.push({
                    range: range_js_1.Range.fromPositions(new position_js_1.Position(uiState.lineNumber, p.column)),
                    options: {
                        description: 'ghost-text-decoration',
                        after: {
                            content: p.text,
                            tokens: p.tokens,
                            inlineClassName: p.preview ? 'ghost-text-decoration-preview' : 'ghost-text-decoration' + extraClassName,
                            cursorStops: model_js_1.InjectedTextCursorStops.Left
                        },
                        showIfCollapsed: true,
                    }
                });
            }
            return decorations;
        });
        this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this._editor, (0, observable_js_1.derived)(reader => {
            /** @description lines */
            const uiState = this.uiState.read(reader);
            return uiState ? {
                lineNumber: uiState.lineNumber,
                additionalLines: uiState.additionalLines,
                minReservedLineCount: uiState.additionalReservedLineCount,
                targetTextModel: uiState.targetTextModel,
            } : undefined;
        })));
        this._register((0, lifecycle_js_1.toDisposable)(() => { this._isDisposed.set(true, undefined); }));
        this._register(this._editorObs.setDecorations(this.decorations));
    }
    ownsViewZone(viewZoneId) {
        return this.additionalLinesWidget.viewZoneId === viewZoneId;
    }
};
exports.GhostTextView = GhostTextView;
exports.GhostTextView = GhostTextView = __decorate([
    __param(2, language_js_1.ILanguageService)
], GhostTextView);
function computeGhostTextViewData(ghostText, textModel, ghostTextClassName) {
    const inlineTexts = [];
    const additionalLines = [];
    function addToAdditionalLines(lines, className) {
        if (additionalLines.length > 0) {
            const lastLine = additionalLines[additionalLines.length - 1];
            if (className) {
                lastLine.decorations.push(new lineDecorations_js_1.LineDecoration(lastLine.content.length + 1, lastLine.content.length + 1 + lines[0].length, className, 0 /* InlineDecorationType.Regular */));
            }
            lastLine.content += lines[0];
            lines = lines.slice(1);
        }
        for (const line of lines) {
            additionalLines.push({
                content: line,
                decorations: className ? [new lineDecorations_js_1.LineDecoration(1, line.length + 1, className, 0 /* InlineDecorationType.Regular */)] : []
            });
        }
    }
    const textBufferLine = textModel.getLineContent(ghostText.lineNumber);
    let hiddenTextStartColumn = undefined;
    let lastIdx = 0;
    for (const part of ghostText.parts) {
        let lines = part.lines;
        if (hiddenTextStartColumn === undefined) {
            inlineTexts.push({ column: part.column, text: lines[0], preview: part.preview });
            lines = lines.slice(1);
        }
        else {
            addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], undefined);
        }
        if (lines.length > 0) {
            addToAdditionalLines(lines, ghostTextClassName);
            if (hiddenTextStartColumn === undefined && part.column <= textBufferLine.length) {
                hiddenTextStartColumn = part.column;
            }
        }
        lastIdx = part.column - 1;
    }
    if (hiddenTextStartColumn !== undefined) {
        addToAdditionalLines([textBufferLine.substring(lastIdx)], undefined);
    }
    const hiddenRange = hiddenTextStartColumn !== undefined ? new utils_js_1.ColumnRange(hiddenTextStartColumn, textBufferLine.length + 1) : undefined;
    return {
        inlineTexts,
        additionalLines,
        hiddenRange,
    };
}
class AdditionalLinesWidget extends lifecycle_js_1.Disposable {
    get viewZoneId() { return this._viewZoneId; }
    constructor(editor, lines) {
        super();
        this.editor = editor;
        this.lines = lines;
        this._viewZoneId = undefined;
        this.editorOptionsChanged = (0, observable_js_1.observableSignalFromEvent)('editorOptionChanged', event_js_1.Event.filter(this.editor.onDidChangeConfiguration, e => e.hasChanged(33 /* EditorOption.disableMonospaceOptimizations */)
            || e.hasChanged(122 /* EditorOption.stopRenderingLineAfter */)
            || e.hasChanged(104 /* EditorOption.renderWhitespace */)
            || e.hasChanged(99 /* EditorOption.renderControlCharacters */)
            || e.hasChanged(53 /* EditorOption.fontLigatures */)
            || e.hasChanged(52 /* EditorOption.fontInfo */)
            || e.hasChanged(68 /* EditorOption.lineHeight */)));
        this._register((0, observable_js_1.autorun)(reader => {
            /** @description update view zone */
            const lines = this.lines.read(reader);
            this.editorOptionsChanged.read(reader);
            if (lines) {
                this.updateLines(lines.lineNumber, lines.additionalLines, lines.minReservedLineCount);
            }
            else {
                this.clear();
            }
        }));
    }
    dispose() {
        super.dispose();
        this.clear();
    }
    clear() {
        this.editor.changeViewZones((changeAccessor) => {
            if (this._viewZoneId) {
                changeAccessor.removeZone(this._viewZoneId);
                this._viewZoneId = undefined;
            }
        });
    }
    updateLines(lineNumber, additionalLines, minReservedLineCount) {
        const textModel = this.editor.getModel();
        if (!textModel) {
            return;
        }
        const { tabSize } = textModel.getOptions();
        this.editor.changeViewZones((changeAccessor) => {
            if (this._viewZoneId) {
                changeAccessor.removeZone(this._viewZoneId);
                this._viewZoneId = undefined;
            }
            const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
            if (heightInLines > 0) {
                const domNode = document.createElement('div');
                renderLines(domNode, tabSize, additionalLines, this.editor.getOptions());
                this._viewZoneId = changeAccessor.addZone({
                    afterLineNumber: lineNumber,
                    heightInLines: heightInLines,
                    domNode,
                    afterColumnAffinity: 1 /* PositionAffinity.Right */
                });
            }
        });
    }
}
exports.AdditionalLinesWidget = AdditionalLinesWidget;
function renderLines(domNode, tabSize, lines, opts) {
    const disableMonospaceOptimizations = opts.get(33 /* EditorOption.disableMonospaceOptimizations */);
    const stopRenderingLineAfter = opts.get(122 /* EditorOption.stopRenderingLineAfter */);
    // To avoid visual confusion, we don't want to render visible whitespace
    const renderWhitespace = 'none';
    const renderControlCharacters = opts.get(99 /* EditorOption.renderControlCharacters */);
    const fontLigatures = opts.get(53 /* EditorOption.fontLigatures */);
    const fontInfo = opts.get(52 /* EditorOption.fontInfo */);
    const lineHeight = opts.get(68 /* EditorOption.lineHeight */);
    const sb = new stringBuilder_js_1.StringBuilder(10000);
    sb.appendString('<div class="suggest-preview-text">');
    for (let i = 0, len = lines.length; i < len; i++) {
        const lineData = lines[i];
        const lineTokens = lineData.content;
        sb.appendString('<div class="view-line');
        sb.appendString('" style="top:');
        sb.appendString(String(i * lineHeight));
        sb.appendString('px;width:1000000px;">');
        const line = lineTokens.getLineContent();
        const isBasicASCII = strings.isBasicASCII(line);
        const containsRTL = strings.containsRTL(line);
        (0, viewLineRenderer_js_1.renderViewLine)(new viewLineRenderer_js_1.RenderLineInput((fontInfo.isMonospace && !disableMonospaceOptimizations), fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII, containsRTL, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== editorOptions_js_1.EditorFontLigatures.OFF, null), sb);
        sb.appendString('</div>');
    }
    sb.appendString('</div>');
    (0, domFontInfo_js_1.applyFontInfo)(domNode, fontInfo);
    const html = sb.build();
    const trustedhtml = exports.ttPolicy ? exports.ttPolicy.createHTML(html) : html;
    domNode.innerHTML = trustedhtml;
}
exports.ttPolicy = (0, trustedTypes_js_1.createTrustedTypesPolicy)('editorGhostText', { createHTML: value => value });
//# sourceMappingURL=ghostTextView.js.map