"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.OriginalEditorInlineDiffView = void 0;
const lifecycle_js_1 = require("../../../../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../../../../base/common/observable.js");
const observableCodeEditor_js_1 = require("../../../../../browser/observableCodeEditor.js");
const diffEditorViewZones_js_1 = require("../../../../../browser/widget/diffEditor/components/diffEditorViewZones/diffEditorViewZones.js");
const renderLines_js_1 = require("../../../../../browser/widget/diffEditor/components/diffEditorViewZones/renderLines.js");
const registrations_contribution_js_1 = require("../../../../../browser/widget/diffEditor/registrations.contribution.js");
const utils_js_1 = require("../../../../../browser/widget/diffEditor/utils.js");
const range_js_1 = require("../../../../../common/core/range.js");
const textModel_js_1 = require("../../../../../common/model/textModel.js");
const viewModel_js_1 = require("../../../../../common/viewModel.js");
const utils_js_2 = require("./utils.js");
class OriginalEditorInlineDiffView extends lifecycle_js_1.Disposable {
    static supportsInlineDiffRendering(mapping) {
        return allowsTrueInlineDiffRendering(mapping);
    }
    constructor(_originalEditor, _state, _modifiedTextModel) {
        super();
        this._originalEditor = _originalEditor;
        this._state = _state;
        this._modifiedTextModel = _modifiedTextModel;
        this._decorations = (0, observable_js_1.derived)(this, reader => {
            const diff = this._state.read(reader);
            if (!diff) {
                return undefined;
            }
            const modified = diff.modifiedText;
            const showInline = diff.mode === 'mixedLines';
            const showEmptyDecorations = true;
            const originalDecorations = [];
            const modifiedDecorations = [];
            const diffLineAddDecorationBackground = textModel_js_1.ModelDecorationOptions.register({
                className: 'inlineCompletions-line-insert',
                description: 'line-insert',
                isWholeLine: true,
                marginClassName: 'gutter-insert',
            });
            const diffLineDeleteDecorationBackground = textModel_js_1.ModelDecorationOptions.register({
                className: 'inlineCompletions-line-delete',
                description: 'line-delete',
                isWholeLine: true,
                marginClassName: 'gutter-delete',
            });
            const diffWholeLineDeleteDecoration = textModel_js_1.ModelDecorationOptions.register({
                className: 'inlineCompletions-char-delete',
                description: 'char-delete',
                isWholeLine: false,
            });
            const diffWholeLineAddDecoration = textModel_js_1.ModelDecorationOptions.register({
                className: 'inlineCompletions-char-insert',
                description: 'char-insert',
                isWholeLine: true,
            });
            const diffAddDecoration = textModel_js_1.ModelDecorationOptions.register({
                className: 'inlineCompletions-char-insert',
                description: 'char-insert',
                shouldFillLineOnLineBreak: true,
            });
            const diffAddDecorationEmpty = textModel_js_1.ModelDecorationOptions.register({
                className: 'inlineCompletions-char-insert diff-range-empty',
                description: 'char-insert diff-range-empty',
            });
            for (const m of diff.diff) {
                const showFullLineDecorations = true;
                if (showFullLineDecorations) {
                    if (!m.original.isEmpty) {
                        originalDecorations.push({
                            range: m.original.toInclusiveRange(),
                            options: diffLineDeleteDecorationBackground,
                        });
                    }
                    if (!m.modified.isEmpty) {
                        modifiedDecorations.push({
                            range: m.modified.toInclusiveRange(),
                            options: diffLineAddDecorationBackground,
                        });
                    }
                }
                if (m.modified.isEmpty || m.original.isEmpty) {
                    if (!m.original.isEmpty) {
                        originalDecorations.push({ range: m.original.toInclusiveRange(), options: diffWholeLineDeleteDecoration });
                    }
                    if (!m.modified.isEmpty) {
                        modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffWholeLineAddDecoration });
                    }
                }
                else {
                    const useInlineDiff = showInline && allowsTrueInlineDiffRendering(m);
                    for (const i of m.innerChanges || []) {
                        // Don't show empty markers outside the line range
                        if (m.original.contains(i.originalRange.startLineNumber)) {
                            originalDecorations.push({
                                range: i.originalRange,
                                options: {
                                    description: 'char-delete',
                                    shouldFillLineOnLineBreak: false,
                                    className: (0, utils_js_2.classNames)('inlineCompletions-char-delete', (i.originalRange.isEmpty() && showEmptyDecorations && !useInlineDiff) && 'diff-range-empty'),
                                    inlineClassName: useInlineDiff ? 'strike-through' : null,
                                    zIndex: 1
                                }
                            });
                        }
                        if (m.modified.contains(i.modifiedRange.startLineNumber)) {
                            modifiedDecorations.push({
                                range: i.modifiedRange,
                                options: (i.modifiedRange.isEmpty() && showEmptyDecorations && !useInlineDiff)
                                    ? diffAddDecorationEmpty
                                    : diffAddDecoration
                            });
                        }
                        if (useInlineDiff) {
                            const insertedText = modified.getValueOfRange(i.modifiedRange);
                            originalDecorations.push({
                                range: range_js_1.Range.fromPositions(i.originalRange.getEndPosition()),
                                options: {
                                    description: 'inserted-text',
                                    before: {
                                        content: insertedText,
                                        inlineClassName: 'inlineCompletions-char-insert',
                                    },
                                    zIndex: 2,
                                    showIfCollapsed: true,
                                }
                            });
                        }
                    }
                }
            }
            return { originalDecorations, modifiedDecorations };
        });
        this._register((0, observableCodeEditor_js_1.observableCodeEditor)(this._originalEditor).setDecorations(this._decorations.map(d => d?.originalDecorations ?? [])));
        const modifiedCodeEditor = this._state.map(s => s?.modifiedCodeEditor);
        this._register((0, observable_js_1.autorunWithStore)((reader, store) => {
            const e = modifiedCodeEditor.read(reader);
            if (e) {
                store.add((0, observableCodeEditor_js_1.observableCodeEditor)(e).setDecorations(this._decorations.map(d => d?.modifiedDecorations ?? [])));
            }
        }));
        const editor = (0, observableCodeEditor_js_1.observableCodeEditor)(this._originalEditor);
        const tokenizationFinished = modelTokenizationFinished(_modifiedTextModel);
        const originalViewZones = (0, observable_js_1.derived)(this, (reader) => {
            const originalModel = editor.model.read(reader);
            if (!originalModel) {
                return [];
            }
            const origViewZones = [];
            const renderOptions = renderLines_js_1.RenderOptions.fromEditor(this._originalEditor);
            const modLineHeight = editor.getOption(68 /* EditorOption.lineHeight */).read(reader);
            const s = this._state.read(reader);
            if (!s) {
                return origViewZones;
            }
            for (const diff of s.diff) {
                if (s.mode !== 'interleavedLines') {
                    continue;
                }
                tokenizationFinished.read(reader); // Update view-zones once tokenization completes
                const source = new renderLines_js_1.LineSource(diff.modified.mapToLineArray(l => this._modifiedTextModel.tokenization.getLineTokens(l)));
                const decorations = [];
                for (const i of diff.innerChanges || []) {
                    decorations.push(new viewModel_js_1.InlineDecoration(i.modifiedRange.delta(-(diff.original.startLineNumber - 1)), registrations_contribution_js_1.diffAddDecoration.className, 0 /* InlineDecorationType.Regular */));
                }
                const deletedCodeDomNode = document.createElement('div');
                deletedCodeDomNode.classList.add('view-lines', 'line-insert', 'monaco-mouse-cursor-text');
                // .inline-deleted-margin-view-zone
                const result = (0, renderLines_js_1.renderLines)(source, renderOptions, decorations, deletedCodeDomNode);
                origViewZones.push({
                    afterLineNumber: diff.original.endLineNumberExclusive - 1,
                    domNode: deletedCodeDomNode,
                    heightInPx: result.heightInLines * modLineHeight,
                    minWidthInPx: result.minWidthInPx,
                    showInHiddenAreas: true,
                    suppressMouseDown: true,
                });
            }
            return origViewZones;
        });
        this._register((0, utils_js_1.applyViewZones)(this._originalEditor, originalViewZones));
    }
}
exports.OriginalEditorInlineDiffView = OriginalEditorInlineDiffView;
function allowsTrueInlineDiffRendering(mapping) {
    if (!mapping.innerChanges) {
        return false;
    }
    return mapping.innerChanges.every(c => ((0, diffEditorViewZones_js_1.rangeIsSingleLine)(c.modifiedRange) && (0, diffEditorViewZones_js_1.rangeIsSingleLine)(c.originalRange)));
}
let i = 0;
function modelTokenizationFinished(model) {
    return (0, observable_js_1.observableFromEvent)(model.onDidChangeTokens, () => i++);
}
//# sourceMappingURL=inlineDiffView.js.map