"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineCompletionsHoverParticipant = exports.InlineCompletionsHover = void 0;
const dom = require("../../../../../base/browser/dom.js");
const htmlContent_js_1 = require("../../../../../base/common/htmlContent.js");
const lifecycle_js_1 = require("../../../../../base/common/lifecycle.js");
const observable_js_1 = require("../../../../../base/common/observable.js");
const range_js_1 = require("../../../../common/core/range.js");
const language_js_1 = require("../../../../common/languages/language.js");
const hoverTypes_js_1 = require("../../../hover/browser/hoverTypes.js");
const inlineCompletionsController_js_1 = require("../controller/inlineCompletionsController.js");
const inlineCompletionsHintsWidget_js_1 = require("./inlineCompletionsHintsWidget.js");
const markdownRenderer_js_1 = require("../../../../browser/widget/markdownRenderer/browser/markdownRenderer.js");
const nls = require("../../../../../nls.js");
const accessibility_js_1 = require("../../../../../platform/accessibility/common/accessibility.js");
const instantiation_js_1 = require("../../../../../platform/instantiation/common/instantiation.js");
const opener_js_1 = require("../../../../../platform/opener/common/opener.js");
const telemetry_js_1 = require("../../../../../platform/telemetry/common/telemetry.js");
class InlineCompletionsHover {
    constructor(owner, range, controller) {
        this.owner = owner;
        this.range = range;
        this.controller = controller;
    }
    isValidForHoverAnchor(anchor) {
        return (anchor.type === 1 /* HoverAnchorType.Range */
            && this.range.startColumn <= anchor.range.startColumn
            && this.range.endColumn >= anchor.range.endColumn);
    }
}
exports.InlineCompletionsHover = InlineCompletionsHover;
let InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant {
    constructor(_editor, _languageService, _openerService, accessibilityService, _instantiationService, _telemetryService) {
        this._editor = _editor;
        this._languageService = _languageService;
        this._openerService = _openerService;
        this.accessibilityService = accessibilityService;
        this._instantiationService = _instantiationService;
        this._telemetryService = _telemetryService;
        this.hoverOrdinal = 4;
    }
    suggestHoverAnchor(mouseEvent) {
        const controller = inlineCompletionsController_js_1.InlineCompletionsController.get(this._editor);
        if (!controller) {
            return null;
        }
        const target = mouseEvent.target;
        if (target.type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {
            // handle the case where the mouse is over the view zone
            const viewZoneData = target.detail;
            if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
                return new hoverTypes_js_1.HoverForeignElementAnchor(1000, this, range_js_1.Range.fromPositions(this._editor.getModel().validatePosition(viewZoneData.positionBefore || viewZoneData.position)), mouseEvent.event.posx, mouseEvent.event.posy, false);
            }
        }
        if (target.type === 7 /* MouseTargetType.CONTENT_EMPTY */) {
            // handle the case where the mouse is over the empty portion of a line following ghost text
            if (controller.shouldShowHoverAt(target.range)) {
                return new hoverTypes_js_1.HoverForeignElementAnchor(1000, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
            }
        }
        if (target.type === 6 /* MouseTargetType.CONTENT_TEXT */) {
            // handle the case where the mouse is directly over ghost text
            const mightBeForeignElement = target.detail.mightBeForeignElement;
            if (mightBeForeignElement && controller.shouldShowHoverAt(target.range)) {
                return new hoverTypes_js_1.HoverForeignElementAnchor(1000, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
            }
        }
        return null;
    }
    computeSync(anchor, lineDecorations) {
        if (this._editor.getOption(64 /* EditorOption.inlineSuggest */).showToolbar !== 'onHover') {
            return [];
        }
        const controller = inlineCompletionsController_js_1.InlineCompletionsController.get(this._editor);
        if (controller && controller.shouldShowHoverAt(anchor.range)) {
            return [new InlineCompletionsHover(this, anchor.range, controller)];
        }
        return [];
    }
    renderHoverParts(context, hoverParts) {
        const disposables = new lifecycle_js_1.DisposableStore();
        const part = hoverParts[0];
        this._telemetryService.publicLog2('inlineCompletionHover.shown');
        if (this.accessibilityService.isScreenReaderOptimized() && !this._editor.getOption(8 /* EditorOption.screenReaderAnnounceInlineSuggestion */)) {
            disposables.add(this.renderScreenReaderText(context, part));
        }
        const model = part.controller.model.get();
        const w = this._instantiationService.createInstance(inlineCompletionsHintsWidget_js_1.InlineSuggestionHintsContentWidget, this._editor, false, (0, observable_js_1.constObservable)(null), model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.activeCommands);
        const widgetNode = w.getDomNode();
        context.fragment.appendChild(widgetNode);
        model.triggerExplicitly();
        disposables.add(w);
        const renderedHoverPart = {
            hoverPart: part,
            hoverElement: widgetNode,
            dispose() { disposables.dispose(); }
        };
        return new hoverTypes_js_1.RenderedHoverParts([renderedHoverPart]);
    }
    getAccessibleContent(hoverPart) {
        return nls.localize('hoverAccessibilityStatusBar', 'There are inline completions here');
    }
    renderScreenReaderText(context, part) {
        const disposables = new lifecycle_js_1.DisposableStore();
        const $ = dom.$;
        const markdownHoverElement = $('div.hover-row.markdown-hover');
        const hoverContentsElement = dom.append(markdownHoverElement, $('div.hover-contents', { ['aria-live']: 'assertive' }));
        const renderer = disposables.add(new markdownRenderer_js_1.MarkdownRenderer({ editor: this._editor }, this._languageService, this._openerService));
        const render = (code) => {
            disposables.add(renderer.onDidRenderAsync(() => {
                hoverContentsElement.className = 'hover-contents code-hover-contents';
                context.onContentsChanged();
            }));
            const inlineSuggestionAvailable = nls.localize('inlineSuggestionFollows', "Suggestion:");
            const renderedContents = disposables.add(renderer.render(new htmlContent_js_1.MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock('text', code)));
            hoverContentsElement.replaceChildren(renderedContents.element);
        };
        disposables.add((0, observable_js_1.autorun)(reader => {
            /** @description update hover */
            const ghostText = part.controller.model.read(reader)?.primaryGhostText.read(reader);
            if (ghostText) {
                const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
                render(ghostText.renderForScreenReader(lineText));
            }
            else {
                dom.reset(hoverContentsElement);
            }
        }));
        context.fragment.appendChild(markdownHoverElement);
        return disposables;
    }
};
exports.InlineCompletionsHoverParticipant = InlineCompletionsHoverParticipant;
exports.InlineCompletionsHoverParticipant = InlineCompletionsHoverParticipant = __decorate([
    __param(1, language_js_1.ILanguageService),
    __param(2, opener_js_1.IOpenerService),
    __param(3, accessibility_js_1.IAccessibilityService),
    __param(4, instantiation_js_1.IInstantiationService),
    __param(5, telemetry_js_1.ITelemetryService)
], InlineCompletionsHoverParticipant);
//# sourceMappingURL=hoverParticipant.js.map