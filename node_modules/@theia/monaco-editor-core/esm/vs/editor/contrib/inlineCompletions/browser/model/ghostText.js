"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.GhostTextReplacement = exports.GhostTextPart = exports.GhostText = void 0;
exports.ghostTextsOrReplacementsEqual = ghostTextsOrReplacementsEqual;
exports.ghostTextOrReplacementEquals = ghostTextOrReplacementEquals;
const arrays_js_1 = require("../../../../../base/common/arrays.js");
const strings_js_1 = require("../../../../../base/common/strings.js");
const position_js_1 = require("../../../../common/core/position.js");
const range_js_1 = require("../../../../common/core/range.js");
const textEdit_js_1 = require("../../../../common/core/textEdit.js");
class GhostText {
    constructor(lineNumber, parts) {
        this.lineNumber = lineNumber;
        this.parts = parts;
    }
    equals(other) {
        return this.lineNumber === other.lineNumber &&
            this.parts.length === other.parts.length &&
            this.parts.every((part, index) => part.equals(other.parts[index]));
    }
    /**
     * Only used for testing/debugging.
    */
    render(documentText, debug = false) {
        return new textEdit_js_1.TextEdit([
            ...this.parts.map(p => new textEdit_js_1.SingleTextEdit(range_js_1.Range.fromPositions(new position_js_1.Position(this.lineNumber, p.column)), debug ? `[${p.lines.join('\n')}]` : p.lines.join('\n'))),
        ]).applyToString(documentText);
    }
    renderForScreenReader(lineText) {
        if (this.parts.length === 0) {
            return '';
        }
        const lastPart = this.parts[this.parts.length - 1];
        const cappedLineText = lineText.substr(0, lastPart.column - 1);
        const text = new textEdit_js_1.TextEdit([
            ...this.parts.map(p => new textEdit_js_1.SingleTextEdit(range_js_1.Range.fromPositions(new position_js_1.Position(1, p.column)), p.lines.join('\n'))),
        ]).applyToString(cappedLineText);
        return text.substring(this.parts[0].column - 1);
    }
    isEmpty() {
        return this.parts.every(p => p.lines.length === 0);
    }
    get lineCount() {
        return 1 + this.parts.reduce((r, p) => r + p.lines.length - 1, 0);
    }
}
exports.GhostText = GhostText;
class GhostTextPart {
    constructor(column, text, 
    /**
     * Indicates if this part is a preview of an inline suggestion when a suggestion is previewed.
    */
    preview) {
        this.column = column;
        this.text = text;
        this.preview = preview;
        this.lines = (0, strings_js_1.splitLines)(this.text);
    }
    equals(other) {
        return this.column === other.column &&
            this.lines.length === other.lines.length &&
            this.lines.every((line, index) => line === other.lines[index]);
    }
}
exports.GhostTextPart = GhostTextPart;
class GhostTextReplacement {
    constructor(lineNumber, columnRange, text, additionalReservedLineCount = 0) {
        this.lineNumber = lineNumber;
        this.columnRange = columnRange;
        this.text = text;
        this.additionalReservedLineCount = additionalReservedLineCount;
        this.parts = [
            new GhostTextPart(this.columnRange.endColumnExclusive, this.text, false),
        ];
        this.newLines = (0, strings_js_1.splitLines)(this.text);
    }
    renderForScreenReader(_lineText) {
        return this.newLines.join('\n');
    }
    render(documentText, debug = false) {
        const replaceRange = this.columnRange.toRange(this.lineNumber);
        if (debug) {
            return new textEdit_js_1.TextEdit([
                new textEdit_js_1.SingleTextEdit(range_js_1.Range.fromPositions(replaceRange.getStartPosition()), '('),
                new textEdit_js_1.SingleTextEdit(range_js_1.Range.fromPositions(replaceRange.getEndPosition()), `)[${this.newLines.join('\n')}]`),
            ]).applyToString(documentText);
        }
        else {
            return new textEdit_js_1.TextEdit([
                new textEdit_js_1.SingleTextEdit(replaceRange, this.newLines.join('\n')),
            ]).applyToString(documentText);
        }
    }
    get lineCount() {
        return this.newLines.length;
    }
    isEmpty() {
        return this.parts.every(p => p.lines.length === 0);
    }
    equals(other) {
        return this.lineNumber === other.lineNumber &&
            this.columnRange.equals(other.columnRange) &&
            this.newLines.length === other.newLines.length &&
            this.newLines.every((line, index) => line === other.newLines[index]) &&
            this.additionalReservedLineCount === other.additionalReservedLineCount;
    }
}
exports.GhostTextReplacement = GhostTextReplacement;
function ghostTextsOrReplacementsEqual(a, b) {
    return (0, arrays_js_1.equals)(a, b, ghostTextOrReplacementEquals);
}
function ghostTextOrReplacementEquals(a, b) {
    if (a === b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    if (a instanceof GhostText && b instanceof GhostText) {
        return a.equals(b);
    }
    if (a instanceof GhostTextReplacement && b instanceof GhostTextReplacement) {
        return a.equals(b);
    }
    return false;
}
//# sourceMappingURL=ghostText.js.map