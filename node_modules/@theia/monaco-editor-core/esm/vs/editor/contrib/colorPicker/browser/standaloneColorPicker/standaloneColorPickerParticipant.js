"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandaloneColorPickerParticipant = exports.StandaloneColorPickerHover = void 0;
const cancellation_js_1 = require("../../../../../base/common/cancellation.js");
const lifecycle_js_1 = require("../../../../../base/common/lifecycle.js");
const themeService_js_1 = require("../../../../../platform/theme/common/themeService.js");
const color_js_1 = require("../color.js");
const colorDetector_js_1 = require("../colorDetector.js");
const colorPickerParticipantUtils_js_1 = require("../colorPickerParticipantUtils.js");
const colorPickerWidget_js_1 = require("../colorPickerWidget.js");
const range_js_1 = require("../../../../common/core/range.js");
const dom_js_1 = require("../../../../../base/browser/dom.js");
class StandaloneColorPickerHover {
    constructor(owner, range, model, provider) {
        this.owner = owner;
        this.range = range;
        this.model = model;
        this.provider = provider;
    }
    static fromBaseColor(owner, color) {
        return new StandaloneColorPickerHover(owner, color.range, color.model, color.provider);
    }
}
exports.StandaloneColorPickerHover = StandaloneColorPickerHover;
let StandaloneColorPickerParticipant = class StandaloneColorPickerParticipant {
    constructor(_editor, _themeService) {
        this._editor = _editor;
        this._themeService = _themeService;
        this.hoverOrdinal = 2;
        this._color = null;
    }
    async createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
        if (!this._editor.hasModel()) {
            return null;
        }
        const colorDetector = colorDetector_js_1.ColorDetector.get(this._editor);
        if (!colorDetector) {
            return null;
        }
        const colors = await (0, color_js_1.getColors)(colorProviderRegistry, this._editor.getModel(), cancellation_js_1.CancellationToken.None);
        let foundColorInfo = null;
        let foundColorProvider = null;
        for (const colorData of colors) {
            const colorInfo = colorData.colorInfo;
            if (range_js_1.Range.containsRange(colorInfo.range, defaultColorInfo.range)) {
                foundColorInfo = colorInfo;
                foundColorProvider = colorData.provider;
            }
        }
        const colorInfo = foundColorInfo ?? defaultColorInfo;
        const colorProvider = foundColorProvider ?? defaultColorProvider;
        const foundInEditor = !!foundColorInfo;
        const colorHover = StandaloneColorPickerHover.fromBaseColor(this, await (0, colorPickerParticipantUtils_js_1.createColorHover)(this._editor.getModel(), colorInfo, colorProvider));
        return { colorHover, foundInEditor };
    }
    async updateEditorModel(colorHoverData) {
        if (!this._editor.hasModel()) {
            return;
        }
        const colorPickerModel = colorHoverData.model;
        let range = new range_js_1.Range(colorHoverData.range.startLineNumber, colorHoverData.range.startColumn, colorHoverData.range.endLineNumber, colorHoverData.range.endColumn);
        if (this._color) {
            await (0, colorPickerParticipantUtils_js_1.updateColorPresentations)(this._editor.getModel(), colorPickerModel, this._color, range, colorHoverData);
            range = (0, colorPickerParticipantUtils_js_1.updateEditorModel)(this._editor, range, colorPickerModel);
        }
    }
    renderHoverParts(context, hoverParts) {
        if (hoverParts.length === 0 || !this._editor.hasModel()) {
            return undefined;
        }
        if (context.setMinimumDimensions) {
            const minimumHeight = this._editor.getOption(68 /* EditorOption.lineHeight */) + 8;
            context.setMinimumDimensions(new dom_js_1.Dimension(302, minimumHeight));
        }
        const disposables = new lifecycle_js_1.DisposableStore();
        const colorHover = hoverParts[0];
        const editorModel = this._editor.getModel();
        const model = colorHover.model;
        const colorPicker = disposables.add(new colorPickerWidget_js_1.ColorPickerWidget(context.fragment, model, this._editor.getOption(149 /* EditorOption.pixelRatio */), this._themeService, "standalone" /* ColorPickerWidgetType.Standalone */));
        let editorUpdatedByColorPicker = false;
        const range = new range_js_1.Range(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
        const color = colorHover.model.color;
        this._color = color;
        (0, colorPickerParticipantUtils_js_1.updateColorPresentations)(editorModel, model, color, range, colorHover);
        disposables.add(model.onColorFlushed((color) => {
            this._color = color;
        }));
        disposables.add(model.onDidChangeColor((color) => {
            (0, colorPickerParticipantUtils_js_1.updateColorPresentations)(editorModel, model, color, range, colorHover);
        }));
        disposables.add(this._editor.onDidChangeModelContent((e) => {
            if (editorUpdatedByColorPicker) {
                editorUpdatedByColorPicker = false;
            }
            else {
                context.hide();
                this._editor.focus();
            }
        }));
        return { hoverPart: colorHover, colorPicker, disposables };
    }
};
exports.StandaloneColorPickerParticipant = StandaloneColorPickerParticipant;
exports.StandaloneColorPickerParticipant = StandaloneColorPickerParticipant = __decorate([
    __param(1, themeService_js_1.IThemeService)
], StandaloneColorPickerParticipant);
//# sourceMappingURL=standaloneColorPickerParticipant.js.map