"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.quickInputButtonToAction = quickInputButtonToAction;
exports.renderQuickInputDescription = renderQuickInputDescription;
const dom = require("../../../base/browser/dom.js");
const domStylesheetsJs = require("../../../base/browser/domStylesheets.js");
const cssJs = require("../../../base/browser/cssValue.js");
const event_js_1 = require("../../../base/browser/event.js");
const event_js_2 = require("../../../base/common/event.js");
const keyboardEvent_js_1 = require("../../../base/browser/keyboardEvent.js");
const touch_js_1 = require("../../../base/browser/touch.js");
const iconLabels_js_1 = require("../../../base/browser/ui/iconLabel/iconLabels.js");
const idGenerator_js_1 = require("../../../base/common/idGenerator.js");
const linkedText_js_1 = require("../../../base/common/linkedText.js");
require("./media/quickInput.css");
const nls_js_1 = require("../../../nls.js");
const iconPathToClass = {};
const iconClassGenerator = new idGenerator_js_1.IdGenerator('quick-input-button-icon-');
function getIconClass(iconPath) {
    if (!iconPath) {
        return undefined;
    }
    let iconClass;
    const key = iconPath.dark.toString();
    if (iconPathToClass[key]) {
        iconClass = iconPathToClass[key];
    }
    else {
        iconClass = iconClassGenerator.nextId();
        domStylesheetsJs.createCSSRule(`.${iconClass}, .hc-light .${iconClass}`, `background-image: ${cssJs.asCSSUrl(iconPath.light || iconPath.dark)}`);
        domStylesheetsJs.createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${cssJs.asCSSUrl(iconPath.dark)}`);
        iconPathToClass[key] = iconClass;
    }
    return iconClass;
}
function quickInputButtonToAction(button, id, run) {
    let cssClasses = button.iconClass || getIconClass(button.iconPath);
    if (button.alwaysVisible) {
        cssClasses = cssClasses ? `${cssClasses} always-visible` : 'always-visible';
    }
    return {
        id,
        label: '',
        tooltip: button.tooltip || '',
        class: cssClasses,
        enabled: true,
        run
    };
}
function renderQuickInputDescription(description, container, actionHandler) {
    dom.reset(container);
    const parsed = (0, linkedText_js_1.parseLinkedText)(description);
    let tabIndex = 0;
    for (const node of parsed.nodes) {
        if (typeof node === 'string') {
            container.append(...(0, iconLabels_js_1.renderLabelWithIcons)(node));
        }
        else {
            let title = node.title;
            if (!title && node.href.startsWith('command:')) {
                title = (0, nls_js_1.localize)('executeCommand', "Click to execute command '{0}'", node.href.substring('command:'.length));
            }
            else if (!title) {
                title = node.href;
            }
            const anchor = dom.$('a', { href: node.href, title, tabIndex: tabIndex++ }, node.label);
            anchor.style.textDecoration = 'underline';
            const handleOpen = (e) => {
                if (dom.isEventLike(e)) {
                    dom.EventHelper.stop(e, true);
                }
                actionHandler.callback(node.href);
            };
            const onClick = actionHandler.disposables.add(new event_js_1.DomEmitter(anchor, dom.EventType.CLICK)).event;
            const onKeydown = actionHandler.disposables.add(new event_js_1.DomEmitter(anchor, dom.EventType.KEY_DOWN)).event;
            const onSpaceOrEnter = event_js_2.Event.chain(onKeydown, $ => $.filter(e => {
                const event = new keyboardEvent_js_1.StandardKeyboardEvent(e);
                return event.equals(10 /* KeyCode.Space */) || event.equals(3 /* KeyCode.Enter */);
            }));
            actionHandler.disposables.add(touch_js_1.Gesture.addTarget(anchor));
            const onTap = actionHandler.disposables.add(new event_js_1.DomEmitter(anchor, touch_js_1.EventType.Tap)).event;
            event_js_2.Event.any(onClick, onTap, onSpaceOrEnter)(handleOpen, null, actionHandler.disposables);
            container.appendChild(anchor);
        }
    }
}
//# sourceMappingURL=quickInputUtils.js.map