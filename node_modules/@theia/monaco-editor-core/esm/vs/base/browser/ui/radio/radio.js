"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Radio = void 0;
const widget_js_1 = require("../widget.js");
const event_js_1 = require("../../../common/event.js");
require("./radio.css");
const dom_js_1 = require("../../dom.js");
const button_js_1 = require("../button/button.js");
const lifecycle_js_1 = require("../../../common/lifecycle.js");
const hoverDelegateFactory_js_1 = require("../hover/hoverDelegateFactory.js");
class Radio extends widget_js_1.Widget {
    constructor(opts) {
        super();
        this._onDidSelect = this._register(new event_js_1.Emitter());
        this.onDidSelect = this._onDidSelect.event;
        this.items = [];
        this.buttons = this._register(new lifecycle_js_1.DisposableMap());
        this.hoverDelegate = opts.hoverDelegate ?? this._register((0, hoverDelegateFactory_js_1.createInstantHoverDelegate)());
        this.domNode = (0, dom_js_1.$)('.monaco-custom-radio');
        this.domNode.setAttribute('role', 'radio');
        this.setItems(opts.items);
    }
    setItems(items) {
        this.buttons.clearAndDisposeAll();
        this.items = items;
        this.activeItem = this.items.find(item => item.isActive) ?? this.items[0];
        for (let index = 0; index < this.items.length; index++) {
            const item = this.items[index];
            const disposables = new lifecycle_js_1.DisposableStore();
            const button = disposables.add(new button_js_1.Button(this.domNode, {
                hoverDelegate: this.hoverDelegate,
                title: item.tooltip,
                supportIcons: true,
            }));
            button.enabled = !item.disabled;
            disposables.add(button.onDidClick(() => {
                if (this.activeItem !== item) {
                    this.activeItem = item;
                    this.updateButtons();
                    this._onDidSelect.fire(index);
                }
            }));
            this.buttons.set(button, { item, dispose: () => disposables.dispose() });
        }
        this.updateButtons();
    }
    setActiveItem(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('Invalid Index');
        }
        this.activeItem = this.items[index];
        this.updateButtons();
    }
    setEnabled(enabled) {
        for (const [button] of this.buttons) {
            button.enabled = enabled;
        }
    }
    updateButtons() {
        let isActive = false;
        for (const [button, { item }] of this.buttons) {
            const isPreviousActive = isActive;
            isActive = item === this.activeItem;
            button.element.classList.toggle('active', isActive);
            button.element.classList.toggle('previous-active', isPreviousActive);
            button.label = item.text;
        }
    }
}
exports.Radio = Radio;
//# sourceMappingURL=radio.js.map