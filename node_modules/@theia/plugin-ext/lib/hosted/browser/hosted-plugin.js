"use strict";
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts
var HostedPluginSupport_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HostedPluginSupport = exports.PluginProgressLocation = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
const uuid_1 = require("@theia/core/lib/common/uuid");
const inversify_1 = require("@theia/core/shared/inversify");
const plugin_worker_1 = require("./plugin-worker");
const plugin_protocol_1 = require("../../common/plugin-protocol");
const hosted_plugin_watcher_1 = require("./hosted-plugin-watcher");
const plugin_api_rpc_1 = require("../../common/plugin-api-rpc");
const main_context_1 = require("../../main/browser/main-context");
const rpc_protocol_1 = require("../../common/rpc-protocol");
const core_1 = require("@theia/core");
const preferences_1 = require("@theia/core/lib/browser/preferences");
const browser_1 = require("@theia/workspace/lib/browser");
const plugin_contribution_handler_1 = require("../../main/browser/plugin-contribution-handler");
const env_main_1 = require("../../main/browser/env-main");
const preference_registry_main_1 = require("../../main/browser/preference-registry-main");
const promise_util_1 = require("@theia/core/lib/common/promise-util");
const debug_session_manager_1 = require("@theia/debug/lib/browser/debug-session-manager");
const debug_configuration_manager_1 = require("@theia/debug/lib/browser/debug-configuration-manager");
const event_1 = require("@theia/core/lib/common/event");
const file_search_service_1 = require("@theia/file-search/lib/common/file-search-service");
const frontend_application_state_1 = require("@theia/core/lib/browser/frontend-application-state");
const plugin_view_registry_1 = require("../../main/browser/view/plugin-view-registry");
const task_contribution_1 = require("@theia/task/lib/browser/task-contribution");
const task_definition_registry_1 = require("@theia/task/lib/browser/task-definition-registry");
const webview_environment_1 = require("../../main/browser/webview/webview-environment");
const webview_1 = require("../../main/browser/webview/webview");
const widget_manager_1 = require("@theia/core/lib/browser/widget-manager");
const terminal_service_1 = require("@theia/terminal/lib/browser/base/terminal-service");
const uri_1 = require("@theia/core/lib/common/uri");
const frontend_application_config_provider_1 = require("@theia/core/lib/browser/frontend-application-config-provider");
const environment_1 = require("@theia/core/shared/@theia/application-package/lib/environment");
const json_schema_store_1 = require("@theia/core/lib/browser/json-schema-store");
const file_service_1 = require("@theia/filesystem/lib/browser/file-service");
const plugin_custom_editor_registry_1 = require("../../main/browser/custom-editors/plugin-custom-editor-registry");
const custom_editor_widget_1 = require("../../main/browser/custom-editors/custom-editor-widget");
const standaloneServices_1 = require("@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices");
const language_1 = require("@theia/monaco-editor-core/esm/vs/editor/common/languages/language");
const uint8_array_message_buffer_1 = require("@theia/core/lib/common/message-rpc/uint8-array-message-buffer");
const channel_1 = require("@theia/core/lib/common/message-rpc/channel");
const browser_2 = require("@theia/notebook/lib/browser");
const application_protocol_1 = require("@theia/core/lib/common/application-protocol");
const hosted_plugin_1 = require("../common/hosted-plugin");
const browser_3 = require("@theia/core/lib/browser/browser");
exports.PluginProgressLocation = 'plugin';
let HostedPluginSupport = HostedPluginSupport_1 = class HostedPluginSupport extends hosted_plugin_1.AbstractHostedPluginSupport {
    constructor() {
        super((0, uuid_1.generateUuid)());
        this.webviewsToRestore = new Map();
        this.webviewRevivers = new Map();
    }
    init() {
        super.init();
        this.workspaceService.onWorkspaceChanged(() => this.updateStoragePath());
        const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
        for (const language of languageService['_requestedBasicLanguages']) {
            this.activateByLanguage(language);
        }
        languageService.onDidRequestBasicLanguageFeatures(language => this.activateByLanguage(language));
        this.commands.onWillExecuteCommand(event => this.ensureCommandHandlerRegistration(event));
        this.debugSessionManager.onWillStartDebugSession(event => this.ensureDebugActivation(event));
        this.debugSessionManager.onWillResolveDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugResolve', event.debugType));
        this.debugConfigurationManager.onWillProvideDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugInitialConfigurations'));
        // Activate all providers of dynamic configurations, i.e. Let the user pick a configuration from all the available ones.
        this.debugConfigurationManager.onWillProvideDynamicDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugDynamicConfigurations', hosted_plugin_1.ALL_ACTIVATION_EVENT));
        this.viewRegistry.onDidExpandView(id => this.activateByView(id));
        this.taskProviderRegistry.onWillProvideTaskProvider(event => this.ensureTaskActivation(event));
        this.taskResolverRegistry.onWillProvideTaskResolver(event => this.ensureTaskActivation(event));
        this.fileService.onWillActivateFileSystemProvider(event => this.ensureFileSystemActivation(event));
        this.customEditorRegistry.onWillOpenCustomEditor(event => this.activateByCustomEditor(event));
        this.notebookService.onWillOpenNotebook(async (event) => this.activateByNotebook(event));
        this.notebookRendererMessagingService.onWillActivateRenderer(rendererId => this.activateByNotebookRenderer(rendererId));
        this.widgets.onDidCreateWidget(({ factoryId, widget }) => {
            // note: state restoration of custom editors is handled in `PluginCustomEditorRegistry.init`
            if (factoryId === webview_1.WebviewWidget.FACTORY_ID && widget instanceof webview_1.WebviewWidget) {
                const storeState = widget.storeState.bind(widget);
                const restoreState = widget.restoreState.bind(widget);
                widget.storeState = () => {
                    if (this.webviewRevivers.has(widget.viewType)) {
                        return storeState();
                    }
                    return undefined;
                };
                widget.restoreState = state => {
                    if (state.viewType) {
                        restoreState(state);
                        this.preserveWebview(widget);
                    }
                    else {
                        widget.dispose();
                    }
                };
            }
        });
    }
    createTheiaReadyPromise() {
        return Promise.all([this.preferenceServiceImpl.ready, this.workspaceService.roots]);
    }
    runOperation(operation) {
        return this.progressService.withProgress('', exports.PluginProgressLocation, () => this.doLoad());
    }
    afterStart() {
        this.watcher.onDidDeploy(() => this.load());
        this.server.onDidOpenConnection(() => this.load());
    }
    // Only load connection-scoped plugins
    acceptPlugin(plugin) {
        return (0, hosted_plugin_1.isConnectionScopedBackendPlugin)(plugin);
    }
    async beforeSyncPlugins(toDisconnect) {
        await super.beforeSyncPlugins(toDisconnect);
        toDisconnect.push(core_1.Disposable.create(() => this.preserveWebviews()));
        this.server.onDidCloseConnection(() => toDisconnect.dispose());
    }
    async beforeLoadContributions(toDisconnect) {
        // make sure that the previous state, including plugin widgets, is restored
        // and core layout is initialized, i.e. explorer, scm, debug views are already added to the shell
        // but shell is not yet revealed
        await this.appState.reachedState('initialized_layout');
    }
    async afterLoadContributions(toDisconnect) {
        await this.viewRegistry.initWidgets();
        // remove restored plugin widgets which were not registered by contributions
        this.viewRegistry.removeStaleWidgets();
    }
    handleContributions(plugin) {
        return this.contributionHandler.handleContributions(this.clientId, plugin);
    }
    handlePluginStarted(manager, plugin) {
        this.activateByWorkspaceContains(manager, plugin);
    }
    async obtainManager(host, hostContributions, toDisconnect) {
        var _a;
        let manager = this.managers.get(host);
        if (!manager) {
            const pluginId = (0, plugin_protocol_1.getPluginId)(hostContributions[0].plugin.metadata.model);
            const rpc = this.initRpc(host, pluginId);
            toDisconnect.push(rpc);
            manager = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.HOSTED_PLUGIN_MANAGER_EXT);
            this.managers.set(host, manager);
            toDisconnect.push(core_1.Disposable.create(() => this.managers.delete(host)));
            const [extApi, globalState, workspaceState, webviewResourceRoot, webviewCspSource, defaultShell, jsonValidation] = await Promise.all([
                this.server.getExtPluginAPI(),
                this.pluginServer.getAllStorageValues(undefined),
                this.pluginServer.getAllStorageValues({
                    workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
                    roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
                }),
                this.webviewEnvironment.resourceRoot(host),
                this.webviewEnvironment.cspSource(),
                this.terminalService.getDefaultShell(),
                this.jsonSchemaStore.schemas
            ]);
            if (toDisconnect.disposed) {
                return undefined;
            }
            const isElectron = environment_1.environment.electron.is();
            const supportedActivationEvents = [...HostedPluginSupport_1.BUILTIN_ACTIVATION_EVENTS];
            const [additionalActivationEvents, appRoot] = await Promise.all([
                this.envServer.getValue(HostedPluginSupport_1.ADDITIONAL_ACTIVATION_EVENTS_ENV),
                this.applicationServer.getApplicationRoot()
            ]);
            if (additionalActivationEvents && additionalActivationEvents.value) {
                additionalActivationEvents.value.split(',').forEach(event => supportedActivationEvents.push(event));
            }
            await manager.$init({
                preferences: (0, preference_registry_main_1.getPreferences)(this.preferenceProviderProvider, this.workspaceService.tryGetRoots()),
                globalState,
                workspaceState,
                env: {
                    queryParams: (0, env_main_1.getQueryParameters)(),
                    language: core_1.nls.locale || core_1.nls.defaultLocale,
                    shell: defaultShell,
                    uiKind: isElectron ? plugin_api_rpc_1.UIKind.Desktop : plugin_api_rpc_1.UIKind.Web,
                    appName: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().applicationName,
                    appHost: isElectron ? 'desktop' : 'web', // TODO: 'web' could be the embedder's name, e.g. 'github.dev'
                    appRoot,
                    appUriScheme: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().electron.uriScheme
                },
                extApi,
                webview: {
                    webviewResourceRoot,
                    webviewCspSource
                },
                jsonValidation,
                pluginKind: browser_3.isRemote ? plugin_api_rpc_1.ExtensionKind.Workspace : plugin_api_rpc_1.ExtensionKind.UI,
                supportedActivationEvents
            });
            if (toDisconnect.disposed) {
                return undefined;
            }
            this.activationEvents.forEach(event => manager.$activateByEvent(event));
        }
        return manager;
    }
    initRpc(host, pluginId) {
        const rpc = host === 'frontend' ? new plugin_worker_1.PluginWorker().rpc : this.createServerRpc(host);
        (0, main_context_1.setUpPluginApi)(rpc, this.container);
        this.mainPluginApiProviders.getContributions().forEach(p => p.initialize(rpc, this.container));
        return rpc;
    }
    createServerRpc(pluginHostId) {
        const channel = new channel_1.BasicChannel(() => {
            const writer = new uint8_array_message_buffer_1.Uint8ArrayWriteBuffer();
            writer.onCommit(buffer => {
                this.server.onMessage(pluginHostId, buffer);
            });
            return writer;
        });
        // Create RPC protocol before adding the listener to the watcher to receive the watcher's cached messages after the rpc protocol was created.
        const rpc = new rpc_protocol_1.RPCProtocolImpl(channel);
        this.watcher.onPostMessageEvent(received => {
            if (pluginHostId === received.pluginHostId) {
                channel.onMessageEmitter.fire(() => new uint8_array_message_buffer_1.Uint8ArrayReadBuffer(received.message));
            }
        });
        return rpc;
    }
    async updateStoragePath() {
        const path = await this.getStoragePath();
        for (const manager of this.managers.values()) {
            manager.$updateStoragePath(path);
        }
    }
    async getStoragePath() {
        var _a;
        const roots = await this.workspaceService.roots;
        return this.pluginPathsService.getHostStoragePath((_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(), roots.map(root => root.resource.toString()));
    }
    async getHostGlobalStoragePath() {
        const configDirUri = await this.envServer.getConfigDirUri();
        const globalStorageFolderUri = new uri_1.default(configDirUri).resolve('globalStorage');
        // Make sure that folder by the path exists
        if (!await this.fileService.exists(globalStorageFolderUri)) {
            await this.fileService.createFolder(globalStorageFolderUri, { fromUserGesture: false });
        }
        const globalStorageFolderFsPath = await this.fileService.fsPath(globalStorageFolderUri);
        if (!globalStorageFolderFsPath) {
            throw new Error(`Could not resolve the FS path for URI: ${globalStorageFolderUri}`);
        }
        return globalStorageFolderFsPath;
    }
    async activateByViewContainer(viewContainerId) {
        await Promise.all(this.viewRegistry.getContainerViews(viewContainerId).map(viewId => this.activateByView(viewId)));
    }
    async activateByView(viewId) {
        await this.activateByEvent(`onView:${viewId}`);
    }
    async activateByLanguage(languageId) {
        await this.activateByEvent('onLanguage');
        await this.activateByEvent(`onLanguage:${languageId}`);
    }
    async activateByUri(scheme, authority) {
        await this.activateByEvent(`onUri:${scheme}://${authority}`);
    }
    async activateByCommand(commandId) {
        await this.activateByEvent(`onCommand:${commandId}`);
    }
    async activateByTaskType(taskType) {
        await this.activateByEvent(`onTaskType:${taskType}`);
    }
    async activateByCustomEditor(viewType) {
        await this.activateByEvent(`onCustomEditor:${viewType}`);
    }
    async activateByNotebook(viewType) {
        await this.activateByEvent(`onNotebook:${viewType}`);
    }
    async activateByNotebookSerializer(viewType) {
        await this.activateByEvent(`onNotebookSerializer:${viewType}`);
    }
    async activateByNotebookRenderer(rendererId) {
        await this.activateByEvent(`onRenderer:${rendererId}`);
    }
    activateByFileSystem(event) {
        return this.activateByEvent(`onFileSystem:${event.scheme}`);
    }
    activateByTerminalProfile(profileId) {
        return this.activateByEvent(`onTerminalProfile:${profileId}`);
    }
    ensureFileSystemActivation(event) {
        event.waitUntil(this.activateByFileSystem(event).then(() => {
            if (!this.fileService.hasProvider(event.scheme)) {
                return (0, promise_util_1.waitForEvent)(event_1.Event.filter(this.fileService.onDidChangeFileSystemProviderRegistrations, ({ added, scheme }) => added && scheme === event.scheme), 3000);
            }
        }));
    }
    ensureCommandHandlerRegistration(event) {
        const activation = this.activateByCommand(event.commandId);
        if (this.commands.getCommand(event.commandId) &&
            (!this.contributionHandler.hasCommand(event.commandId) ||
                this.contributionHandler.hasCommandHandler(event.commandId))) {
            return;
        }
        const waitForCommandHandler = new promise_util_1.Deferred();
        const listener = this.contributionHandler.onDidRegisterCommandHandler(id => {
            if (id === event.commandId) {
                listener.dispose();
                waitForCommandHandler.resolve();
            }
        });
        const p = Promise.all([
            activation,
            waitForCommandHandler.promise
        ]);
        p.then(() => listener.dispose(), () => listener.dispose());
        event.waitUntil(p);
    }
    ensureTaskActivation(event) {
        const promises = [this.activateByCommand('workbench.action.tasks.runTask')];
        const taskType = event.taskType;
        if (taskType) {
            if (taskType === hosted_plugin_1.ALL_ACTIVATION_EVENT) {
                for (const taskDefinition of this.taskDefinitionRegistry.getAll()) {
                    promises.push(this.activateByTaskType(taskDefinition.taskType));
                }
            }
            else {
                promises.push(this.activateByTaskType(taskType));
            }
        }
        event.waitUntil(Promise.all(promises));
    }
    ensureDebugActivation(event, activationEvent, debugType) {
        event.waitUntil(this.activateByDebug(activationEvent, debugType));
    }
    async activateByDebug(activationEvent, debugType) {
        const promises = [this.activateByEvent('onDebug')];
        if (activationEvent) {
            promises.push(this.activateByEvent(activationEvent));
            if (debugType) {
                promises.push(this.activateByEvent(activationEvent + ':' + debugType));
            }
        }
        await Promise.all(promises);
    }
    async activateByWorkspaceContains(manager, plugin) {
        const activationEvents = plugin.contributes && plugin.contributes.activationEvents;
        if (!activationEvents) {
            return;
        }
        const paths = [];
        const includePatterns = [];
        // should be aligned with https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts#L460-L469
        for (const activationEvent of activationEvents) {
            if (/^workspaceContains:/.test(activationEvent)) {
                const fileNameOrGlob = activationEvent.substring('workspaceContains:'.length);
                if (fileNameOrGlob.indexOf(hosted_plugin_1.ALL_ACTIVATION_EVENT) >= 0 || fileNameOrGlob.indexOf('?') >= 0) {
                    includePatterns.push(fileNameOrGlob);
                }
                else {
                    paths.push(fileNameOrGlob);
                }
            }
        }
        const activatePlugin = () => manager.$activateByEvent(`onPlugin:${plugin.metadata.model.id}`);
        const promises = [];
        if (paths.length) {
            promises.push(this.workspaceService.containsSome(paths));
        }
        if (includePatterns.length) {
            const tokenSource = new core_1.CancellationTokenSource();
            const searchTimeout = setTimeout(() => {
                tokenSource.cancel();
                // activate eagerly if took to long to search
                activatePlugin();
            }, 7000);
            promises.push((async () => {
                try {
                    const result = await this.fileSearchService.find('', {
                        rootUris: this.workspaceService.tryGetRoots().map(r => r.resource.toString()),
                        includePatterns,
                        limit: 1
                    }, tokenSource.token);
                    return result.length > 0;
                }
                catch (e) {
                    if (!(0, core_1.isCancelled)(e)) {
                        console.error(e);
                    }
                    return false;
                }
                finally {
                    clearTimeout(searchTimeout);
                }
            })());
        }
        if (promises.length && await Promise.all(promises).then(exists => exists.some(v => v))) {
            await activatePlugin();
        }
    }
    registerWebviewReviver(viewType, reviver) {
        if (this.webviewRevivers.has(viewType)) {
            throw new Error(`Reviver for ${viewType} already registered`);
        }
        this.webviewRevivers.set(viewType, reviver);
        if (this.webviewsToRestore.has(viewType)) {
            this.restoreWebview(this.webviewsToRestore.get(viewType));
        }
    }
    unregisterWebviewReviver(viewType) {
        this.webviewRevivers.delete(viewType);
    }
    async preserveWebviews() {
        for (const webview of this.widgets.getWidgets(webview_1.WebviewWidget.FACTORY_ID)) {
            this.preserveWebview(webview);
        }
        for (const webview of this.widgets.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID)) {
            webview.modelRef.dispose();
            if (webview['closeWithoutSaving']) {
                delete webview['closeWithoutSaving'];
            }
            this.customEditorRegistry.resolveWidget(webview);
        }
    }
    preserveWebview(webview) {
        if (!this.webviewsToRestore.has(webview.viewType)) {
            this.activateByEvent(`onWebviewPanel:${webview.viewType}`);
            this.webviewsToRestore.set(webview.viewType, webview);
            webview.disposed.connect(() => this.webviewsToRestore.delete(webview.viewType));
        }
    }
    async restoreWebview(webview) {
        const restore = this.webviewRevivers.get(webview.viewType);
        if (restore) {
            try {
                await restore(webview);
            }
            catch (e) {
                webview.setHTML(this.getDeserializationFailedContents(`
                An error occurred while restoring '${webview.viewType}' view. Please check logs.
                `));
                console.error('Failed to restore the webview', e);
            }
        }
    }
    getDeserializationFailedContents(message) {
        return `<!DOCTYPE html>
        <html>
            <head>
                <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none';">
            </head>
            <body>${message}</body>
        </html>`;
    }
};
exports.HostedPluginSupport = HostedPluginSupport;
HostedPluginSupport.ADDITIONAL_ACTIVATION_EVENTS_ENV = 'ADDITIONAL_ACTIVATION_EVENTS';
HostedPluginSupport.BUILTIN_ACTIVATION_EVENTS = [
    '*',
    'onLanguage',
    'onCommand',
    'onDebug',
    'onDebugInitialConfigurations',
    'onDebugResolve',
    'onDebugAdapterProtocolTracker',
    'onDebugDynamicConfigurations',
    'onTaskType',
    'workspaceContains',
    'onView',
    'onUri',
    'onTerminalProfile',
    'onWebviewPanel',
    'onFileSystem',
    'onCustomEditor',
    'onStartupFinished',
    'onAuthenticationRequest',
    'onNotebook',
    'onNotebookSerializer'
];
tslib_1.__decorate([
    (0, inversify_1.inject)(hosted_plugin_watcher_1.HostedPluginWatcher),
    tslib_1.__metadata("design:type", hosted_plugin_watcher_1.HostedPluginWatcher)
], HostedPluginSupport.prototype, "watcher", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_contribution_handler_1.PluginContributionHandler),
    tslib_1.__metadata("design:type", plugin_contribution_handler_1.PluginContributionHandler)
], HostedPluginSupport.prototype, "contributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceProviderProvider),
    tslib_1.__metadata("design:type", Function)
], HostedPluginSupport.prototype, "preferenceProviderProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceServiceImpl),
    tslib_1.__metadata("design:type", preferences_1.PreferenceServiceImpl)
], HostedPluginSupport.prototype, "preferenceServiceImpl", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], HostedPluginSupport.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookService),
    tslib_1.__metadata("design:type", browser_2.NotebookService)
], HostedPluginSupport.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookRendererMessagingService),
    tslib_1.__metadata("design:type", browser_2.NotebookRendererMessagingService)
], HostedPluginSupport.prototype, "notebookRendererMessagingService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], HostedPluginSupport.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], HostedPluginSupport.prototype, "debugSessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_manager_1.DebugConfigurationManager),
    tslib_1.__metadata("design:type", debug_configuration_manager_1.DebugConfigurationManager)
], HostedPluginSupport.prototype, "debugConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], HostedPluginSupport.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_search_service_1.FileSearchService),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "fileSearchService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(frontend_application_state_1.FrontendApplicationStateService),
    tslib_1.__metadata("design:type", frontend_application_state_1.FrontendApplicationStateService)
], HostedPluginSupport.prototype, "appState", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookTypeRegistry),
    tslib_1.__metadata("design:type", browser_2.NotebookTypeRegistry)
], HostedPluginSupport.prototype, "notebookTypeRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_view_registry_1.PluginViewRegistry),
    tslib_1.__metadata("design:type", plugin_view_registry_1.PluginViewRegistry)
], HostedPluginSupport.prototype, "viewRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskProviderRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskProviderRegistry)
], HostedPluginSupport.prototype, "taskProviderRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskResolverRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskResolverRegistry)
], HostedPluginSupport.prototype, "taskResolverRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], HostedPluginSupport.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ProgressService),
    tslib_1.__metadata("design:type", core_1.ProgressService)
], HostedPluginSupport.prototype, "progressService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_environment_1.WebviewEnvironment),
    tslib_1.__metadata("design:type", webview_environment_1.WebviewEnvironment)
], HostedPluginSupport.prototype, "webviewEnvironment", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(widget_manager_1.WidgetManager),
    tslib_1.__metadata("design:type", widget_manager_1.WidgetManager)
], HostedPluginSupport.prototype, "widgets", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(json_schema_store_1.JsonSchemaStore),
    tslib_1.__metadata("design:type", json_schema_store_1.JsonSchemaStore)
], HostedPluginSupport.prototype, "jsonSchemaStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_custom_editor_registry_1.PluginCustomEditorRegistry),
    tslib_1.__metadata("design:type", plugin_custom_editor_registry_1.PluginCustomEditorRegistry)
], HostedPluginSupport.prototype, "customEditorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_protocol_1.ApplicationServer),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "applicationServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], HostedPluginSupport.prototype, "init", null);
exports.HostedPluginSupport = HostedPluginSupport = HostedPluginSupport_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], HostedPluginSupport);
//# sourceMappingURL=hosted-plugin.js.map