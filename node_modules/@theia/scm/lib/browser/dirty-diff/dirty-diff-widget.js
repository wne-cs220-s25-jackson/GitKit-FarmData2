"use strict";
// *****************************************************************************
// Copyright (C) 2023 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirtyDiffWidget = exports.DirtyDiffWidgetFactory = exports.DirtyDiffWidgetProps = exports.PLUGIN_SCM_CHANGE_TITLE_MENU = exports.SCM_CHANGE_TITLE_MENU = void 0;
const tslib_1 = require("tslib");
const inversify_1 = require("@theia/core/shared/inversify");
const vscode_languageserver_protocol_1 = require("@theia/core/shared/vscode-languageserver-protocol");
const core_1 = require("@theia/core");
const browser_1 = require("@theia/core/lib/browser");
const context_key_service_1 = require("@theia/core/lib/browser/context-key-service");
const monaco_editor_provider_1 = require("@theia/monaco/lib/browser/monaco-editor-provider");
const monaco_editor_peek_view_widget_1 = require("@theia/monaco/lib/browser/monaco-editor-peek-view-widget");
const diff_computer_1 = require("./diff-computer");
const scm_colors_1 = require("../scm-colors");
const monaco = require("@theia/monaco-editor-core");
exports.SCM_CHANGE_TITLE_MENU = ['scm-change-title-menu'];
/** Reserved for plugin contributions, corresponds to contribution point 'scm/change/title'. */
exports.PLUGIN_SCM_CHANGE_TITLE_MENU = ['plugin-scm-change-title-menu'];
exports.DirtyDiffWidgetProps = Symbol('DirtyDiffWidgetProps');
exports.DirtyDiffWidgetFactory = Symbol('DirtyDiffWidgetFactory');
let DirtyDiffWidget = class DirtyDiffWidget {
    constructor(props, editorProvider, contextKeyService, menuModelRegistry, menuCommandExecutor) {
        this.props = props;
        this.editorProvider = editorProvider;
        this.contextKeyService = contextKeyService;
        this.menuModelRegistry = menuModelRegistry;
        this.menuCommandExecutor = menuCommandExecutor;
        this.onDidCloseEmitter = new core_1.Emitter();
        this.onDidClose = this.onDidCloseEmitter.event;
        this.index = -1;
    }
    create() {
        this.peekView = new DirtyDiffPeekView(this);
        this.peekView.onDidClose(e => this.onDidCloseEmitter.fire(e));
        this.diffEditorPromise = this.peekView.create();
    }
    get editor() {
        return this.props.editor;
    }
    get uri() {
        return this.editor.uri;
    }
    get previousRevisionUri() {
        return this.props.previousRevisionUri;
    }
    get changes() {
        return this.props.changes;
    }
    get currentChange() {
        return this.changes[this.index];
    }
    get currentChangeIndex() {
        return this.index;
    }
    showChange(index) {
        this.checkCreated();
        if (index >= 0 && index < this.changes.length) {
            this.index = index;
            this.showCurrentChange();
        }
    }
    showNextChange() {
        this.checkCreated();
        const index = this.index;
        const length = this.changes.length;
        if (length > 0 && (index < 0 || length > 1)) {
            this.index = index < 0 ? 0 : cycle(index, 1, length);
            this.showCurrentChange();
        }
    }
    showPreviousChange() {
        this.checkCreated();
        const index = this.index;
        const length = this.changes.length;
        if (length > 0 && (index < 0 || length > 1)) {
            this.index = index < 0 ? length - 1 : cycle(index, -1, length);
            this.showCurrentChange();
        }
    }
    async getContentWithSelectedChanges(predicate) {
        this.checkCreated();
        const changes = this.changes.filter(predicate);
        const { diffEditor } = await this.diffEditorPromise;
        const diffEditorModel = diffEditor.getModel();
        return applyChanges(changes, diffEditorModel.original, diffEditorModel.modified);
    }
    dispose() {
        var _a;
        (_a = this.peekView) === null || _a === void 0 ? void 0 : _a.dispose();
        this.onDidCloseEmitter.dispose();
    }
    showCurrentChange() {
        this.peekView.setTitle(this.computePrimaryHeading(), this.computeSecondaryHeading());
        const { previousRange, currentRange } = this.changes[this.index];
        this.peekView.show(vscode_languageserver_protocol_1.Position.create(diff_computer_1.LineRange.getEndPosition(currentRange).line, 0), this.computeHeightInLines());
        this.diffEditorPromise.then(({ diffEditor }) => {
            let startLine = diff_computer_1.LineRange.getStartPosition(currentRange).line;
            let endLine = diff_computer_1.LineRange.getEndPosition(currentRange).line;
            if (diff_computer_1.LineRange.isEmpty(currentRange)) { // the change is a removal
                ++endLine;
            }
            else if (!diff_computer_1.LineRange.isEmpty(previousRange)) { // the change is a modification
                --startLine;
                ++endLine;
            }
            diffEditor.revealLinesInCenter(startLine + 1, endLine + 1, // monaco line numbers are 1-based
            monaco.editor.ScrollType.Immediate);
        });
        this.editor.focus();
    }
    computePrimaryHeading() {
        return this.uri.path.base;
    }
    computeSecondaryHeading() {
        const index = this.index + 1;
        const length = this.changes.length;
        return length > 1 ? core_1.nls.localizeByDefault('{0} of {1} changes', index, length) :
            core_1.nls.localizeByDefault('{0} of {1} change', index, length);
    }
    computeHeightInLines() {
        const editor = this.editor.getControl();
        const lineHeight = editor.getOption(monaco.editor.EditorOption.lineHeight);
        const editorHeight = editor.getLayoutInfo().height;
        const editorHeightInLines = Math.floor(editorHeight / lineHeight);
        const { previousRange, currentRange } = this.changes[this.index];
        const changeHeightInLines = diff_computer_1.LineRange.getLineCount(currentRange) + diff_computer_1.LineRange.getLineCount(previousRange);
        return Math.min(changeHeightInLines + /* padding */ 8, Math.floor(editorHeightInLines / 3));
    }
    checkCreated() {
        if (!this.peekView) {
            throw new Error('create() method needs to be called first.');
        }
    }
};
exports.DirtyDiffWidget = DirtyDiffWidget;
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DirtyDiffWidget.prototype, "create", null);
exports.DirtyDiffWidget = DirtyDiffWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(exports.DirtyDiffWidgetProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(monaco_editor_provider_1.MonacoEditorProvider)),
    tslib_1.__param(2, (0, inversify_1.inject)(context_key_service_1.ContextKeyService)),
    tslib_1.__param(3, (0, inversify_1.inject)(core_1.MenuModelRegistry)),
    tslib_1.__param(4, (0, inversify_1.inject)(core_1.MenuCommandExecutor)),
    tslib_1.__metadata("design:paramtypes", [Object, monaco_editor_provider_1.MonacoEditorProvider, Object, core_1.MenuModelRegistry, Object])
], DirtyDiffWidget);
function cycle(index, offset, length) {
    return (index + offset + length) % length;
}
// adapted from https://github.com/microsoft/vscode/blob/823d54f86ee13eb357bc6e8e562e89d793f3c43b/extensions/git/src/staging.ts
function applyChanges(changes, original, modified) {
    const result = [];
    let currentLine = 1;
    for (const change of changes) {
        const { previousRange, currentRange } = change;
        const isInsertion = diff_computer_1.LineRange.isEmpty(previousRange);
        const isDeletion = diff_computer_1.LineRange.isEmpty(currentRange);
        const convert = (range) => {
            let startLineNumber;
            let endLineNumber;
            if (!diff_computer_1.LineRange.isEmpty(range)) {
                startLineNumber = range.start + 1;
                endLineNumber = range.end;
            }
            else {
                startLineNumber = range.start;
                endLineNumber = 0;
            }
            return [startLineNumber, endLineNumber];
        };
        const [originalStartLineNumber, originalEndLineNumber] = convert(previousRange);
        const [modifiedStartLineNumber, modifiedEndLineNumber] = convert(currentRange);
        let toLine = isInsertion ? originalStartLineNumber + 1 : originalStartLineNumber;
        let toCharacter = 1;
        // if this is a deletion at the very end of the document,
        // we need to account for a newline at the end of the last line,
        // which may have been deleted
        if (isDeletion && originalEndLineNumber === original.getLineCount()) {
            toLine--;
            toCharacter = original.getLineMaxColumn(toLine);
        }
        result.push(original.getValueInRange(new monaco.Range(currentLine, 1, toLine, toCharacter)));
        if (!isDeletion) {
            let fromLine = modifiedStartLineNumber;
            let fromCharacter = 1;
            // if this is an insertion at the very end of the document,
            // we must start the next range after the last character of the previous line,
            // in order to take the correct eol
            if (isInsertion && originalStartLineNumber === original.getLineCount()) {
                fromLine--;
                fromCharacter = modified.getLineMaxColumn(fromLine);
            }
            result.push(modified.getValueInRange(new monaco.Range(fromLine, fromCharacter, modifiedEndLineNumber + 1, 1)));
        }
        currentLine = isInsertion ? originalStartLineNumber + 1 : originalEndLineNumber + 1;
    }
    result.push(original.getValueInRange(new monaco.Range(currentLine, 1, original.getLineCount() + 1, 1)));
    return result.join('');
}
class DirtyDiffPeekView extends monaco_editor_peek_view_widget_1.MonacoEditorPeekViewWidget {
    constructor(widget) {
        super(widget.editor, { isResizeable: true, showArrow: true, frameWidth: 1, keepEditorSelection: true, className: 'dirty-diff' });
        this.widget = widget;
    }
    async create() {
        try {
            super.create();
            const diffEditor = await this.diffEditorPromise;
            return new Promise(resolve => {
                // setTimeout is needed here because the non-side-by-side diff editor might still not have created the view zones;
                // otherwise, the first change shown might not be properly revealed in the diff editor.
                // see also https://github.com/microsoft/vscode/blob/b30900b56c4b3ca6c65d7ab92032651f4cb23f15/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.ts#L248
                const disposable = diffEditor.diffEditor.onDidUpdateDiff(() => setTimeout(() => {
                    resolve(diffEditor);
                    disposable.dispose();
                }));
            });
        }
        catch (e) {
            this.dispose();
            throw e;
        }
    }
    show(rangeOrPos, heightInLines) {
        const borderColor = this.getBorderColor();
        this.style({
            arrowColor: borderColor,
            frameColor: borderColor,
            headerBackgroundColor: monaco_editor_peek_view_widget_1.peekViewTitleBackground,
            primaryHeadingColor: monaco_editor_peek_view_widget_1.peekViewTitleForeground,
            secondaryHeadingColor: monaco_editor_peek_view_widget_1.peekViewTitleInfoForeground
        });
        this.updateActions();
        super.show(rangeOrPos, heightInLines);
    }
    getBorderColor() {
        const { currentChange } = this.widget;
        if (!currentChange) {
            return monaco_editor_peek_view_widget_1.peekViewBorder;
        }
        if (diff_computer_1.Change.isAddition(currentChange)) {
            return scm_colors_1.ScmColors.editorGutterAddedBackground;
        }
        else if (diff_computer_1.Change.isRemoval(currentChange)) {
            return scm_colors_1.ScmColors.editorGutterDeletedBackground;
        }
        else {
            return scm_colors_1.ScmColors.editorGutterModifiedBackground;
        }
    }
    updateActions() {
        this.clearActions();
        const { contextKeyService, menuModelRegistry, menuCommandExecutor } = this.widget;
        contextKeyService.with({ originalResourceScheme: this.widget.previousRevisionUri.scheme }, () => {
            for (const menuPath of [exports.SCM_CHANGE_TITLE_MENU, exports.PLUGIN_SCM_CHANGE_TITLE_MENU]) {
                const menu = menuModelRegistry.getMenu(menuPath);
                for (const item of menu.children) {
                    if (item instanceof core_1.ActionMenuNode) {
                        const { command, id, label, icon, when } = item;
                        if (icon && menuCommandExecutor.isVisible(menuPath, command, this.widget) && (!when || contextKeyService.match(when))) {
                            this.addAction(id, label, icon, menuCommandExecutor.isEnabled(menuPath, command, this.widget), () => {
                                menuCommandExecutor.executeCommand(menuPath, command, this.widget);
                            });
                        }
                    }
                }
            }
        });
        this.addAction('dirtydiff.next', core_1.nls.localizeByDefault('Show Next Change'), (0, browser_1.codicon)('arrow-down'), true, () => this.widget.showNextChange());
        this.addAction('dirtydiff.previous', core_1.nls.localizeByDefault('Show Previous Change'), (0, browser_1.codicon)('arrow-up'), true, () => this.widget.showPreviousChange());
        this.addAction('peekview.close', core_1.nls.localizeByDefault('Close'), (0, browser_1.codicon)('close'), true, () => this.dispose());
    }
    fillHead(container) {
        super.fillHead(container, true);
    }
    fillBody(container) {
        this.diffEditorPromise = this.widget.editorProvider.createEmbeddedDiffEditor(this.editor, container, this.widget.previousRevisionUri).then(diffEditor => {
            this.toDispose.push(diffEditor);
            return diffEditor;
        });
    }
    doLayoutBody(height, width) {
        super.doLayoutBody(height, width);
        this.layout(height, width);
        this.height = height;
    }
    onWidth(width) {
        super.onWidth(width);
        const { height } = this;
        if (height !== undefined) {
            this.layout(height, width);
        }
    }
    layout(height, width) {
        var _a;
        (_a = this.diffEditorPromise) === null || _a === void 0 ? void 0 : _a.then(({ diffEditor }) => diffEditor.layout({ height, width }));
    }
    doRevealRange(range) {
        this.editor.revealPosition(vscode_languageserver_protocol_1.Position.create(range.end.line, 0), { vertical: 'centerIfOutsideViewport' });
    }
}
//# sourceMappingURL=dirty-diff-widget.js.map