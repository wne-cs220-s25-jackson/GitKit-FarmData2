"use strict";
// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", { value: true });
exports.VSXExtensionsModel = void 0;
const tslib_1 = require("tslib");
const inversify_1 = require("@theia/core/shared/inversify");
const p_debounce_1 = require("p-debounce");
const markdownit = require("@theia/core/shared/markdown-it");
const DOMPurify = require("@theia/core/shared/dompurify");
const event_1 = require("@theia/core/lib/common/event");
const cancellation_1 = require("@theia/core/lib/common/cancellation");
const hosted_plugin_1 = require("@theia/plugin-ext/lib/hosted/browser/hosted-plugin");
const vsx_extension_1 = require("./vsx-extension");
const progress_service_1 = require("@theia/core/lib/common/progress-service");
const vsx_extensions_search_model_1 = require("./vsx-extensions-search-model");
const browser_1 = require("@theia/core/lib/browser");
const browser_2 = require("@theia/workspace/lib/browser");
const uri_1 = require("@theia/core/lib/common/uri");
const ovsx_types_1 = require("@theia/ovsx-client/lib/ovsx-types");
const ovsx_client_provider_1 = require("../common/ovsx-client-provider");
const request_1 = require("@theia/core/shared/@theia/request");
const ovsx_client_1 = require("@theia/ovsx-client");
const application_protocol_1 = require("@theia/core/lib/common/application-protocol");
const file_service_1 = require("@theia/filesystem/lib/browser/file-service");
let VSXExtensionsModel = class VSXExtensionsModel {
    constructor() {
        /**
         * Single source for all extensions
         */
        this.extensions = new Map();
        this.onDidChangeEmitter = new event_1.Emitter();
        this._installed = new Set();
        this._recommended = new Set();
        this._searchResult = new Set();
        this.searchCancellationTokenSource = new cancellation_1.CancellationTokenSource();
        this.updateSearchResult = (0, p_debounce_1.default)(async () => {
            const { token } = this.resetSearchCancellationTokenSource();
            await this.doUpdateSearchResult({ query: this.search.query, includeAllVersions: true }, token);
        }, 500);
    }
    init() {
        this.initialized = this.doInit().catch(console.error);
    }
    async doInit() {
        await Promise.all([
            this.initInstalled(),
            this.initSearchResult(),
            this.initRecommended(),
        ]);
    }
    get onDidChange() {
        return this.onDidChangeEmitter.event;
    }
    get installed() {
        return this._installed.values();
    }
    get searchError() {
        return this._searchError;
    }
    get searchResult() {
        return this._searchResult.values();
    }
    get recommended() {
        return this._recommended.values();
    }
    setOnlyShowVerifiedExtensions(bool) {
        if (this.preferences.get('extensions.onlyShowVerifiedExtensions') !== bool) {
            this.preferences.updateValue('extensions.onlyShowVerifiedExtensions', bool);
        }
        this.updateSearchResult();
    }
    isInstalled(id) {
        return this._installed.has(id);
    }
    getExtension(id) {
        return this.extensions.get(id);
    }
    resolve(id) {
        return this.doChange(async () => {
            var _a;
            await this.initialized;
            const extension = (_a = await this.refresh(id)) !== null && _a !== void 0 ? _a : this.getExtension(id);
            if (!extension) {
                throw new Error(`Failed to resolve ${id} extension.`);
            }
            if (extension.readme === undefined) {
                try {
                    let rawReadme = '';
                    const installedReadme = await this.findReadmeFile(extension);
                    // Attempt to read the local readme first
                    // It saves network resources and is faster
                    if (installedReadme) {
                        const readmeContent = await this.fileService.readFile(installedReadme);
                        rawReadme = readmeContent.value.toString();
                    }
                    else if (extension.readmeUrl) {
                        rawReadme = request_1.RequestContext.asText(await this.request.request({ url: extension.readmeUrl }));
                    }
                    const readme = this.compileReadme(rawReadme);
                    extension.update({ readme });
                }
                catch (e) {
                    if (!ovsx_types_1.VSXResponseError.is(e) || e.statusCode !== 404) {
                        console.error(`[${id}]: failed to compile readme, reason:`, e);
                    }
                }
            }
            return extension;
        });
    }
    async findReadmeFile(extension) {
        var _a, _b;
        if (!extension.plugin) {
            return undefined;
        }
        // Since we don't know the exact capitalization of the readme file (might be README.md, readme.md, etc.)
        // We attempt to find the readme file by searching through the plugin's directories
        const packageUri = new uri_1.default(extension.plugin.metadata.model.packageUri);
        const pluginUri = packageUri.withPath(packageUri.path.join('..'));
        const pluginDirStat = await this.fileService.resolve(pluginUri);
        const possibleNames = ['readme.md', 'readme.txt', 'readme'];
        const readmeFileUri = (_b = (_a = pluginDirStat.children) === null || _a === void 0 ? void 0 : _a.find(child => possibleNames.includes(child.name.toLowerCase()))) === null || _b === void 0 ? void 0 : _b.resource;
        return readmeFileUri;
    }
    async initInstalled() {
        await this.pluginSupport.willStart;
        this.pluginSupport.onDidChangePlugins(() => this.updateInstalled());
        try {
            await this.updateInstalled();
        }
        catch (e) {
            console.error(e);
        }
    }
    async initSearchResult() {
        this.search.onDidChangeQuery(() => this.updateSearchResult());
        try {
            await this.updateSearchResult();
        }
        catch (e) {
            console.error(e);
        }
    }
    async initRecommended() {
        this.preferences.onPreferenceChanged(change => {
            if (change.preferenceName === 'extensions') {
                this.updateRecommended();
            }
        });
        await this.preferences.ready;
        try {
            await this.updateRecommended();
        }
        catch (e) {
            console.error(e);
        }
    }
    resetSearchCancellationTokenSource() {
        this.searchCancellationTokenSource.cancel();
        return this.searchCancellationTokenSource = new cancellation_1.CancellationTokenSource();
    }
    setExtension(id) {
        let extension = this.extensions.get(id);
        if (!extension) {
            extension = this.extensionFactory({ id });
            this.extensions.set(id, extension);
        }
        return extension;
    }
    doChange(task, token = cancellation_1.CancellationToken.None) {
        return this.progressService.withProgress('', 'extensions', async () => {
            if (token && token.isCancellationRequested) {
                return;
            }
            const result = await task();
            if (token && token.isCancellationRequested) {
                return;
            }
            this.onDidChangeEmitter.fire();
            return result;
        });
    }
    doUpdateSearchResult(param, token) {
        return this.doChange(async () => {
            this._searchResult = new Set();
            if (!param.query) {
                return;
            }
            const client = await this.clientProvider();
            const filter = await this.vsxApiFilter();
            try {
                const result = await client.search(param);
                if (token.isCancellationRequested) {
                    return;
                }
                for (const data of result.extensions) {
                    const id = data.namespace.toLowerCase() + '.' + data.name.toLowerCase();
                    const allVersions = filter.getLatestCompatibleVersion(data);
                    if (!allVersions) {
                        continue;
                    }
                    if (this.preferences.get('extensions.onlyShowVerifiedExtensions')) {
                        this.fetchVerifiedStatus(id, client, allVersions).then(verified => {
                            this.doChange(() => {
                                this.addExtensions(data, id, allVersions, !!verified);
                                return Promise.resolve();
                            });
                        });
                    }
                    else {
                        this.addExtensions(data, id, allVersions);
                        this.fetchVerifiedStatus(id, client, allVersions).then(verified => {
                            this.doChange(() => {
                                let extension = this.getExtension(id);
                                extension = this.setExtension(id);
                                extension.update(Object.assign({
                                    verified: verified
                                }));
                                return Promise.resolve();
                            });
                        });
                    }
                }
            }
            catch (error) {
                this._searchError = (error === null || error === void 0 ? void 0 : error.message) || String(error);
            }
        }, token);
    }
    async fetchVerifiedStatus(id, client, allVersions) {
        var _a;
        try {
            const res = await client.query({ extensionId: id, extensionVersion: allVersions.version, includeAllVersions: true });
            const extension = (_a = res.extensions) === null || _a === void 0 ? void 0 : _a[0];
            let verified = extension === null || extension === void 0 ? void 0 : extension.verified;
            if (!verified && (extension === null || extension === void 0 ? void 0 : extension.publishedBy.loginName) === 'open-vsx') {
                verified = true;
            }
            return verified;
        }
        catch (error) {
            console.error(error);
            return false;
        }
    }
    addExtensions(data, id, allVersions, verified) {
        if (!this.preferences.get('extensions.onlyShowVerifiedExtensions') || verified) {
            const extension = this.setExtension(id);
            extension.update(Object.assign(data, {
                publisher: data.namespace,
                downloadUrl: data.files.download,
                iconUrl: data.files.icon,
                readmeUrl: data.files.readme,
                licenseUrl: data.files.license,
                version: allVersions.version,
                verified: verified
            }));
            this._searchResult.add(id);
        }
    }
    async updateInstalled() {
        const prevInstalled = this._installed;
        return this.doChange(async () => {
            const plugins = this.pluginSupport.plugins;
            const currInstalled = new Set();
            const refreshing = [];
            for (const plugin of plugins) {
                if (plugin.model.engine.type === 'vscode') {
                    const version = plugin.model.version;
                    const id = plugin.model.id;
                    this._installed.delete(id);
                    const extension = this.setExtension(id);
                    currInstalled.add(extension.id);
                    refreshing.push(this.refresh(id, version));
                }
            }
            for (const id of this._installed) {
                const extension = this.getExtension(id);
                if (!extension) {
                    continue;
                }
                refreshing.push(this.refresh(id, extension.version));
            }
            const installed = new Set([...prevInstalled, ...currInstalled]);
            const installedSorted = Array.from(installed).sort((a, b) => this.compareExtensions(a, b));
            this._installed = new Set(installedSorted.values());
            await Promise.all(refreshing);
        });
    }
    updateRecommended() {
        return this.doChange(async () => {
            const allRecommendations = new Set();
            const allUnwantedRecommendations = new Set();
            const updateRecommendationsForScope = (scope, root) => {
                const { recommendations, unwantedRecommendations } = this.getRecommendationsForScope(scope, root);
                recommendations.forEach(recommendation => allRecommendations.add(recommendation));
                unwantedRecommendations.forEach(unwantedRecommendation => allUnwantedRecommendations.add(unwantedRecommendation));
            };
            updateRecommendationsForScope('defaultValue'); // In case there are application-default recommendations.
            const roots = await this.workspaceService.roots;
            for (const root of roots) {
                updateRecommendationsForScope('workspaceFolderValue', root.resource);
            }
            if (this.workspaceService.saved) {
                updateRecommendationsForScope('workspaceValue');
            }
            const recommendedSorted = new Set(Array.from(allRecommendations).sort((a, b) => this.compareExtensions(a, b)));
            allUnwantedRecommendations.forEach(unwantedRecommendation => recommendedSorted.delete(unwantedRecommendation));
            this._recommended = recommendedSorted;
            return Promise.all(Array.from(recommendedSorted, plugin => this.refresh(plugin)));
        });
    }
    getRecommendationsForScope(scope, root) {
        var _a, _b, _c;
        const configuredValue = (_a = this.preferences.inspect('extensions', root === null || root === void 0 ? void 0 : root.toString())) === null || _a === void 0 ? void 0 : _a[scope];
        return {
            recommendations: (_b = configuredValue === null || configuredValue === void 0 ? void 0 : configuredValue.recommendations) !== null && _b !== void 0 ? _b : [],
            unwantedRecommendations: (_c = configuredValue === null || configuredValue === void 0 ? void 0 : configuredValue.unwantedRecommendations) !== null && _c !== void 0 ? _c : [],
        };
    }
    compileReadme(readmeMarkdown) {
        const readmeHtml = markdownit({ html: true }).render(readmeMarkdown);
        return DOMPurify.sanitize(readmeHtml);
    }
    async refresh(id, version) {
        try {
            let extension = this.getExtension(id);
            if (!this.shouldRefresh(extension)) {
                return extension;
            }
            const filter = await this.vsxApiFilter();
            const targetPlatform = await this.applicationServer.getApplicationPlatform();
            let data;
            if (version === undefined) {
                data = await filter.findLatestCompatibleExtension({
                    extensionId: id,
                    includeAllVersions: true,
                    targetPlatform
                });
            }
            else {
                data = await filter.findLatestCompatibleExtension({
                    extensionId: id,
                    extensionVersion: version,
                    includeAllVersions: true,
                    targetPlatform
                });
            }
            if (!data) {
                return;
            }
            if (data.error) {
                return this.onDidFailRefresh(id, data.error);
            }
            if (!data.verified) {
                if (data.publishedBy.loginName === 'open-vsx') {
                    data.verified = true;
                }
            }
            extension = this.setExtension(id);
            extension.update(Object.assign(data, {
                publisher: data.namespace,
                downloadUrl: data.files.download,
                iconUrl: data.files.icon,
                readmeUrl: data.files.readme,
                licenseUrl: data.files.license,
                version: data.version,
                verified: data.verified
            }));
            return extension;
        }
        catch (e) {
            return this.onDidFailRefresh(id, e);
        }
    }
    /**
     * Determines if the given extension should be refreshed.
     * @param extension the extension to refresh.
     */
    shouldRefresh(extension) {
        if (extension === undefined) {
            return true;
        }
        return !extension.builtin;
    }
    onDidFailRefresh(id, error) {
        const cached = this.getExtension(id);
        if (cached && cached.installed) {
            return cached;
        }
        console.error(`[${id}]: failed to refresh, reason:`, error);
        return undefined;
    }
    /**
     * Compare two extensions based on their display name, and publisher if applicable.
     * @param a the first extension id for comparison.
     * @param b the second extension id for comparison.
     */
    compareExtensions(a, b) {
        const extensionA = this.getExtension(a);
        const extensionB = this.getExtension(b);
        if (!extensionA || !extensionB) {
            return 0;
        }
        if (extensionA.displayName && extensionB.displayName) {
            return extensionA.displayName.localeCompare(extensionB.displayName);
        }
        if (extensionA.publisher && extensionB.publisher) {
            return extensionA.publisher.localeCompare(extensionB.publisher);
        }
        return 0;
    }
};
exports.VSXExtensionsModel = VSXExtensionsModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(ovsx_client_provider_1.OVSXClientProvider),
    tslib_1.__metadata("design:type", Function)
], VSXExtensionsModel.prototype, "clientProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(hosted_plugin_1.HostedPluginSupport),
    tslib_1.__metadata("design:type", hosted_plugin_1.HostedPluginSupport)
], VSXExtensionsModel.prototype, "pluginSupport", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(vsx_extension_1.VSXExtensionFactory),
    tslib_1.__metadata("design:type", Function)
], VSXExtensionsModel.prototype, "extensionFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(progress_service_1.ProgressService),
    tslib_1.__metadata("design:type", progress_service_1.ProgressService)
], VSXExtensionsModel.prototype, "progressService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], VSXExtensionsModel.prototype, "preferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], VSXExtensionsModel.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(vsx_extensions_search_model_1.VSXExtensionsSearchModel),
    tslib_1.__metadata("design:type", vsx_extensions_search_model_1.VSXExtensionsSearchModel)
], VSXExtensionsModel.prototype, "search", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(request_1.RequestService),
    tslib_1.__metadata("design:type", Object)
], VSXExtensionsModel.prototype, "request", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(ovsx_client_1.OVSXApiFilterProvider),
    tslib_1.__metadata("design:type", Function)
], VSXExtensionsModel.prototype, "vsxApiFilter", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], VSXExtensionsModel.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_protocol_1.ApplicationServer),
    tslib_1.__metadata("design:type", Object)
], VSXExtensionsModel.prototype, "applicationServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], VSXExtensionsModel.prototype, "init", null);
exports.VSXExtensionsModel = VSXExtensionsModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], VSXExtensionsModel);
//# sourceMappingURL=vsx-extensions-model.js.map