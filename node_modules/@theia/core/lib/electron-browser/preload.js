"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preload = void 0;
const disposable_1 = require("../common/disposable");
const electron_api_1 = require("../electron-common/electron-api");
// eslint-disable-next-line import/no-extraneous-dependencies
const { ipcRenderer, contextBridge } = require('electron');
// a map of menuId => map<handler id => handler>
const commandHandlers = new Map();
let nextHandlerId = 1;
const mainMenuId = 1;
let nextMenuId = mainMenuId + 1;
let openUrlHandler;
ipcRenderer.on(electron_api_1.CHANNEL_OPEN_URL, async (event, url, replyChannel) => {
    if (openUrlHandler) {
        event.sender.send(replyChannel, await openUrlHandler(url));
    }
    else {
        event.sender.send(replyChannel, false);
    }
});
function convertMenu(menu, handlerMap) {
    if (!menu) {
        return undefined;
    }
    return menu.map(item => {
        let handlerId = undefined;
        if (item.execute) {
            handlerId = nextHandlerId++;
            handlerMap.set(handlerId, item.execute);
        }
        return {
            id: item.id,
            submenu: convertMenu(item.submenu, handlerMap),
            accelerator: item.accelerator,
            label: item.label,
            handlerId: handlerId,
            checked: item.checked,
            enabled: item.enabled,
            role: item.role,
            type: item.type,
            visible: item.visible
        };
    });
}
const api = {
    WindowMetadata: { webcontentId: 'none' },
    setMenuBarVisible: (visible, windowName) => ipcRenderer.send(electron_api_1.CHANNEL_SET_MENU_BAR_VISIBLE, visible, windowName),
    setMenu: (menu) => {
        commandHandlers.delete(mainMenuId);
        const handlers = new Map();
        commandHandlers.set(mainMenuId, handlers);
        ipcRenderer.send(electron_api_1.CHANNEL_SET_MENU, mainMenuId, convertMenu(menu, handlers));
    },
    getSecurityToken: () => ipcRenderer.sendSync(electron_api_1.CHANNEL_GET_SECURITY_TOKEN),
    focusWindow: (name) => ipcRenderer.send(electron_api_1.CHANNEL_FOCUS_WINDOW, name),
    showItemInFolder: fsPath => {
        ipcRenderer.send(electron_api_1.CHANNEL_SHOW_ITEM_IN_FOLDER, fsPath);
    },
    openWithSystemApp: location => {
        ipcRenderer.send(electron_api_1.CHANNEL_OPEN_WITH_SYSTEM_APP, location);
    },
    attachSecurityToken: (endpoint) => ipcRenderer.invoke(electron_api_1.CHANNEL_ATTACH_SECURITY_TOKEN, endpoint),
    popup: async function (menu, x, y, onClosed, windowName) {
        const menuId = nextMenuId++;
        const handlers = new Map();
        commandHandlers.set(menuId, handlers);
        const handle = await ipcRenderer.invoke(electron_api_1.CHANNEL_OPEN_POPUP, menuId, convertMenu(menu, handlers), x, y, windowName);
        const closeListener = () => {
            ipcRenderer.removeListener(electron_api_1.CHANNEL_ON_CLOSE_POPUP, closeListener);
            commandHandlers.delete(menuId);
            onClosed();
        };
        ipcRenderer.on(electron_api_1.CHANNEL_ON_CLOSE_POPUP, closeListener);
        return handle;
    },
    closePopup: function (handle) {
        ipcRenderer.send(electron_api_1.CHANNEL_CLOSE_POPUP, handle);
    },
    getTitleBarStyleAtStartup: function () {
        return ipcRenderer.invoke(electron_api_1.CHANNEL_GET_TITLE_STYLE_AT_STARTUP);
    },
    setTitleBarStyle: function (style) {
        ipcRenderer.send(electron_api_1.CHANNEL_SET_TITLE_STYLE, style);
    },
    setBackgroundColor: function (backgroundColor) {
        ipcRenderer.send(electron_api_1.CHANNEL_SET_BACKGROUND_COLOR, backgroundColor);
    },
    minimize: function () {
        ipcRenderer.send(electron_api_1.CHANNEL_MINIMIZE);
    },
    isMaximized: function () {
        return ipcRenderer.sendSync(electron_api_1.CHANNEL_IS_MAXIMIZED);
    },
    maximize: function () {
        ipcRenderer.send(electron_api_1.CHANNEL_MAXIMIZE);
    },
    unMaximize: function () {
        ipcRenderer.send(electron_api_1.CHANNEL_UNMAXIMIZE);
    },
    close: function () {
        ipcRenderer.send(electron_api_1.CHANNEL_CLOSE);
    },
    onAboutToClose(handler) {
        const h = (event, replyChannel) => {
            handler();
            event.sender.send(replyChannel);
        };
        ipcRenderer.on(electron_api_1.CHANNEL_ABOUT_TO_CLOSE, h);
        return disposable_1.Disposable.create(() => ipcRenderer.off(electron_api_1.CHANNEL_ABOUT_TO_CLOSE, h));
    },
    setOpenUrlHandler(handler) {
        openUrlHandler = handler;
    },
    onWindowEvent: function (event, handler) {
        const h = (_event, evt) => {
            if (event === evt) {
                handler();
            }
        };
        ipcRenderer.on(electron_api_1.CHANNEL_ON_WINDOW_EVENT, h);
        return disposable_1.Disposable.create(() => ipcRenderer.off(electron_api_1.CHANNEL_ON_WINDOW_EVENT, h));
    },
    setCloseRequestHandler: function (handler) {
        ipcRenderer.on(electron_api_1.CHANNEL_REQUEST_CLOSE, async (event, stopReason, confirmChannel, cancelChannel) => {
            try {
                if (await handler(stopReason)) {
                    event.sender.send(confirmChannel);
                    return;
                }
                ;
            }
            catch (e) {
                console.warn('exception in close handler ', e);
            }
            event.sender.send(cancelChannel);
        });
    },
    setSecondaryWindowCloseRequestHandler(windowName, handler) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const listener = async (event, name, confirmChannel, cancelChannel) => {
            if (name === windowName) {
                try {
                    if (await handler()) {
                        event.sender.send(confirmChannel);
                        ipcRenderer.removeListener(electron_api_1.CHANNEL_REQUEST_SECONDARY_CLOSE, listener);
                        return;
                    }
                    ;
                }
                catch (e) {
                    console.warn('exception in close handler ', e);
                }
                event.sender.send(cancelChannel);
            }
        };
        ipcRenderer.on(electron_api_1.CHANNEL_REQUEST_SECONDARY_CLOSE, listener);
    },
    toggleDevTools: function () {
        ipcRenderer.send(electron_api_1.CHANNEL_TOGGLE_DEVTOOLS);
    },
    getZoomLevel: function () {
        return ipcRenderer.invoke(electron_api_1.CHANNEL_GET_ZOOM_LEVEL);
    },
    setZoomLevel: function (desired) {
        ipcRenderer.send(electron_api_1.CHANNEL_SET_ZOOM_LEVEL, desired);
    },
    isFullScreenable: function () {
        return ipcRenderer.sendSync(electron_api_1.CHANNEL_IS_FULL_SCREENABLE);
    },
    isFullScreen: function () {
        return ipcRenderer.sendSync(electron_api_1.CHANNEL_IS_FULL_SCREEN);
    },
    toggleFullScreen: function () {
        ipcRenderer.send(electron_api_1.CHANNEL_TOGGLE_FULL_SCREEN);
    },
    requestReload: (newUrl) => ipcRenderer.send(electron_api_1.CHANNEL_REQUEST_RELOAD, newUrl),
    restart: () => ipcRenderer.send(electron_api_1.CHANNEL_RESTART),
    applicationStateChanged: state => {
        ipcRenderer.send(electron_api_1.CHANNEL_APP_STATE_CHANGED, state);
    },
    readClipboard() {
        return ipcRenderer.sendSync(electron_api_1.CHANNEL_READ_CLIPBOARD);
    },
    writeClipboard(text) {
        ipcRenderer.send(electron_api_1.CHANNEL_WRITE_CLIPBOARD, text);
    },
    onKeyboardLayoutChanged(handler) {
        return createDisposableListener(electron_api_1.CHANNEL_KEYBOARD_LAYOUT_CHANGED, (event, layout) => { handler(layout); });
    },
    onData: handler => createDisposableListener(electron_api_1.CHANNEL_IPC_CONNECTION, (event, data) => { handler(data); }),
    sendData: data => {
        ipcRenderer.send(electron_api_1.CHANNEL_IPC_CONNECTION, data);
    },
    useNativeElements: !('THEIA_ELECTRON_DISABLE_NATIVE_ELEMENTS' in process.env && process.env.THEIA_ELECTRON_DISABLE_NATIVE_ELEMENTS === '1')
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function createDisposableListener(channel, handler) {
    ipcRenderer.on(channel, handler);
    return disposable_1.Disposable.create(() => ipcRenderer.off(channel, handler));
}
function preload() {
    console.log('exposing theia core electron api');
    ipcRenderer.on(electron_api_1.CHANNEL_INVOKE_MENU, (_, menuId, handlerId) => {
        const map = commandHandlers.get(menuId);
        if (map) {
            const handler = map.get(handlerId);
            if (handler) {
                handler();
            }
        }
    });
    api.WindowMetadata.webcontentId = ipcRenderer.sendSync(electron_api_1.CHANNEL_WC_METADATA);
    contextBridge.exposeInMainWorld('electronTheiaCore', api);
}
exports.preload = preload;
//# sourceMappingURL=preload.js.map