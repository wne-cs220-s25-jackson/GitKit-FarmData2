"use strict";
var DefaultSecondaryWindowService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSecondaryWindowService = void 0;
const tslib_1 = require("tslib");
// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics, Ericsson, ARM, EclipseSource and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const inversify_1 = require("inversify");
const window_service_1 = require("./window-service");
const saveable_1 = require("../saveable");
const preferences_1 = require("../preferences");
const common_1 = require("../../common");
const saveable_service_1 = require("../saveable-service");
let DefaultSecondaryWindowService = DefaultSecondaryWindowService_1 = class DefaultSecondaryWindowService {
    constructor() {
        this.onWindowOpenedEmitter = new common_1.Emitter;
        this.onWindowOpened = this.onWindowOpenedEmitter.event;
        this.onWindowClosedEmitter = new common_1.Emitter;
        this.onWindowClosed = this.onWindowClosedEmitter.event;
        /**
         * Randomized prefix to be included in opened windows' ids.
         * This avoids conflicts when creating sub-windows from multiple theia instances (e.g. by opening Theia multiple times in the same browser)
         */
        this.prefix = crypto.getRandomValues(new Uint32Array(1))[0];
        /** Unique id. Increase after every access. */
        this.nextId = 0;
        this.secondaryWindows = [];
    }
    init() {
        // Set up messaging with secondary windows
        window.addEventListener('message', (event) => {
            console.trace('Message on main window', event);
            if (event.data.fromSecondary) {
                console.trace('Message comes from secondary window');
                return;
            }
            if (event.data.fromMain) {
                console.trace('Message has mainWindow marker, therefore ignore it');
                return;
            }
            // Filter setImmediate messages. Do not forward because these come in with very high frequency.
            // They are not needed in secondary windows because these messages are just a work around
            // to make setImmediate work in the main window: https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate
            if (typeof event.data === 'string' && event.data.startsWith('setImmediate')) {
                return;
            }
            console.trace('Delegate main window message to secondary windows', event);
            this.secondaryWindows.forEach(secondaryWindow => {
                if (!secondaryWindow.window.closed) {
                    secondaryWindow.window.postMessage({ ...event.data, fromMain: true }, '*');
                }
            });
        });
        // Close all open windows when the main window is closed.
        this.windowService.onUnload(() => {
            // Iterate backwards because calling window.close might remove the window from the array
            for (let i = this.secondaryWindows.length - 1; i >= 0; i--) {
                this.secondaryWindows[i].close();
            }
        });
    }
    createSecondaryWindow(widget, shell) {
        var _a;
        const [height, width, left, top] = this.findSecondaryWindowCoordinates(widget);
        let options = `popup=1,width=${width},height=${height},left=${left},top=${top}`;
        if (this.preferenceService.get('window.secondaryWindowAlwaysOnTop')) {
            options += ',alwaysOnTop=true';
        }
        const newWindow = (_a = window.open(DefaultSecondaryWindowService_1.SECONDARY_WINDOW_URL, this.nextWindowId(), options)) !== null && _a !== void 0 ? _a : undefined;
        if (newWindow) {
            this.secondaryWindows.push(newWindow);
            this.onWindowOpenedEmitter.fire(newWindow);
            newWindow.addEventListener('DOMContentLoaded', () => {
                newWindow.addEventListener('beforeunload', evt => {
                    const saveable = saveable_1.Saveable.get(widget);
                    const wouldLoseState = !!saveable && saveable.dirty && this.saveResourceService.autoSave === 'off';
                    if (wouldLoseState) {
                        evt.returnValue = '';
                        evt.preventDefault();
                        return 'non-empty';
                    }
                }, { capture: true });
                newWindow.addEventListener('unload', () => {
                    const saveable = saveable_1.Saveable.get(widget);
                    shell.closeWidget(widget.id, {
                        save: !!saveable && saveable.dirty && this.saveResourceService.autoSave !== 'off'
                    });
                    const extIndex = this.secondaryWindows.indexOf(newWindow);
                    if (extIndex > -1) {
                        this.onWindowClosedEmitter.fire(newWindow);
                        this.secondaryWindows.splice(extIndex, 1);
                    }
                    ;
                });
                this.windowCreated(newWindow, widget, shell);
            });
        }
        return newWindow;
    }
    windowCreated(newWindow, widget, shell) {
        newWindow.addEventListener('unload', () => {
            shell.closeWidget(widget.id);
        });
    }
    findWindow(windowName) {
        for (const w of this.secondaryWindows) {
            if (w.name === windowName) {
                return w;
            }
        }
        return undefined;
    }
    findSecondaryWindowCoordinates(widget) {
        const clientBounds = widget.node.getBoundingClientRect();
        const preference = this.preferenceService.get('window.secondaryWindowPlacement');
        let height;
        let width;
        let left;
        let top;
        const offsetY = 20; // Offset to avoid the window title bar
        switch (preference) {
            case 'originalSize': {
                height = widget.node.clientHeight;
                width = widget.node.clientWidth;
                left = window.screenLeft + clientBounds.x;
                top = window.screenTop + (window.outerHeight - window.innerHeight) + offsetY;
                if (common_1.environment.electron.is()) {
                    top = window.screenTop + clientBounds.y;
                }
                break;
            }
            case 'halfWidth': {
                height = window.innerHeight - (window.outerHeight - window.innerHeight);
                width = window.innerWidth / 2;
                left = window.screenLeft;
                top = window.screenTop;
                if (!common_1.environment.electron.is()) {
                    height = window.innerHeight + clientBounds.y - offsetY;
                }
                break;
            }
            case 'fullSize': {
                height = window.innerHeight - (window.outerHeight - window.innerHeight);
                width = window.innerWidth;
                left = window.screenLeft;
                top = window.screenTop;
                if (!common_1.environment.electron.is()) {
                    height = window.innerHeight + clientBounds.y - offsetY;
                }
                break;
            }
        }
        return [height, width, left, top];
    }
    focus(win) {
        win.focus();
    }
    nextWindowId() {
        return `${this.prefix}-secondaryWindow-${this.nextId++}`;
    }
};
exports.DefaultSecondaryWindowService = DefaultSecondaryWindowService;
// secondary-window.html is part of Theia's generated code. It is generated by dev-packages/application-manager/src/generator/frontend-generator.ts
DefaultSecondaryWindowService.SECONDARY_WINDOW_URL = 'secondary-window.html';
tslib_1.__decorate([
    (0, inversify_1.inject)(window_service_1.WindowService),
    tslib_1.__metadata("design:type", Object)
], DefaultSecondaryWindowService.prototype, "windowService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], DefaultSecondaryWindowService.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(saveable_service_1.SaveableService),
    tslib_1.__metadata("design:type", saveable_service_1.SaveableService)
], DefaultSecondaryWindowService.prototype, "saveResourceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DefaultSecondaryWindowService.prototype, "init", null);
exports.DefaultSecondaryWindowService = DefaultSecondaryWindowService = DefaultSecondaryWindowService_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DefaultSecondaryWindowService);
//# sourceMappingURL=default-secondary-window-service.js.map