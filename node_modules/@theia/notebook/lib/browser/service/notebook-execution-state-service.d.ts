import { Disposable, DisposableCollection, Emitter, URI } from '@theia/core';
import { NotebookService } from './notebook-service';
import { CellExecuteOutputEdit, CellExecuteOutputItemEdit, CellExecutionUpdateType, NotebookCellExecutionState } from '../../common';
import { CellEditOperation } from '../notebook-types';
import { NotebookModel } from '../view-model/notebook-model';
export type CellExecuteUpdate = CellExecuteOutputEdit | CellExecuteOutputItemEdit | CellExecutionStateUpdate;
export interface CellExecutionComplete {
    runEndTime?: number;
    lastRunSuccess?: boolean;
}
export interface CellExecutionStateUpdate {
    editType: CellExecutionUpdateType.ExecutionState;
    executionOrder?: number;
    runStartTime?: number;
    didPause?: boolean;
    isPaused?: boolean;
}
export declare enum NotebookExecutionType {
    cell = 0,
    notebook = 1
}
export interface NotebookFailStateChangedEvent {
    visible: boolean;
    notebook: URI;
}
export interface FailedCellInfo {
    cellHandle: number;
    disposable: Disposable;
    visible: boolean;
}
export declare class NotebookExecutionStateService implements Disposable {
    protected notebookService: NotebookService;
    protected toDispose: DisposableCollection;
    protected readonly executions: Map<string, Map<number, CellExecution>>;
    protected readonly onDidChangeExecutionEmitter: Emitter<CellExecutionStateChangedEvent>;
    onDidChangeExecution: import("@theia/core").Event<CellExecutionStateChangedEvent>;
    protected readonly onDidChangeLastRunFailStateEmitter: Emitter<NotebookFailStateChangedEvent>;
    onDidChangeLastRunFailState: import("@theia/core").Event<NotebookFailStateChangedEvent>;
    getOrCreateCellExecution(notebookUri: URI, cellHandle: number): CellExecution;
    protected createNotebookCellExecution(notebook: NotebookModel, cellHandle: number): CellExecution;
    protected onCellExecutionDidComplete(notebookUri: URI, cellHandle: number, exe: CellExecution, lastRunSuccess?: boolean): void;
    getCellExecution(cellUri: URI): CellExecution | undefined;
    dispose(): void;
}
export declare class CellExecution implements Disposable {
    readonly cellHandle: number;
    protected readonly notebook: NotebookModel;
    protected readonly onDidUpdateEmitter: Emitter<void>;
    readonly onDidUpdate: import("@theia/core").Event<void>;
    protected readonly onDidCompleteEmitter: Emitter<boolean | undefined>;
    readonly onDidComplete: import("@theia/core").Event<boolean | undefined>;
    toDispose: DisposableCollection;
    protected _state: NotebookCellExecutionState;
    get state(): NotebookCellExecutionState;
    get notebookURI(): URI;
    protected _didPause: boolean;
    get didPause(): boolean;
    protected _isPaused: boolean;
    get isPaused(): boolean;
    constructor(cellHandle: number, notebook: NotebookModel);
    initialize(): void;
    protected getCellLog(): string;
    confirm(): void;
    update(updates: CellExecuteUpdate[]): void;
    complete(completionData: CellExecutionComplete): void;
    dispose(): void;
    protected applyCellExecutionEditsToNotebook(edits: CellEditOperation[]): void;
}
export declare class CellExecutionStateChangedEvent {
    readonly notebook: URI;
    readonly cellHandle: number;
    readonly changed?: CellExecution | undefined;
    readonly type = NotebookExecutionType.cell;
    constructor(notebook: URI, cellHandle: number, changed?: CellExecution | undefined);
    affectsCell(cell: URI): boolean;
    affectsNotebook(notebook: URI): boolean;
}
export declare function updateToEdit(update: CellExecuteUpdate, cellHandle: number): CellEditOperation;
//# sourceMappingURL=notebook-execution-state-service.d.ts.map