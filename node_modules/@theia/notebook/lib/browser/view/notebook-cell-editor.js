"use strict";
// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", { value: true });
exports.CellEditor = exports.FIND_MATCH_DECORATION = exports.CURRENT_FIND_MATCH_DECORATION = void 0;
const React = require("@theia/core/shared/react");
const simple_monaco_editor_1 = require("@theia/monaco/lib/browser/simple-monaco-editor");
const monaco_editor_provider_1 = require("@theia/monaco/lib/browser/monaco-editor-provider");
const contextkey_1 = require("@theia/monaco-editor-core/esm/vs/platform/contextkey/common/contextkey");
const core_1 = require("@theia/core");
const notebook_context_keys_1 = require("../contributions/notebook-context-keys");
const editorExtensions_1 = require("@theia/monaco-editor-core/esm/vs/editor/browser/editorExtensions");
const textModel_1 = require("@theia/monaco-editor-core/esm/vs/editor/common/model/textModel");
const model_1 = require("@theia/monaco-editor-core/esm/vs/editor/common/model");
const browser_1 = require("@theia/core/lib/browser");
const DEFAULT_EDITOR_OPTIONS = {
    ...monaco_editor_provider_1.MonacoEditorProvider.inlineOptions,
    minHeight: -1,
    maxHeight: -1,
    scrollbar: {
        ...monaco_editor_provider_1.MonacoEditorProvider.inlineOptions.scrollbar,
        alwaysConsumeMouseWheel: false
    },
    lineDecorationsWidth: 10,
};
exports.CURRENT_FIND_MATCH_DECORATION = textModel_1.ModelDecorationOptions.register({
    description: 'current-find-match',
    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,
    zIndex: 13,
    className: 'currentFindMatch',
    inlineClassName: 'currentFindMatchInline',
    showIfCollapsed: true,
    overviewRuler: {
        color: 'editorOverviewRuler.findMatchForeground',
        position: model_1.OverviewRulerLane.Center
    }
});
exports.FIND_MATCH_DECORATION = textModel_1.ModelDecorationOptions.register({
    description: 'find-match',
    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,
    zIndex: 10,
    className: 'findMatch',
    inlineClassName: 'findMatchInline',
    showIfCollapsed: true,
    overviewRuler: {
        color: 'editorOverviewRuler.findMatchForeground',
        position: model_1.OverviewRulerLane.Center
    }
});
class CellEditor extends React.Component {
    constructor() {
        super(...arguments);
        this.toDispose = new core_1.DisposableCollection();
        this.matches = [];
        this.oldMatchDecorations = [];
        this.handleResize = () => {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.refresh();
        };
    }
    componentDidMount() {
        var _a;
        this.disposeEditor();
        this.toDispose.push(this.props.cell.onWillFocusCellEditor(focusRequest => {
            var _a, _b, _c, _d, _e, _f;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().focus();
            const lineCount = (_c = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getControl().getModel()) === null || _c === void 0 ? void 0 : _c.getLineCount();
            if (focusRequest && lineCount !== undefined) {
                (_d = this.editor) === null || _d === void 0 ? void 0 : _d.getControl().setPosition(focusRequest === 'lastLine' ?
                    { lineNumber: lineCount, column: 1 } :
                    { lineNumber: focusRequest, column: 1 }, 'keyboard');
            }
            const currentLine = (_f = (_e = this.editor) === null || _e === void 0 ? void 0 : _e.getControl().getPosition()) === null || _f === void 0 ? void 0 : _f.lineNumber;
            this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE, currentLine === 1);
            this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE, currentLine === lineCount);
        }));
        this.toDispose.push(this.props.cell.onWillBlurCellEditor(() => this.blurEditor()));
        this.toDispose.push(this.props.cell.onDidChangeEditorOptions(options => {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().updateOptions(options);
        }));
        this.toDispose.push(this.props.cell.onDidChangeLanguage(language => {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.setLanguage(language);
        }));
        this.toDispose.push(this.props.cell.onDidFindMatches(matches => {
            this.matches = matches;
            (0, browser_1.animationFrame)().then(() => this.setMatches());
        }));
        this.toDispose.push(this.props.cell.onDidSelectFindMatch(match => this.centerEditorInView()));
        this.toDispose.push(this.props.notebookModel.onDidChangeSelectedCell(e => {
            var _a;
            if (e.cell !== this.props.cell && ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().hasTextFocus())) {
                this.blurEditor();
            }
        }));
        if (!this.props.notebookViewportService || (this.container && this.props.notebookViewportService.isElementInViewport(this.container))) {
            this.initEditor();
        }
        else {
            const disposable = (_a = this.props.notebookViewportService) === null || _a === void 0 ? void 0 : _a.onDidChangeViewport(() => {
                if (!this.editor && this.container && this.props.notebookViewportService.isElementInViewport(this.container)) {
                    this.initEditor();
                    disposable.dispose();
                }
            });
            this.toDispose.push(disposable);
        }
        this.toDispose.push(this.props.cell.onDidRequestCenterEditor(() => {
            this.centerEditorInView();
        }));
    }
    componentWillUnmount() {
        this.disposeEditor();
    }
    disposeEditor() {
        if (this.editor) {
            this.props.notebookCellEditorService.editorDisposed(this.editor.uri);
        }
        this.toDispose.dispose();
        this.toDispose = new core_1.DisposableCollection();
    }
    centerEditorInView() {
        var _a, _b;
        const editorDomNode = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().getDomNode();
        if (editorDomNode) {
            editorDomNode.scrollIntoView({
                behavior: 'instant',
                block: 'center'
            });
        }
        else {
            (_b = this.container) === null || _b === void 0 ? void 0 : _b.scrollIntoView({
                behavior: 'instant',
                block: 'center'
            });
        }
    }
    async initEditor() {
        const { cell, notebookModel, monacoServices } = this.props;
        if (this.container) {
            const editorNode = this.container;
            editorNode.style.height = '';
            const editorModel = await cell.resolveTextModel();
            const uri = cell.uri;
            this.editor = new simple_monaco_editor_1.SimpleMonacoEditor(uri, editorModel, editorNode, monacoServices, { ...DEFAULT_EDITOR_OPTIONS, ...cell.editorOptions }, [[contextkey_1.IContextKeyService, this.props.notebookContextManager.scopedStore]], { contributions: editorExtensions_1.EditorExtensionsRegistry.getEditorContributions().filter(c => c.id !== 'editor.contrib.findController') });
            this.toDispose.push(this.editor);
            this.editor.setLanguage(cell.language);
            this.toDispose.push(this.editor.getControl().onDidContentSizeChange(() => {
                editorNode.style.height = this.editor.getControl().getContentHeight() + 7 + 'px';
                this.editor.setSize({ width: -1, height: this.editor.getControl().getContentHeight() });
            }));
            this.toDispose.push(this.editor.onDocumentContentChanged(e => {
                notebookModel.cellDirtyChanged(cell, true);
            }));
            this.toDispose.push(this.editor.getControl().onDidFocusEditorText(() => {
                this.props.notebookModel.setSelectedCell(cell, false);
                this.props.notebookCellEditorService.editorFocusChanged(this.editor);
            }));
            this.toDispose.push(this.editor.getControl().onDidBlurEditorText(() => {
                var _a;
                if (((_a = this.props.notebookCellEditorService.getActiveCell()) === null || _a === void 0 ? void 0 : _a.uri.toString()) === this.props.cell.uri.toString()) {
                    this.props.notebookCellEditorService.editorFocusChanged(undefined);
                }
            }));
            this.toDispose.push(this.editor.getControl().onDidChangeCursorSelection(e => {
                const selectedText = this.editor.getControl().getModel().getValueInRange(e.selection);
                // TODO handle secondary selections
                this.props.cell.selection = {
                    start: { line: e.selection.startLineNumber - 1, character: e.selection.startColumn - 1 },
                    end: { line: e.selection.endLineNumber - 1, character: e.selection.endColumn - 1 }
                };
                this.props.notebookModel.selectedText = selectedText;
            }));
            this.toDispose.push(this.editor.getControl().onDidChangeCursorPosition(e => {
                if (e.secondaryPositions.length === 0) {
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE, e.position.lineNumber === 1);
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE, e.position.lineNumber === this.editor.getControl().getModel().getLineCount());
                }
                else {
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE, false);
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE, false);
                }
            }));
            this.props.notebookCellEditorService.editorCreated(uri, this.editor);
            this.setMatches();
            if (notebookModel.selectedCell === cell) {
                this.editor.getControl().focus();
            }
        }
    }
    setMatches() {
        if (!this.editor) {
            return;
        }
        const decorations = [];
        for (const match of this.matches) {
            const decoration = match.selected ? exports.CURRENT_FIND_MATCH_DECORATION : exports.FIND_MATCH_DECORATION;
            decorations.push({
                range: {
                    startLineNumber: match.range.start.line,
                    startColumn: match.range.start.character,
                    endLineNumber: match.range.end.line,
                    endColumn: match.range.end.character
                },
                options: decoration
            });
        }
        this.oldMatchDecorations = this.editor.getControl()
            .changeDecorations(accessor => accessor.deltaDecorations(this.oldMatchDecorations, decorations));
    }
    setContainer(component) {
        this.container = component !== null && component !== void 0 ? component : undefined;
    }
    ;
    estimateHeight() {
        var _a, _b;
        const lineHeight = (_b = (_a = this.props.fontInfo) === null || _a === void 0 ? void 0 : _a.lineHeight) !== null && _b !== void 0 ? _b : 20;
        return this.props.cell.text.split(core_1.OS.backend.EOL).length * lineHeight + 10 + 7 + 'px';
    }
    render() {
        return React.createElement("div", { className: 'theia-notebook-cell-editor', onResize: this.handleResize, id: this.props.cell.uri.toString(), ref: container => this.setContainer(container), style: { height: this.editor ? undefined : this.estimateHeight() } });
    }
    blurEditor() {
        var _a;
        let parent = (_a = this.container) === null || _a === void 0 ? void 0 : _a.parentElement;
        while (parent && !parent.classList.contains('theia-notebook-cell')) {
            parent = parent.parentElement;
        }
        if (parent) {
            parent.focus();
        }
    }
}
exports.CellEditor = CellEditor;
//# sourceMappingURL=notebook-cell-editor.js.map