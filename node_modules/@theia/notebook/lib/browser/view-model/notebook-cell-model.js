"use strict";
// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotebookCodeEditorFindMatch = exports.NotebookCellModel = exports.createNotebookCellModelContainer = exports.NotebookCellModelFactory = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@theia/core");
const inversify_1 = require("@theia/core/shared/inversify");
const common_1 = require("../../common");
const notebook_monaco_text_model_service_1 = require("../service/notebook-monaco-text-model-service");
const notebook_cell_output_model_1 = require("./notebook-cell-output-model");
const browser_1 = require("@theia/core/lib/browser");
const notebook_preferences_1 = require("../contributions/notebook-preferences");
const language_service_1 = require("@theia/core/lib/browser/language-service");
exports.NotebookCellModelFactory = Symbol('NotebookModelFactory');
function createNotebookCellModelContainer(parent, props) {
    const child = parent.createChild();
    child.bind(NotebookCellModelProps).toConstantValue(props);
    child.bind(NotebookCellModel).toSelf();
    return child;
}
exports.createNotebookCellModelContainer = createNotebookCellModelContainer;
const NotebookCellModelProps = Symbol('NotebookModelProps');
let NotebookCellModel = class NotebookCellModel {
    constructor() {
        this.onDidChangeOutputsEmitter = new core_1.Emitter();
        this.onDidChangeOutputs = this.onDidChangeOutputsEmitter.event;
        this.onDidChangeOutputItemsEmitter = new core_1.Emitter();
        this.onDidChangeOutputItems = this.onDidChangeOutputItemsEmitter.event;
        this.onDidChangeContentEmitter = new core_1.Emitter();
        this.onDidChangeContent = this.onDidChangeContentEmitter.event;
        this.onDidChangeMetadataEmitter = new core_1.Emitter();
        this.onDidChangeMetadata = this.onDidChangeMetadataEmitter.event;
        this.onDidChangeInternalMetadataEmitter = new core_1.Emitter();
        this.onDidChangeInternalMetadata = this.onDidChangeInternalMetadataEmitter.event;
        this.onDidChangeLanguageEmitter = new core_1.Emitter();
        this.onDidChangeLanguage = this.onDidChangeLanguageEmitter.event;
        this.onDidRequestCellEditChangeEmitter = new core_1.Emitter();
        this.onDidRequestCellEditChange = this.onDidRequestCellEditChangeEmitter.event;
        this.onWillFocusCellEditorEmitter = new core_1.Emitter();
        this.onWillFocusCellEditor = this.onWillFocusCellEditorEmitter.event;
        this.onWillBlurCellEditorEmitter = new core_1.Emitter();
        this.onWillBlurCellEditor = this.onWillBlurCellEditorEmitter.event;
        this.onDidChangeEditorOptionsEmitter = new core_1.Emitter();
        this.onDidChangeEditorOptions = this.onDidChangeEditorOptionsEmitter.event;
        this.outputVisibilityChangeEmitter = new core_1.Emitter();
        this.onDidChangeOutputVisibility = this.outputVisibilityChangeEmitter.event;
        this.onDidFindMatchesEmitter = new core_1.Emitter();
        this.onDidFindMatches = this.onDidFindMatchesEmitter.event;
        this.onDidSelectFindMatchEmitter = new core_1.Emitter();
        this.onDidSelectFindMatch = this.onDidSelectFindMatchEmitter.event;
        this.onDidRequestCenterEditorEmitter = new core_1.Emitter();
        this.onDidRequestCenterEditor = this.onDidRequestCenterEditorEmitter.event;
        this.onDidCellHeightChangeEmitter = new core_1.Emitter();
        this.onDidCellHeightChange = this.onDidCellHeightChangeEmitter.event;
        this.toDispose = new core_1.DisposableCollection();
        this._editing = false;
        this._editorOptions = {};
        this._outputVisible = true;
        this._selection = undefined;
        this._cellheight = 0;
    }
    get outputs() {
        return this._outputs;
    }
    get metadata() {
        return this._metadata;
    }
    set metadata(newMetadata) {
        this._metadata = newMetadata;
        this.onDidChangeMetadataEmitter.fire();
    }
    get internalMetadata() {
        return this._internalMetadata;
    }
    set internalMetadata(newInternalMetadata) {
        const lastRunSuccessChanged = this._internalMetadata.lastRunSuccess !== newInternalMetadata.lastRunSuccess;
        newInternalMetadata = {
            ...newInternalMetadata,
            ...{ runStartTimeAdjustment: computeRunStartTimeAdjustment(this._internalMetadata, newInternalMetadata) }
        };
        this._internalMetadata = newInternalMetadata;
        this.onDidChangeInternalMetadataEmitter.fire({ lastRunSuccessChanged });
    }
    get text() {
        return this.textModel && !this.textModel.isDisposed() ? this.textModel.getText() : this.source;
    }
    get source() {
        return this.props.source;
    }
    set source(source) {
        var _a;
        this.props.source = source;
        (_a = this.textModel) === null || _a === void 0 ? void 0 : _a.textEditorModel.setValue(source);
    }
    get language() {
        return this.props.language;
    }
    set language(newLanguage) {
        if (this.language === newLanguage) {
            return;
        }
        if (this.textModel) {
            this.textModel.setLanguageId(newLanguage);
        }
        this.props.language = newLanguage;
        this.onDidChangeLanguageEmitter.fire(newLanguage);
        this.onDidChangeContentEmitter.fire('language');
    }
    get languageName() {
        var _a, _b;
        return (_b = (_a = this.languageService.getLanguage(this.language)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : this.language;
    }
    get uri() {
        return this.props.uri;
    }
    get handle() {
        return this.props.handle;
    }
    get cellKind() {
        return this.props.cellKind;
    }
    get editing() {
        return this._editing;
    }
    get editorOptions() {
        return this._editorOptions;
    }
    set editorOptions(options) {
        this._editorOptions = options;
        this.onDidChangeEditorOptionsEmitter.fire(options);
    }
    get outputVisible() {
        return this._outputVisible;
    }
    set outputVisible(visible) {
        if (this._outputVisible !== visible) {
            this._outputVisible = visible;
            this.outputVisibilityChangeEmitter.fire(visible);
        }
    }
    get selection() {
        return this._selection;
    }
    set selection(selection) {
        this._selection = selection;
    }
    get cellHeight() {
        return this._cellheight;
    }
    set cellHeight(height) {
        if (height !== this._cellheight) {
            this.onDidCellHeightChangeEmitter.fire(height);
            this._cellheight = height;
        }
    }
    init() {
        var _a, _b;
        this._outputs = this.props.outputs.map(op => new notebook_cell_output_model_1.NotebookCellOutputModel(op));
        this._metadata = (_a = this.props.metadata) !== null && _a !== void 0 ? _a : {};
        this._internalMetadata = (_b = this.props.internalMetadata) !== null && _b !== void 0 ? _b : {};
        this.editorOptions = {
            lineNumbers: this.preferenceService.get(notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS)
        };
        this.toDispose.push(this.preferenceService.onPreferenceChanged(e => {
            if (e.preferenceName === notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS) {
                this.editorOptions = {
                    ...this.editorOptions,
                    lineNumbers: this.preferenceService.get(notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS)
                };
            }
        }));
    }
    dispose() {
        this.onDidChangeOutputsEmitter.dispose();
        this.onDidChangeOutputItemsEmitter.dispose();
        this.onDidChangeContentEmitter.dispose();
        this.onDidChangeMetadataEmitter.dispose();
        this.onDidChangeInternalMetadataEmitter.dispose();
        this.onDidChangeLanguageEmitter.dispose();
        this.toDispose.dispose();
    }
    requestEdit() {
        if (!this.textModel || !this.textModel.readOnly) {
            this._editing = true;
            this.onDidRequestCellEditChangeEmitter.fire(true);
        }
    }
    requestStopEdit() {
        this._editing = false;
        this.onDidRequestCellEditChangeEmitter.fire(false);
    }
    requestFocusEditor(focusRequest) {
        this.requestEdit();
        this.onWillFocusCellEditorEmitter.fire(focusRequest);
    }
    requestBlurEditor() {
        this.requestStopEdit();
        this.onWillBlurCellEditorEmitter.fire();
    }
    requestCenterEditor() {
        this.onDidRequestCenterEditorEmitter.fire();
    }
    spliceNotebookCellOutputs(splice) {
        if (splice.deleteCount > 0 && splice.newOutputs.length > 0) {
            const commonLen = Math.min(splice.deleteCount, splice.newOutputs.length);
            // update
            for (let i = 0; i < commonLen; i++) {
                const currentOutput = this.outputs[splice.start + i];
                const newOutput = splice.newOutputs[i];
                this.replaceOutputData(currentOutput.outputId, newOutput);
            }
            this.outputs.splice(splice.start + commonLen, splice.deleteCount - commonLen, ...splice.newOutputs.slice(commonLen).map(op => new notebook_cell_output_model_1.NotebookCellOutputModel(op)));
            this.onDidChangeOutputsEmitter.fire({ start: splice.start + commonLen, deleteCount: splice.deleteCount - commonLen, newOutputs: splice.newOutputs.slice(commonLen) });
        }
        else {
            this.outputs.splice(splice.start, splice.deleteCount, ...splice.newOutputs.map(op => new notebook_cell_output_model_1.NotebookCellOutputModel(op)));
            this.onDidChangeOutputsEmitter.fire(splice);
        }
    }
    replaceOutputData(outputId, newOutputData) {
        const output = this.outputs.find(out => out.outputId === outputId);
        if (!output) {
            return false;
        }
        output.replaceData(newOutputData);
        this.onDidChangeOutputItemsEmitter.fire(output);
        return true;
    }
    changeOutputItems(outputId, append, items) {
        const output = this.outputs.find(out => out.outputId === outputId);
        if (!output) {
            return false;
        }
        if (append) {
            output.appendData(items);
        }
        else {
            output.replaceData({ outputId: outputId, outputs: items, metadata: output.metadata });
        }
        this.onDidChangeOutputItemsEmitter.fire(output);
        return true;
    }
    getData() {
        return {
            cellKind: this.cellKind,
            language: this.language,
            outputs: this.outputs.map(output => output.getData()),
            source: this.text,
            collapseState: this.props.collapseState,
            internalMetadata: this.internalMetadata,
            metadata: this.metadata
        };
    }
    async resolveTextModel() {
        if (this.textModel) {
            return this.textModel;
        }
        const ref = await this.textModelService.getOrCreateNotebookCellModelReference(this.uri);
        this.textModel = ref.object;
        this.toDispose.push(ref);
        this.toDispose.push(this.textModel.onDidChangeContent(e => {
            this.props.source = e.model.getText();
        }));
        return ref.object;
    }
    restartOutputRenderer(outputId) {
        const output = this.outputs.find(out => out.outputId === outputId);
        if (output) {
            this.onDidChangeOutputItemsEmitter.fire(output);
        }
    }
    showMatch(selected) {
        this.onDidSelectFindMatchEmitter.fire(selected);
    }
    findMatches(options) {
        var _a, _b;
        if (this.cellKind === common_1.CellKind.Markup && !this.editing) {
            return (_b = (_a = this.onMarkdownFind) === null || _a === void 0 ? void 0 : _a.call(this, options)) !== null && _b !== void 0 ? _b : [];
        }
        if (!this.textModel) {
            return [];
        }
        const matches = options.search ? this.textModel.findMatches({
            searchString: options.search,
            isRegex: options.regex,
            matchCase: options.matchCase,
            matchWholeWord: options.wholeWord
        }) : [];
        const editorFindMatches = matches.map(match => new NotebookCodeEditorFindMatch(this, match.range, this.textModel));
        this.onDidFindMatchesEmitter.fire(editorFindMatches);
        return editorFindMatches;
    }
    replaceAll(matches, value) {
        var _a;
        const editOperations = matches.map(match => ({
            range: {
                startColumn: match.range.start.character,
                startLineNumber: match.range.start.line,
                endColumn: match.range.end.character,
                endLineNumber: match.range.end.line
            },
            text: value
        }));
        (_a = this.textModel) === null || _a === void 0 ? void 0 : _a.textEditorModel.pushEditOperations(
        // eslint-disable-next-line no-null/no-null
        null, editOperations, 
        // eslint-disable-next-line no-null/no-null
        () => null);
    }
};
exports.NotebookCellModel = NotebookCellModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(NotebookCellModelProps),
    tslib_1.__metadata("design:type", Object)
], NotebookCellModel.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_monaco_text_model_service_1.NotebookMonacoTextModelService),
    tslib_1.__metadata("design:type", notebook_monaco_text_model_service_1.NotebookMonacoTextModelService)
], NotebookCellModel.prototype, "textModelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(language_service_1.LanguageService),
    tslib_1.__metadata("design:type", language_service_1.LanguageService)
], NotebookCellModel.prototype, "languageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], NotebookCellModel.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookCellModel.prototype, "init", null);
exports.NotebookCellModel = NotebookCellModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCellModel);
class NotebookCodeEditorFindMatch {
    constructor(cell, range, textModel) {
        this.cell = cell;
        this.range = range;
        this.textModel = textModel;
        this.selected = false;
    }
    show() {
        this.cell.showMatch(this);
    }
    replace(value) {
        this.textModel.textEditorModel.pushEditOperations(
        // eslint-disable-next-line no-null/no-null
        null, [{
                range: {
                    startColumn: this.range.start.character,
                    startLineNumber: this.range.start.line,
                    endColumn: this.range.end.character,
                    endLineNumber: this.range.end.line
                },
                text: value
            }], 
        // eslint-disable-next-line no-null/no-null
        () => null);
    }
}
exports.NotebookCodeEditorFindMatch = NotebookCodeEditorFindMatch;
function computeRunStartTimeAdjustment(oldMetadata, newMetadata) {
    if (oldMetadata.runStartTime !== newMetadata.runStartTime && typeof newMetadata.runStartTime === 'number') {
        const offset = Date.now() - newMetadata.runStartTime;
        return offset < 0 ? Math.abs(offset) : 0;
    }
    else {
        return newMetadata.runStartTimeAdjustment;
    }
}
//# sourceMappingURL=notebook-cell-model.js.map