import { Disposable, Emitter, Event, QueueableEmitter, Resource, URI } from '@theia/core';
import { Saveable, SaveOptions } from '@theia/core/lib/browser';
import { CellData, NotebookCellMetadata, NotebookData, NotebookDocumentMetadata } from '../../common';
import { NotebookContentChangedEvent, NotebookModelWillAddRemoveEvent, CellEditOperation, NullablePartialNotebookCellInternalMetadata, NullablePartialNotebookCellMetadata } from '../notebook-types';
import { NotebookSerializer } from '../service/notebook-service';
import { FileService } from '@theia/filesystem/lib/browser/file-service';
import { NotebookCellModel, NotebookCellModelFactory } from './notebook-cell-model';
import { interfaces } from '@theia/core/shared/inversify';
import { UndoRedoService } from '@theia/editor/lib/browser/undo-redo-service';
import { MarkdownString } from '@theia/core/lib/common/markdown-rendering';
import type { NotebookModelResolverService } from '../service/notebook-model-resolver-service';
import { BinaryBuffer } from '@theia/core/lib/common/buffer';
import { NotebookEditorFindMatch, NotebookEditorFindMatchOptions } from '../view/notebook-find-widget';
export declare const NotebookModelFactory: unique symbol;
export declare function createNotebookModelContainer(parent: interfaces.Container, props: NotebookModelProps): interfaces.Container;
export declare const NotebookModelResolverServiceProxy: unique symbol;
export interface NotebookModelProps {
    data: NotebookData;
    resource: Resource;
    viewType: string;
    serializer: NotebookSerializer;
}
export interface SelectedCellChangeEvent {
    cell: NotebookCellModel | undefined;
    scrollIntoView: boolean;
}
export declare class NotebookModel implements Saveable, Disposable {
    protected readonly onDirtyChangedEmitter: Emitter<void>;
    readonly onDirtyChanged: Event<void>;
    protected readonly onDidSaveNotebookEmitter: Emitter<void>;
    readonly onDidSaveNotebook: Event<void>;
    protected readonly onDidAddOrRemoveCellEmitter: Emitter<NotebookModelWillAddRemoveEvent>;
    readonly onDidAddOrRemoveCell: Event<NotebookModelWillAddRemoveEvent>;
    protected readonly onDidChangeContentEmitter: QueueableEmitter<NotebookContentChangedEvent>;
    readonly onDidChangeContent: Event<NotebookContentChangedEvent[]>;
    protected readonly onContentChangedEmitter: Emitter<void>;
    readonly onContentChanged: Event<void>;
    protected readonly onDidChangeSelectedCellEmitter: Emitter<SelectedCellChangeEvent>;
    readonly onDidChangeSelectedCell: Event<SelectedCellChangeEvent>;
    protected readonly onDidDisposeEmitter: Emitter<void>;
    readonly onDidDispose: Event<void>;
    get onDidChangeReadOnly(): Event<boolean | MarkdownString>;
    protected readonly fileService: FileService;
    protected readonly undoRedoService: UndoRedoService;
    protected props: NotebookModelProps;
    protected cellModelFactory: NotebookCellModelFactory;
    protected modelResolverService: NotebookModelResolverService;
    protected nextHandle: number;
    protected _dirty: boolean;
    set dirty(dirty: boolean);
    get dirty(): boolean;
    get readOnly(): boolean | MarkdownString;
    protected _selectedText: string;
    set selectedText(value: string);
    get selectedText(): string;
    selectedCell?: NotebookCellModel;
    protected dirtyCells: NotebookCellModel[];
    cells: NotebookCellModel[];
    get uri(): URI;
    get viewType(): string;
    metadata: NotebookDocumentMetadata;
    initialize(): void;
    dispose(): void;
    save(options?: SaveOptions): Promise<void>;
    createSnapshot(): Saveable.Snapshot;
    serialize(): Promise<BinaryBuffer>;
    applySnapshot(snapshot: Saveable.Snapshot): Promise<void>;
    revert(options?: Saveable.RevertOptions): Promise<void>;
    isDirty(): boolean;
    cellDirtyChanged(cell: NotebookCellModel, dirtyState: boolean): void;
    setData(data: NotebookData, markDirty?: boolean): void;
    getData(): NotebookData;
    undo(): void;
    redo(): void;
    setSelectedCell(cell: NotebookCellModel, scrollIntoView?: boolean): void;
    private addCellOutputListeners;
    getVisibleCells(): NotebookCellModel[];
    applyEdits(rawEdits: CellEditOperation[], computeUndoRedo: boolean): void;
    protected fireContentChange(): void;
    protected replaceCells(start: number, deleteCount: number, newCells: CellData[], computeUndoRedo: boolean, requestEdit: boolean): void;
    protected changeCellInternalMetadataPartial(cell: NotebookCellModel, internalMetadata: NullablePartialNotebookCellInternalMetadata): void;
    protected updateNotebookMetadata(metadata: NotebookDocumentMetadata, computeUndoRedo: boolean): void;
    protected changeCellMetadataPartial(cell: NotebookCellModel, metadata: NullablePartialNotebookCellMetadata, computeUndoRedo: boolean): void;
    protected changeCellMetadata(cell: NotebookCellModel, metadata: NotebookCellMetadata, computeUndoRedo: boolean): void;
    protected changeCellLanguage(cell: NotebookCellModel, languageId: string, computeUndoRedo: boolean): void;
    protected moveCellToIndex(fromIndex: number, length: number, toIndex: number, computeUndoRedo: boolean): boolean;
    getCellIndexByHandle(handle: number): number;
    getCellByHandle(handle: number): NotebookCellModel | undefined;
    protected isCellMetadataChanged(a: NotebookCellMetadata, b: NotebookCellMetadata): boolean;
    findMatches(options: NotebookEditorFindMatchOptions): NotebookEditorFindMatch[];
    replaceAll(matches: NotebookEditorFindMatch[], text: string): void;
}
//# sourceMappingURL=notebook-model.d.ts.map