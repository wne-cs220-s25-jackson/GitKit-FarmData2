import { Disposable, DisposableCollection, Emitter, Event, URI } from '@theia/core';
import { interfaces } from '@theia/core/shared/inversify';
import { MonacoEditorModel } from '@theia/monaco/lib/browser/monaco-editor-model';
import { type MonacoEditor } from '@theia/monaco/lib/browser/monaco-editor';
import { CellKind, NotebookCellCollapseState, NotebookCellInternalMetadata, NotebookCellMetadata, CellOutput, CellData, CellOutputItem } from '../../common';
import { NotebookCellOutputsSplice } from '../notebook-types';
import { NotebookMonacoTextModelService } from '../service/notebook-monaco-text-model-service';
import { NotebookCellOutputModel } from './notebook-cell-output-model';
import { PreferenceService } from '@theia/core/lib/browser';
import { LanguageService } from '@theia/core/lib/browser/language-service';
import { NotebookEditorFindMatch, NotebookEditorFindMatchOptions } from '../view/notebook-find-widget';
import { Range } from '@theia/core/shared/vscode-languageserver-protocol';
export declare const NotebookCellModelFactory: unique symbol;
export type NotebookCellModelFactory = (props: NotebookCellModelProps) => NotebookCellModel;
export type CellEditorFocusRequest = number | 'lastLine' | undefined;
export declare function createNotebookCellModelContainer(parent: interfaces.Container, props: NotebookCellModelProps): interfaces.Container;
export interface CellInternalMetadataChangedEvent {
    readonly lastRunSuccessChanged?: boolean;
}
export interface NotebookCell {
    readonly uri: URI;
    handle: number;
    language: string;
    cellKind: CellKind;
    outputs: CellOutput[];
    metadata: NotebookCellMetadata;
    internalMetadata: NotebookCellInternalMetadata;
    text: string;
    /**
     * The selection of the cell. Zero-based line/character coordinates.
     */
    selection: Range | undefined;
    onDidChangeOutputs?: Event<NotebookCellOutputsSplice>;
    onDidChangeOutputItems?: Event<CellOutput>;
    onDidChangeLanguage: Event<string>;
    onDidChangeMetadata: Event<void>;
    onDidChangeInternalMetadata: Event<CellInternalMetadataChangedEvent>;
}
export interface NotebookCellModelProps {
    readonly uri: URI;
    readonly handle: number;
    source: string;
    language: string;
    readonly cellKind: CellKind;
    outputs: CellOutput[];
    metadata?: NotebookCellMetadata | undefined;
    internalMetadata?: NotebookCellInternalMetadata | undefined;
    readonly collapseState?: NotebookCellCollapseState | undefined;
}
export declare class NotebookCellModel implements NotebookCell, Disposable {
    protected readonly onDidChangeOutputsEmitter: Emitter<NotebookCellOutputsSplice>;
    readonly onDidChangeOutputs: Event<NotebookCellOutputsSplice>;
    protected readonly onDidChangeOutputItemsEmitter: Emitter<CellOutput>;
    readonly onDidChangeOutputItems: Event<CellOutput>;
    protected readonly onDidChangeContentEmitter: Emitter<"content" | "language" | "mime">;
    readonly onDidChangeContent: Event<"content" | "language" | "mime">;
    protected readonly onDidChangeMetadataEmitter: Emitter<void>;
    readonly onDidChangeMetadata: Event<void>;
    protected readonly onDidChangeInternalMetadataEmitter: Emitter<CellInternalMetadataChangedEvent>;
    readonly onDidChangeInternalMetadata: Event<CellInternalMetadataChangedEvent>;
    protected readonly onDidChangeLanguageEmitter: Emitter<string>;
    readonly onDidChangeLanguage: Event<string>;
    protected readonly onDidRequestCellEditChangeEmitter: Emitter<boolean>;
    readonly onDidRequestCellEditChange: Event<boolean>;
    protected readonly onWillFocusCellEditorEmitter: Emitter<CellEditorFocusRequest>;
    readonly onWillFocusCellEditor: Event<CellEditorFocusRequest>;
    protected readonly onWillBlurCellEditorEmitter: Emitter<void>;
    readonly onWillBlurCellEditor: Event<void>;
    protected readonly onDidChangeEditorOptionsEmitter: Emitter<MonacoEditor.IOptions>;
    readonly onDidChangeEditorOptions: Event<MonacoEditor.IOptions>;
    protected readonly outputVisibilityChangeEmitter: Emitter<boolean>;
    readonly onDidChangeOutputVisibility: Event<boolean>;
    protected readonly onDidFindMatchesEmitter: Emitter<NotebookCodeEditorFindMatch[]>;
    readonly onDidFindMatches: Event<NotebookCodeEditorFindMatch[]>;
    protected readonly onDidSelectFindMatchEmitter: Emitter<NotebookCodeEditorFindMatch>;
    readonly onDidSelectFindMatch: Event<NotebookCodeEditorFindMatch>;
    protected onDidRequestCenterEditorEmitter: Emitter<void>;
    readonly onDidRequestCenterEditor: Event<void>;
    protected onDidCellHeightChangeEmitter: Emitter<number>;
    readonly onDidCellHeightChange: Event<number>;
    protected readonly props: NotebookCellModelProps;
    protected readonly textModelService: NotebookMonacoTextModelService;
    protected readonly languageService: LanguageService;
    protected readonly preferenceService: PreferenceService;
    get outputs(): NotebookCellOutputModel[];
    protected _outputs: NotebookCellOutputModel[];
    get metadata(): NotebookCellMetadata;
    set metadata(newMetadata: NotebookCellMetadata);
    protected _metadata: NotebookCellMetadata;
    protected toDispose: DisposableCollection;
    protected _internalMetadata: NotebookCellInternalMetadata;
    get internalMetadata(): NotebookCellInternalMetadata;
    set internalMetadata(newInternalMetadata: NotebookCellInternalMetadata);
    protected textModel?: MonacoEditorModel;
    get text(): string;
    get source(): string;
    set source(source: string);
    get language(): string;
    set language(newLanguage: string);
    get languageName(): string;
    get uri(): URI;
    get handle(): number;
    get cellKind(): CellKind;
    protected _editing: boolean;
    get editing(): boolean;
    protected _editorOptions: MonacoEditor.IOptions;
    get editorOptions(): Readonly<MonacoEditor.IOptions>;
    set editorOptions(options: MonacoEditor.IOptions);
    protected _outputVisible: boolean;
    get outputVisible(): boolean;
    set outputVisible(visible: boolean);
    protected _selection: Range | undefined;
    get selection(): Range | undefined;
    set selection(selection: Range | undefined);
    protected _cellheight: number;
    get cellHeight(): number;
    set cellHeight(height: number);
    protected init(): void;
    dispose(): void;
    requestEdit(): void;
    requestStopEdit(): void;
    requestFocusEditor(focusRequest?: CellEditorFocusRequest): void;
    requestBlurEditor(): void;
    requestCenterEditor(): void;
    spliceNotebookCellOutputs(splice: NotebookCellOutputsSplice): void;
    replaceOutputData(outputId: string, newOutputData: CellOutput): boolean;
    changeOutputItems(outputId: string, append: boolean, items: CellOutputItem[]): boolean;
    getData(): CellData;
    resolveTextModel(): Promise<MonacoEditorModel>;
    restartOutputRenderer(outputId: string): void;
    onMarkdownFind: ((options: NotebookEditorFindMatchOptions) => NotebookEditorFindMatch[]) | undefined;
    showMatch(selected: NotebookCodeEditorFindMatch): void;
    findMatches(options: NotebookEditorFindMatchOptions): NotebookEditorFindMatch[];
    replaceAll(matches: NotebookCodeEditorFindMatch[], value: string): void;
}
export interface NotebookCellFindMatches {
    matches: NotebookEditorFindMatch[];
    selected: NotebookEditorFindMatch;
}
export declare class NotebookCodeEditorFindMatch implements NotebookEditorFindMatch {
    readonly cell: NotebookCellModel;
    readonly range: Range;
    readonly textModel: MonacoEditorModel;
    selected: boolean;
    constructor(cell: NotebookCellModel, range: Range, textModel: MonacoEditorModel);
    show(): void;
    replace(value: string): void;
}
//# sourceMappingURL=notebook-cell-model.d.ts.map