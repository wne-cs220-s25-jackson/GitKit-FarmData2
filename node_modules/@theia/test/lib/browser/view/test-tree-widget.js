"use strict";
// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TestTreeWidget_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestTreeWidget = exports.TestTree = exports.TestItemNode = exports.TestControllerNode = exports.TestRoot = void 0;
const tslib_1 = require("tslib");
const inversify_1 = require("@theia/core/shared/inversify");
const tree_1 = require("@theia/core/lib/browser/tree");
const browser_1 = require("@theia/core/lib/browser");
const icon_theme_service_1 = require("@theia/core/lib/browser/icon-theme-service");
const theming_1 = require("@theia/core/lib/browser/theming");
const context_key_service_1 = require("@theia/core/lib/browser/context-key-service");
const test_service_1 = require("../test-service");
const React = require("@theia/core/shared/react");
const tree_delta_1 = require("../../common/tree-delta");
const core_1 = require("@theia/core");
const test_execution_state_manager_1 = require("./test-execution-state-manager");
const test_output_ui_model_1 = require("./test-output-ui-model");
const test_view_contribution_1 = require("./test-view-contribution");
const ROOT_ID = 'TestTree';
var TestRoot;
(function (TestRoot) {
    function is(node) {
        return tree_1.CompositeTreeNode.is(node) && node.id === ROOT_ID;
    }
    TestRoot.is = is;
})(TestRoot || (exports.TestRoot = TestRoot = {}));
var TestControllerNode;
(function (TestControllerNode) {
    function is(node) {
        return tree_1.ExpandableTreeNode.is(node) && 'controller' in node;
    }
    TestControllerNode.is = is;
})(TestControllerNode || (exports.TestControllerNode = TestControllerNode = {}));
var TestItemNode;
(function (TestItemNode) {
    function is(node) {
        return tree_1.TreeNode.is(node) && 'testItem' in node;
    }
    TestItemNode.is = is;
})(TestItemNode || (exports.TestItemNode = TestItemNode = {}));
let TestTree = class TestTree extends tree_1.TreeImpl {
    constructor() {
        super(...arguments);
        this.controllerListeners = new Map();
    }
    init() {
        this.testService.getControllers().forEach(controller => this.addController(controller));
        this.testService.onControllersChanged(e => {
            var _a, _b;
            (_a = e.removed) === null || _a === void 0 ? void 0 : _a.forEach(controller => {
                var _a;
                (_a = this.controllerListeners.get(controller)) === null || _a === void 0 ? void 0 : _a.dispose();
            });
            (_b = e.added) === null || _b === void 0 ? void 0 : _b.forEach(controller => this.addController(controller));
            this.refresh(this.root);
        });
    }
    addController(controller) {
        const listeners = new core_1.DisposableCollection();
        this.controllerListeners.set(controller.id, listeners);
        listeners.push(controller.onItemsChanged(delta => {
            this.processDeltas(controller, controller, delta);
        }));
    }
    async resolveChildren(parent) {
        if (TestItemNode.is(parent)) {
            parent.testItem.resolveChildren();
            return Promise.resolve(parent.testItem.tests.map(test => this.createTestNode(parent.controller, parent, test)));
        }
        else if (TestControllerNode.is(parent)) {
            return Promise.resolve(parent.controller.tests.map(test => this.createTestNode(parent.controller, parent, test)));
        }
        else if (TestRoot.is(parent)) {
            return Promise.resolve(this.testService.getControllers().map(controller => this.createControllerNode(parent, controller)));
        }
        else {
            return Promise.resolve([]);
        }
    }
    createControllerNode(parent, controller) {
        const node = {
            id: controller.id,
            name: controller.label,
            controller: controller,
            expanded: false,
            children: [],
            parent: parent
        };
        return node;
    }
    processDeltas(controller, parent, deltas) {
        deltas.forEach(delta => this.processDelta(controller, parent, delta));
    }
    processDelta(controller, parent, delta) {
        if (delta.type === tree_delta_1.DeltaKind.ADDED || delta.type === tree_delta_1.DeltaKind.REMOVED) {
            let node;
            if (parent === controller && delta.path.length === 1) {
                node = this.getNode(this.computeId([controller.id]));
            }
            else {
                const item = this.findInParent(parent, delta.path.slice(0, delta.path.length - 1), 0);
                if (item) {
                    node = this.getNode(this.computeId(this.computePath(controller, item)));
                }
            }
            if (node) {
                this.refresh(node); // we only have composite tree nodes in this tree
            }
            else {
                console.warn('delta for unknown test item');
            }
        }
        else {
            const item = this.findInParent(parent, delta.path, 0);
            if (item) {
                if (delta.type === tree_delta_1.DeltaKind.CHANGED) {
                    this.fireChanged();
                }
                if (delta.childDeltas) {
                    this.processDeltas(controller, item, delta.childDeltas);
                }
            }
            else {
                console.warn('delta for unknown test item');
            }
        }
    }
    findInParent(root, path, startIndex) {
        if (startIndex >= path.length) {
            return root;
        }
        const child = root.tests.find(candidate => candidate.id === path[startIndex]);
        if (!child) {
            return undefined;
        }
        return this.findInParent(child, path, startIndex + 1);
    }
    computePath(controller, item) {
        const result = [controller.id];
        let current = item;
        while (current) {
            result.unshift(current.id);
            current = current.parent;
        }
        return result;
    }
    computeId(path) {
        return path.map(id => id.replace('/', '//')).join('/');
    }
    createTestNode(controller, parent, test) {
        const previous = this.getNode(test.id);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = {
            id: this.computeId(this.computePath(controller, test)),
            name: test.label,
            controller: controller,
            testItem: test,
            expanded: tree_1.ExpandableTreeNode.is(previous) ? previous.expanded : undefined,
            selected: false,
            children: [],
            parent: parent
        };
        result.children = test.tests.map(t => this.createTestNode(controller, result, t));
        if (result.children.length === 0 && !test.canResolveChildren) {
            delete result.expanded;
        }
        return result;
    }
};
exports.TestTree = TestTree;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestTree.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestTree.prototype, "init", null);
exports.TestTree = TestTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TestTree);
let TestTreeWidget = TestTreeWidget_1 = class TestTreeWidget extends tree_1.TreeWidget {
    constructor(props, model, contextMenuRenderer) {
        super(props, model, contextMenuRenderer);
        this.id = TestTreeWidget_1.ID;
        this.title.label = core_1.nls.localizeByDefault('Test Explorer');
        this.title.caption = core_1.nls.localizeByDefault('Test Explorer');
        this.title.iconClass = (0, browser_1.codicon)('beaker');
        this.title.closable = true;
    }
    init() {
        super.init();
        this.addClass('theia-test-view');
        this.model.root = {
            id: ROOT_ID,
            parent: undefined,
            visible: false,
            children: []
        };
        this.uiModel.onDidChangeActiveTestRun(e => this.update());
        this.uiModel.onDidChangeActiveTestState(() => this.update());
        this.model.onSelectionChanged(() => {
            const that = this;
            const node = this.model.selectedNodes[0];
            if (TestItemNode.is(node)) {
                const run = that.uiModel.getActiveTestRun(node.controller);
                if (run) {
                    const output = run === null || run === void 0 ? void 0 : run.getOutput(node.testItem);
                    if (output) {
                        this.uiModel.selectedOutputSource = {
                            output: output,
                            onDidAddTestOutput: core_1.Event.map(run.onDidChangeTestOutput, evt => evt.filter(item => item[0] === node.testItem).map(item => item[1]))
                        };
                    }
                    this.uiModel.selectedTestState = run.getTestState(node.testItem);
                }
            }
        });
    }
    renderTree(model) {
        if (TestRoot.is(model.root) && model.root.children.length > 0) {
            return super.renderTree(model);
        }
        return React.createElement("div", { className: 'theia-widget-noInfo noMarkers' }, core_1.nls.localizeByDefault('No tests have been found in this workspace yet.'));
    }
    getTestStateClass(state) {
        switch (state) {
            case test_service_1.TestExecutionState.Queued: return `${(0, browser_1.codicon)('history')} queued`;
            case test_service_1.TestExecutionState.Running: return `${(0, browser_1.codicon)('sync')} codicon-modifier-spin running`;
            case test_service_1.TestExecutionState.Skipped: return `${(0, browser_1.codicon)('debug-step-over')} skipped`;
            case test_service_1.TestExecutionState.Failed: return `${(0, browser_1.codicon)('error')} failed`;
            case test_service_1.TestExecutionState.Errored: return `${(0, browser_1.codicon)('issues')} errored`;
            case test_service_1.TestExecutionState.Passed: return `${(0, browser_1.codicon)('pass')} passed`;
            case test_service_1.TestExecutionState.Running: return `${(0, browser_1.codicon)('sync-spin')} running`;
            default: return (0, browser_1.codicon)('circle');
        }
    }
    renderIcon(node, props) {
        var _a;
        if (TestItemNode.is(node)) {
            const currentRun = this.uiModel.getActiveTestRun(node.controller);
            let state;
            if (currentRun) {
                state = (_a = currentRun.getTestState(node.testItem)) === null || _a === void 0 ? void 0 : _a.state;
                if (!state) {
                    state = this.stateManager.getComputedState(currentRun, node.testItem);
                }
            }
            return React.createElement("div", { className: this.getTestStateClass(state) });
        }
        else {
            return super.renderIcon(node, props);
        }
    }
    renderTailDecorations(node, props) {
        if (TestItemNode.is(node)) {
            const testItem = node.testItem;
            return this.contextKeys.with({ view: this.id, controllerId: node.controller.id, testId: testItem.id, testItemHasUri: !!testItem.uri }, () => {
                const menu = this.menus.getMenu(test_view_contribution_1.TEST_VIEW_INLINE_MENU);
                const args = [node.testItem];
                const inlineCommands = menu.children.filter((item) => item instanceof core_1.ActionMenuNode);
                const tailDecorations = super.renderTailDecorations(node, props);
                return React.createElement(React.Fragment, null,
                    inlineCommands.length > 0 && React.createElement("div", { className: tree_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, inlineCommands.map((item, index) => this.renderInlineCommand(item, index, this.focusService.hasFocus(node), args))),
                    tailDecorations !== undefined && React.createElement("div", { className: tree_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, tailDecorations));
            });
        }
        else {
            return super.renderTailDecorations(node, props);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    renderInlineCommand(actionMenuNode, index, tabbable, args) {
        if (!actionMenuNode.icon || !this.commands.isVisible(actionMenuNode.command, ...args) || (actionMenuNode.when && !this.contextKeys.match(actionMenuNode.when))) {
            return false;
        }
        const className = [tree_1.TREE_NODE_SEGMENT_CLASS, tree_1.TREE_NODE_TAIL_CLASS, actionMenuNode.icon, browser_1.ACTION_ITEM, 'theia-test-tree-inline-action'].join(' ');
        const tabIndex = tabbable ? 0 : undefined;
        const titleString = actionMenuNode.label + this.resolveKeybindingForCommand(actionMenuNode.command);
        return React.createElement("div", { key: index, className: className, title: titleString, tabIndex: tabIndex, onClick: e => {
                e.stopPropagation();
                this.commands.executeCommand(actionMenuNode.command, ...args);
            } });
    }
    resolveKeybindingForCommand(command) {
        let result = '';
        if (command) {
            const bindings = this.keybindings.getKeybindingsForCommand(command);
            let found = false;
            if (bindings && bindings.length > 0) {
                bindings.forEach(binding => {
                    if (!found && this.keybindings.isEnabledInScope(binding, this.node)) {
                        found = true;
                        result = ` (${this.keybindings.acceleratorFor(binding, '+')})`;
                    }
                });
            }
        }
        return result;
    }
    toContextMenuArgs(node) {
        if (TestItemNode.is(node)) {
            return [node.testItem];
        }
        return [];
    }
    storeState() {
        return {}; // don't store any state for now
    }
};
exports.TestTreeWidget = TestTreeWidget;
TestTreeWidget.ID = 'test-tree-widget';
TestTreeWidget.TEST_CONTEXT_MENU = ['RESOURCE_CONTEXT_MENU'];
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], TestTreeWidget.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TestTreeWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], TestTreeWidget.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_execution_state_manager_1.TestExecutionStateManager),
    tslib_1.__metadata("design:type", test_execution_state_manager_1.TestExecutionStateManager)
], TestTreeWidget.prototype, "stateManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_output_ui_model_1.TestOutputUIModel),
    tslib_1.__metadata("design:type", test_output_ui_model_1.TestOutputUIModel)
], TestTreeWidget.prototype, "uiModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", core_1.MenuModelRegistry)
], TestTreeWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], TestTreeWidget.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], TestTreeWidget.prototype, "keybindings", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestTreeWidget.prototype, "init", null);
exports.TestTreeWidget = TestTreeWidget = TestTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(tree_1.TreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, Object, browser_1.ContextMenuRenderer])
], TestTreeWidget);
//# sourceMappingURL=test-tree-widget.js.map